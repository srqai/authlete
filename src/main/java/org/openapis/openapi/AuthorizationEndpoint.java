/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package org.openapis.openapi;

import static org.openapis.openapi.operations.Operations.RequestOperation;

import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import java.lang.Exception;
import java.lang.String;
import org.openapis.openapi.models.operations.AuthAuthorizationApiFormRequest;
import org.openapis.openapi.models.operations.AuthAuthorizationApiFormRequestBody;
import org.openapis.openapi.models.operations.AuthAuthorizationApiFormRequestBuilder;
import org.openapis.openapi.models.operations.AuthAuthorizationApiFormResponse;
import org.openapis.openapi.models.operations.AuthAuthorizationApiRequest;
import org.openapis.openapi.models.operations.AuthAuthorizationApiRequestBody;
import org.openapis.openapi.models.operations.AuthAuthorizationApiRequestBuilder;
import org.openapis.openapi.models.operations.AuthAuthorizationApiResponse;
import org.openapis.openapi.models.operations.PostApiServiceIdAuthAuthorizationTicketUpdateFormRequest;
import org.openapis.openapi.models.operations.PostApiServiceIdAuthAuthorizationTicketUpdateFormRequestBody;
import org.openapis.openapi.models.operations.PostApiServiceIdAuthAuthorizationTicketUpdateFormRequestBuilder;
import org.openapis.openapi.models.operations.PostApiServiceIdAuthAuthorizationTicketUpdateFormResponse;
import org.openapis.openapi.models.operations.PostApiServiceIdAuthAuthorizationTicketUpdateRequest;
import org.openapis.openapi.models.operations.PostApiServiceIdAuthAuthorizationTicketUpdateRequestBody;
import org.openapis.openapi.models.operations.PostApiServiceIdAuthAuthorizationTicketUpdateRequestBuilder;
import org.openapis.openapi.models.operations.PostApiServiceIdAuthAuthorizationTicketUpdateResponse;
import org.openapis.openapi.operations.AuthAuthorizationApi;
import org.openapis.openapi.operations.AuthAuthorizationApiForm;
import org.openapis.openapi.operations.PostApiServiceIdAuthAuthorizationTicketUpdate;
import org.openapis.openapi.operations.PostApiServiceIdAuthAuthorizationTicketUpdateForm;


public class AuthorizationEndpoint {
    private final SDKConfiguration sdkConfiguration;

    AuthorizationEndpoint(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
    }

    /**
     * Process Authorization Request
     * 
     * <p>This API parses request parameters of an authorization request and returns necessary data for the authorization server
     * implementation to process the authorization request further.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the authorization endpoint of
     * the service. The endpoint implementation must extract the request parameters from the authorization
     * request from the client application and pass them as the value of parameters request parameter for
     * Authlete's `/auth/authorization` API.
     * 
     * <p>The value of `parameters` is either (1) the entire query string when the HTTP method of the request
     * from the client application is `GET` or (2) the entire entity body (which is formatted in
     * `application/x-www-form-urlencoded`) when the HTTP method of the request from the client application
     * is `POST`.
     * 
     * <p>The following code snippet is an example in JAX-RS showing how to extract request parameters from
     * the authorization request.
     * 
     * <p>```java
     * @GET
     * public Response get(@Context UriInfo uriInfo)
     * {
     *     // The query parameters of the authorization request.
     *     String parameters = uriInfo.getRequestUri().getQuery();
     *     ......
     * }
     * 
     * <p>@POST
     * @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
     * public Response post(String parameters)
     * {
     *     // 'parameters' is the entity body of the authorization request.
     *     ......
     * }
     * ```
     * 
     * <p>The endpoint implementation does not have to parse the request parameters from the client application
     * because Authlete's `/auth/authorization` API does it.
     * 
     * <p>The response from `/auth/authorization` API has various parameters. Among them, it is `action`
     * parameter that the authorization server implementation should check first because it denotes the
     * next action that the authorization server implementation should take. According to the value of
     * `action`, the service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete.
     * In either case, from the viewpoint of the client application, it is an error on the server side.
     * Therefore, the service implementation should generate a response to the client application with
     * HTTP status of "500 Internal Server Error". Authlete recommends `application/json` as the content
     * type although OAuth 2.0 specification does not mention the format of the error response when the
     * redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application
     * since "500 Internal Server Error" is not required by OAuth 2.0.
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * is invalid.
     * 
     * <p>A response with HTTP status of "400 Bad Request" should be returned to the client application and
     * Authlete recommends `application/json` as the content type although OAuth 2.0 specification does
     * not mention the format of the error response when the redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application since
     * "400 Bad Request" is not required by OAuth 2.0.
     * 
     * <p>**LOCATION**
     * 
     * <p>When the value of `action` is `LOCATION`, it means that the request from the client application
     * is invalid but the redirect URI
     * to which the error should be reported has been determined.
     * 
     * <p>A response with HTTP status of "302 Found" must be returned to the client application with `Location`
     * header which has a redirect URI with error parameter.
     * 
     * <p>The value of `responseContent` is a redirect URI with `error` parameter, so it can be used as the
     * value of `Location` header.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 302 Found
     * Location: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORM**
     * 
     * <p>When the value of `action` is `FORM`, it means that the request from the client application is
     * invalid but the redirect URI to which the error should be reported has been determined, and that
     * the authorization request contains `response_mode=form_post` as is defined in [OAuth 2.0 Form Post
     * Response Mode](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html).
     * 
     * <p>The HTTP status of the response returned to the client application should be "200 OK" and the
     * content type should be `text/html;charset=UTF-8`.
     * 
     * <p>The value of `responseContent` is an HTML which can be used as the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Content-Type: text/html;charset=UTF-8
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>**NO_INTERACTION**
     * 
     * <p>When the value of `action` is `NO_INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request without displaying any user interface
     * pages for authentication or consent. This case happens when the authorization request contains
     * `prompt=none`.
     * 
     * <p>The service must follow the steps described below.
     * 
     * <p>[1] END-USER AUTHENTICATION
     * 
     * <p>Check whether an end-user has already logged in. If an end-user has logged in, go to the next step ([MAX_AGE]).
     * Otherwise, call Authlete's `/auth/authorization/fail` API with `reason=NOT_LOGGED_IN` and use the response from
     * the API to generate a response to the client application.
     * 
     * <p>[2] MAX AGE
     * 
     * <p>Get the value of `maxAge` parameter from the `/auth/authorization` API response. The value represents
     * the maximum authentication age which has come from `max_age` request parameter or `defaultMaxAge`
     * configuration parameter of the client application. If the value is `0`, go to the next step ([SUBJECT]).
     * Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Get the time at which the end-user was authenticated. that this value is not managed by Authlete,
     * meaning that it is expected that the service implementation manages the value. If the service implementation
     * does not manage authentication time of end-users, call Authlete's `/auth/authorization/fail` API
     * with `reason=MAX_AGE_NOT_SUPPORTED` and use the API response to generate a response to the client
     * application.
     * 
     * <p>(ii) Add the value of the maximum authentication age (which is represented in seconds) to the authentication
     * time. The calculated value is the expiration time.
     * 
     * <p>(iii) Check whether the calculated value is equal to or greater than the current time. If this condition
     * is satisfied, go to the next step ([SUBJECT]). Otherwise, call Authlete's `/auth/authorization/fail`
     * API with `reason=EXCEEDS_MAX_AGE` and use the API response to generate a response to the client
     * application.
     * 
     * <p>[3] SUBJECT
     * 
     * <p>Get the value of `subject` from the `/auth/authorization` API response. The value represents an
     * end-user who the client application expects to grant authorization. If the value is `null`, go to
     * the next step ([ACRs]). Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Compare the value of the requested subject to the current end-user.
     * 
     * <p>(ii) If they are equal, go to the next step ([ACRs]). If they are not equal, call Authlete's
     * `/auth/authorization/fail` API with `reason=DIFFERENT_SUBJECT` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>[4] ACRs
     * 
     * <p>Get the value of `acrs` from the `/auth/authorization` API response. The value represents a list
     * of ACRs (Authentication Context Class References) and comes from (1) acr claim in `claims` request
     * parameter, (2) `acr_values` request parameter, or (3) `default_acr_values` configuration parameter
     * of the client application.
     * 
     * <p>It is ensured that all the ACRs in acrs are supported by the authorization server implementation.
     * In other words, it is ensured that all the ACRs are listed in `acr_values_supported` configuration
     * parameter of the authorization server.
     * 
     * <p>If the value of ACRs is `null`, go to the next step ([ISSUE]). Otherwise, follow the sub steps
     * described below.
     * 
     * <p>(i) Get the ACR performed for the authentication of the current end-user. Note that this value is
     * managed not by Authlete but by the authorization server implementation. (If the authorization server
     * implementation cannot handle ACRs, it should not have listed ACRs as `acr_values_supported`.)
     * 
     * <p>(ii) Compare the ACR value obtained in the above step to each element in the ACR array (`acrs`)
     * in the listed order.
     * 
     * <p>(iii) If the ACR value was found in the array, (= the ACR performed for the authentication of the
     * current end-user did not match any one of the ACRs requested by the client application), check
     * whether one of the requested ACRs must be satisfied or not using `acrEssential` parameter in the
     * `/auth/authorization` API response. If the value of `acrEssential` parameter is `true`, call Authlete's
     * `/auth/authorization/fail` API with `reason=ACR_NOT_SATISFIED` and use the response from the API
     * to generate a response to the client application. Otherwise, go to the next step ([SCOPES]).
     * 
     * <p>[5] SCOPES
     * 
     * <p>Get the value of `scopes` from the `/auth/authorization` API response. If the array contains a
     * scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), which is only available in a dedicated/onpremise Authlete server (contact sales@authlete.com
     * for details).
     * 
     * <p>[6] DYNAMIC SCOPES
     * 
     * <p>Get the value of `dynamicScopes` from the `/auth/authorization` API response. If the array contains
     * a scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs) but dynamic scopes are not remembered as granted scopes.
     * 
     * <p>[7] RESOURCES
     * 
     * <p>Get the value of `resources` from the `/auth/authorization` API response. The array represents
     * the values of the `resource` request parameters. If you want to reject the request, call Authlete's
     * `/auth/authorization/fail` API with `reason=INVALID_TARGET` and use the response from the API to
     * generate a response to the client application. Otherwise, go to the next step ([ISSUE]).
     * 
     * <p>See "Resource Indicators for OAuth 2.0" for details.
     * 
     * <p>[8] ISSUE
     * 
     * <p>If all the above steps succeeded, the last step is to issue an authorization code, an ID token
     * and/or an access token. (There is a special case, though. In the case of `response_type=none`,
     * nothing is issued.) It can be performed by calling Authlete's `/auth/authorization/issue` API.
     * The API requires the following parameters. Prepare these parameters and call `/auth/authorization/issue`
     * API and use the response to generate a response to the client application.
     * 
     * <p>- &lt;u&gt;`ticket` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents a ticket which is exchanged with tokens at `/auth/authorization/issue`.
     *   Use the value of `ticket` contained in the `/auth/authorization` API response.
     * 
     * <p>- &lt;u&gt;`subject` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the unique identifier of the current end-user. It is often called "user ID"
     *   and it may or may not be visible to the user. In any case, it is a number or a string assigned
     *   to an end-user by the authorization server implementation. Authlete does not care about the format
     *   of the value of subject, but it must consist of only ASCII letters and its length must not exceed 100.
     * 
     * <p>  When the value of `subject` parameter in the /auth/authorization API response is not `null`,
     *   it is necessarily identical to the value of `subject` parameter in the `/auth/authorization/issue`
     *   API request.
     * 
     * <p>  The value of this parameter will be embedded in an ID token as the value of `sub` claim. When
     *   the value of `subject_type` configuration parameter of the client application is `PAIRWISE`,
     *   the value of sub claim is different from the value specified by this parameter, See [8. Subject
     *   Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes) of OpenID
     *   Connect Core 1.0 for details about subject types.
     * 
     * <p>  You can use the `sub` request parameter to adjust the value of the `sub` claim in an ID token.
     *   See the description of the `sub` request parameter for details.
     * 
     * <p>- &lt;u&gt;`authTime` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the time when the end-user authentication occurred. Its value is the
     *   number of seconds from `1970-01-01`. The value of this parameter will be embedded in an ID token
     *   as the value of `auth_time` claim.
     * 
     * <p>- &lt;u&gt;`acr` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the ACR (Authentication Context Class Reference) which the authentication
     *   of the end-user satisfies. When `acrs` in the `/auth/authorization` API response is a non-empty
     *   array and the value of `acrEssential` is `true`, the value of this parameter must be one of the
     *   array elements. Otherwise, even `null` is allowed. The value of this parameter will be embedded
     *   in an ID token as the value of `acr` claim.
     * 
     * <p>- &lt;u&gt;`claims` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents claims of the end-user. "Claims" here are pieces of information about
     *   the end-user such as `"name"`, `"email"` and `"birthdate"`. The authorization server implementation
     *   is required to gather claims of the end-user, format the claim values into JSON and set the JSON
     *   string as the value of this parameter.
     * 
     * <p>  The claims which the authorization server implementation is required to gather are listed in
     *   `claims` parameter in the `/auth/authorization` API response.
     * 
     * <p>  For example, if claims parameter lists `"name"`, `"email"` and `"birthdate"`, the value of this
     *   parameter should look like the following.
     * 
     * <p>  ```json
     *   {
     *     "name": "John Smith",
     *     "email": "john@example.com",
     *     "birthdate": "1974-05-06"
     *   }
     *   ```
     * 
     * <p>  `claimsLocales` parameter in the `/auth/authorization` API response lists the end-user's preferred
     *   languages and scripts, ordered by preference. When `claimsLocales` parameter is a non-empty array,
     *   its elements should be taken into account when the authorization server implementation gathers
     *   claim values. Especially, note the excerpt below from [5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
     *   of OpenID Connect Core 1.0.
     * 
     * <p>  &gt; When the OP determines, either through the `claims_locales` parameter, or by other means, that
     *   the End-User and Client are requesting Claims in only one set of languages and scripts, it is
     *   RECOMMENDED that OPs return Claims without language tags when they employ this language and script.
     *   It is also RECOMMENDED that Clients be written in a manner that they can handle and utilize Claims
     *   using language tags.
     * 
     * <p>  If `claims` parameter in the `/auth/authorization` API response is `null` or an empty array,
     *   the value of this parameter should be `null`.
     * 
     * <p>  See [5.1. Standard Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)
     *   of OpenID Connect core 1.0 for claim names and their value formats. Note (1) that the authorization
     *   server implementation support its special claims ([5.1.2. Additional Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims))
     *   and (2) that claim names may be followed by a language tag ([5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)).
     *   Read the specification of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
     *   for details.
     * 
     * <p>  The claim values in this parameter will be embedded in an ID token.
     * 
     * <p>  Note that `idTokenClaims` parameter is available in the `/auth/authorization` API response.
     *   The parameter has the value of the `"id_token"` property in the `claims` request parameter or
     *   in the `"claims"` property in a request object. The value of this parameter should be considered
     *   when you prepare claim values.
     * 
     * <p>- &lt;u&gt;`properties` (optional)&lt;/u&gt;&lt;br&gt;
     *   Extra properties to associate with an access token and/or an authorization code that may be issued
     *   by this request. Note that `properties` parameter is accepted only when `Content-Type` of the
     *   request is `application/json`, so don't use `application/x-www-form-urlencoded` for details.
     * 
     * <p>- &lt;u&gt;`scopes` (optional)&lt;/u&gt;&lt;br&gt;
     *   Scopes to associate with an access token and/or an authorization code. If this parameter is `null`,
     *   the scopes specified in the original authorization request from the client application are used.
     *   In other cases, including the case of an empty array, the specified scopes will replace the original
     *   scopes contained in the original authorization request.
     * 
     * <p>  Even scopes that are not included in the original authorization request can be specified. However,
     *   as an exception, `openid` scope is ignored on the server side if it is not included in the original
     *   request. It is because the existence of `openid` scope considerably changes the validation steps
     *   and because adding `openid` triggers generation of an ID token (although the client application
     *   has not requested it) and the behavior is a major violation against the specification.
     * 
     * <p>  If you add `offline_access` scope although it is not included in the original request, keep in
     *   mind that the specification requires explicit consent from the user for the scope ([OpenID Connect
     *   Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess)).
     *   When `offline_access` is included in the original request, the current implementation of Authlete's
     *   `/auth/authorization` API checks whether the request has come along with `prompt` request parameter
     *   and the value includes consent. However, note that the implementation of Authlete's `/auth/authorization/issue`
     *   API does not perform such checking if `offline_access` scope is added via this `scopes` parameter.
     * 
     * <p>- &lt;u&gt;`sub` (optional)&lt;/u&gt;&lt;br&gt;
     *   The value of the `sub` claim in an ID token. If the value of this request parameter is not empty,
     *   it is used as the value of the `sub` claim. Otherwise, the value of the `subject` request parameter
     *   is used as the value of the `sub` claim. The main purpose of this parameter is to hide the actual
     *   value of the subject from client applications.
     * 
     * <p>  Note that even if this `sub` parameter is not empty, the value of the subject request parameter
     *   is used as the value of the subject which is associated with the access token.
     * 
     * <p>**INTERACTION**
     * 
     * <p>When the value of `action` is `INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request with user interaction by an HTML form.
     * The purpose of the UI displayed to the end-user is to ask the end-user to grant authorization to
     * the client application. The items described below are some points which the service implementation
     * should take into account when it builds the UI.
     * 
     * <p>[1] DISPLAY MODE
     * 
     * <p>The response from `/auth/authorization` API has `display` parameter. It is one of `PAGE` (default),
     * `POPUP`, `TOUCH` and `WAP` The meanings of the values are described in [3.1.2.1. Authentication
     * Request of OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * Basically, the authorization server implementation should display the UI which is suitable for the
     * display mode, but it is okay for the authorization server implementation to "attempt to detect the
     * capabilities of the User Agent and present an appropriate display".
     * 
     * <p>It is ensured that the value of `display` is one of the supported display modes which are specified
     * by `supportedDisplays` configuration parameter of the service.
     * 
     * <p>[2] UI LOCALE
     * 
     * <p>The response from `/auth/authorization` API has `uiLocales` parameter. It it is not `null`, it lists
     * language tag values (such as `fr-CA`, `ja-JP` and `en`) ordered by preference. The service implementation
     * should display the UI in one of the language listed in the parameter when possible. It is ensured
     * that language tags listed in `uiLocales` are contained in the list of supported UI locales which
     * are specified by `supportedUiLocales` configuration parameter of the service.
     * 
     * <p>[3] CLIENT INFORMATION
     * 
     * <p>The authorization server implementation should show information about the client application to
     * the end-user. The information is embedded in `client` parameter in the response from `/auth/authorization`
     * API.
     * 
     * <p>[4] SCOPES
     * 
     * <p>A client application requires authorization for specific permissions. In OAuth 2.0 specification,
     * "scope" is a technical term which represents a permission. `scopes` parameter in the response
     * from `/auth/authorization` API is a list of scopes requested by the client application. The service
     * implementation should show the end-user the scopes.
     * 
     * <p>The authorization server implementation may choose not to show scopes to which the end-user has
     * given consent in the past. To put it the other way around, the authorization server implementation
     * may show only the scopes to which the end-user has not given consent yet. However, if the value
     * of `prompts` response parameter contains `CONSENT`, the authorization server implementation has
     * to obtain explicit consent from the end-user even if the end-user has given consent to all the
     * requested scopes in the past.
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), but the APIs work only in the case the Authlete server you use is a dedicated Authlete server
     * (contact sales@authlete.com for details). In other words, the APIs of the shared Authlete server
     * are disabled intentionally (in order to prevent garbage data from being accumulated) and they
     * return 403 Forbidden.
     * 
     * <p>It is ensured that the values in `scopes` parameter are contained in the list of supported scopes
     * which are specified by `supportedScopes` configuration parameter of the service.
     * 
     * <p>[5] DYNAMIC SCOPES
     * 
     * <p>The authorization request may include dynamic scopes. The list of recognized dynamic scopes are
     * accessible by getDynamicScopes() method. See the description of the [DynamicScope](https://authlete.github.io/authlete-java-common/com/authlete/common/dto/DynamicScope.html)
     * class for details about dynamic scopes.
     * 
     * <p>[6] AUTHORIZATION DETAILS
     * 
     * <p>The authorization server implementation should show the end-user "authorization details" if the
     * request includes it. The value of `authorization_details` parameter in the response is the content
     * of the `authorization_details` request parameter.
     * 
     * <p>See "OAuth 2.0 Rich Authorization Requests" for details.
     * 
     * <p>[7] PURPOSE
     * 
     * <p>The authorization server implementation must show the value of the `purpose` request parameter if
     * it supports [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html).
     * See [8. Transaction-specific Purpose](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.8)
     * in the specification for details.
     * 
     * <p>Note that the value of `purpose` response parameter is the value of the purpose request parameter.
     * 
     * <p>[7] END-USER AUTHENTICATION
     * 
     * <p>Necessarily, the end-user must be authenticated (= must login the service) before granting authorization
     * to the client application. Simply put, a login form is expected to be displayed for end-user authentication.
     * The service implementation must follow the steps described below to comply with OpenID Connect.
     * (Or just always show a login form if it's too much of a bother.)
     * 
     * <p>(i) Get the value of `prompts` response parameter. It corresponds to the value of the `prompt`
     * request parameter. Details of the request parameter are described in [3.1.2.1. Authentication
     * Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) of OpenID Connect Core 1.0.
     * 
     * <p>(ii) If the value of `prompts` parameter is `SELECT_ACCOUNT` display a form to let the end-user
     * select on of his/her accounts for login. If `subject` response parameter is not `null`, it is the
     * end-user ID that the client application expects, so the value should be used to determine the value
     * of the login ID. Note that a subject and a login ID are not necessarily equal. If the value of
     * `subject` response parameter is `null`, the value of `loginHint` response parameter should be referred
     * to as a hint to determine the value of the login ID. The value of `loginHint` response parameter
     * is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iii) If the value of `prompts` response parameter contains `LOGIN`, display a form to urge the
     * end-user to login even if the end-user has already logged in. If the value of `subject` response
     * parameter is not `null`, it is the end-user ID that the client application expects, so the value
     * should be used to determine the value of the login ID. Note that a subject and a login ID are not
     * necessarily equal. If the value of `subject` response parameter is `null`, the value of `loginHint`
     * response parameter should be referred to as a hint to determine the value of the login ID. The value
     * of `loginHint` response parameter is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iv) If the value of `prompts` response parameter does not contain `LOGIN`, the authorization server
     * implementation does not have to authenticate the end-user if all the conditions described below
     * are satisfied. If any one of the conditions is not satisfied, show a login form to authenticate
     * the end-user.
     * 
     * <p>- An end-user has already logged in the service.
     * 
     * <p>- The login ID of the current end-user matches the value of `subject` response parameter.
     * This check is required only when the value of `subject` response parameter is a non-null value.
     * 
     * <p>- The max age, which is the number of seconds contained in `maxAge` response parameter,
     * has not passed since the current end-user logged in your service. This check is required only when
     * the value of `maxAge` response parameter is a non-zero value.
     * 
     * <p>- If the authorization server implementation does not manage authentication time of end-users
     * (= if the authorization server implementation cannot know when end-users logged in) and if the
     * value of `maxAge` response parameter is a non-zero value, a login form should be displayed.
     * 
     * <p>- The ACR (Authentication Context Class Reference) of the authentication performed for
     * the current end-user satisfies one of the ACRs listed in `acrs` response parameter. This check is
     * required only when the value of `acrs` response parameter is a non-empty array.
     * 
     * <p>In every case, the end-user authentication must satisfy one of the ACRs listed in `acrs` response
     * parameter when the value of `acrs` response parameter is a non-empty array and `acrEssential`
     * response parameter is `true`.
     * 
     * <p>[9] GRANT/DENY BUTTONS
     * 
     * <p>The end-user is supposed to choose either (1) to grant authorization to the client application or
     * (2) to deny the authorization request. The UI must have UI components to accept the judgment by
     * the user. Usually, a button to grant authorization and a button to deny the request are provided.
     * 
     * <p>When the value of `subject` response parameter is not `null`, the end-user authentication must be
     * performed for the subject, meaning that the authorization server implementation should repeatedly
     * show a login form until the subject is successfully authenticated.
     * 
     * <p>The end-user will choose either (1) to grant authorization to the client application or (2) to
     * deny the authorization request. When the end-user chose to deny the authorization request, call
     * Authlete's `/auth/authorization/fail` API with `reason=DENIED` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>When the end-user chose to grant authorization to the client application, the authorization server
     * implementation has to issue an authorization code, an ID token, and/or an access token to the client
     * application. (There is a special case. When `response_type=none`, nothing is issued.) Issuing the
     * tokens can be performed by calling Authlete's `/auth/authorization/issue` API. Read [ISSUE] written
     * above in the description for the case of `action=NO_INTERACTION`.
     * &lt;/details&gt;
     * 
     * @return The call builder
     */
    public AuthAuthorizationApiRequestBuilder process() {
        return new AuthAuthorizationApiRequestBuilder(sdkConfiguration);
    }

    /**
     * Process Authorization Request
     * 
     * <p>This API parses request parameters of an authorization request and returns necessary data for the authorization server
     * implementation to process the authorization request further.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the authorization endpoint of
     * the service. The endpoint implementation must extract the request parameters from the authorization
     * request from the client application and pass them as the value of parameters request parameter for
     * Authlete's `/auth/authorization` API.
     * 
     * <p>The value of `parameters` is either (1) the entire query string when the HTTP method of the request
     * from the client application is `GET` or (2) the entire entity body (which is formatted in
     * `application/x-www-form-urlencoded`) when the HTTP method of the request from the client application
     * is `POST`.
     * 
     * <p>The following code snippet is an example in JAX-RS showing how to extract request parameters from
     * the authorization request.
     * 
     * <p>```java
     * @GET
     * public Response get(@Context UriInfo uriInfo)
     * {
     *     // The query parameters of the authorization request.
     *     String parameters = uriInfo.getRequestUri().getQuery();
     *     ......
     * }
     * 
     * <p>@POST
     * @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
     * public Response post(String parameters)
     * {
     *     // 'parameters' is the entity body of the authorization request.
     *     ......
     * }
     * ```
     * 
     * <p>The endpoint implementation does not have to parse the request parameters from the client application
     * because Authlete's `/auth/authorization` API does it.
     * 
     * <p>The response from `/auth/authorization` API has various parameters. Among them, it is `action`
     * parameter that the authorization server implementation should check first because it denotes the
     * next action that the authorization server implementation should take. According to the value of
     * `action`, the service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete.
     * In either case, from the viewpoint of the client application, it is an error on the server side.
     * Therefore, the service implementation should generate a response to the client application with
     * HTTP status of "500 Internal Server Error". Authlete recommends `application/json` as the content
     * type although OAuth 2.0 specification does not mention the format of the error response when the
     * redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application
     * since "500 Internal Server Error" is not required by OAuth 2.0.
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * is invalid.
     * 
     * <p>A response with HTTP status of "400 Bad Request" should be returned to the client application and
     * Authlete recommends `application/json` as the content type although OAuth 2.0 specification does
     * not mention the format of the error response when the redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application since
     * "400 Bad Request" is not required by OAuth 2.0.
     * 
     * <p>**LOCATION**
     * 
     * <p>When the value of `action` is `LOCATION`, it means that the request from the client application
     * is invalid but the redirect URI
     * to which the error should be reported has been determined.
     * 
     * <p>A response with HTTP status of "302 Found" must be returned to the client application with `Location`
     * header which has a redirect URI with error parameter.
     * 
     * <p>The value of `responseContent` is a redirect URI with `error` parameter, so it can be used as the
     * value of `Location` header.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 302 Found
     * Location: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORM**
     * 
     * <p>When the value of `action` is `FORM`, it means that the request from the client application is
     * invalid but the redirect URI to which the error should be reported has been determined, and that
     * the authorization request contains `response_mode=form_post` as is defined in [OAuth 2.0 Form Post
     * Response Mode](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html).
     * 
     * <p>The HTTP status of the response returned to the client application should be "200 OK" and the
     * content type should be `text/html;charset=UTF-8`.
     * 
     * <p>The value of `responseContent` is an HTML which can be used as the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Content-Type: text/html;charset=UTF-8
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>**NO_INTERACTION**
     * 
     * <p>When the value of `action` is `NO_INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request without displaying any user interface
     * pages for authentication or consent. This case happens when the authorization request contains
     * `prompt=none`.
     * 
     * <p>The service must follow the steps described below.
     * 
     * <p>[1] END-USER AUTHENTICATION
     * 
     * <p>Check whether an end-user has already logged in. If an end-user has logged in, go to the next step ([MAX_AGE]).
     * Otherwise, call Authlete's `/auth/authorization/fail` API with `reason=NOT_LOGGED_IN` and use the response from
     * the API to generate a response to the client application.
     * 
     * <p>[2] MAX AGE
     * 
     * <p>Get the value of `maxAge` parameter from the `/auth/authorization` API response. The value represents
     * the maximum authentication age which has come from `max_age` request parameter or `defaultMaxAge`
     * configuration parameter of the client application. If the value is `0`, go to the next step ([SUBJECT]).
     * Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Get the time at which the end-user was authenticated. that this value is not managed by Authlete,
     * meaning that it is expected that the service implementation manages the value. If the service implementation
     * does not manage authentication time of end-users, call Authlete's `/auth/authorization/fail` API
     * with `reason=MAX_AGE_NOT_SUPPORTED` and use the API response to generate a response to the client
     * application.
     * 
     * <p>(ii) Add the value of the maximum authentication age (which is represented in seconds) to the authentication
     * time. The calculated value is the expiration time.
     * 
     * <p>(iii) Check whether the calculated value is equal to or greater than the current time. If this condition
     * is satisfied, go to the next step ([SUBJECT]). Otherwise, call Authlete's `/auth/authorization/fail`
     * API with `reason=EXCEEDS_MAX_AGE` and use the API response to generate a response to the client
     * application.
     * 
     * <p>[3] SUBJECT
     * 
     * <p>Get the value of `subject` from the `/auth/authorization` API response. The value represents an
     * end-user who the client application expects to grant authorization. If the value is `null`, go to
     * the next step ([ACRs]). Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Compare the value of the requested subject to the current end-user.
     * 
     * <p>(ii) If they are equal, go to the next step ([ACRs]). If they are not equal, call Authlete's
     * `/auth/authorization/fail` API with `reason=DIFFERENT_SUBJECT` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>[4] ACRs
     * 
     * <p>Get the value of `acrs` from the `/auth/authorization` API response. The value represents a list
     * of ACRs (Authentication Context Class References) and comes from (1) acr claim in `claims` request
     * parameter, (2) `acr_values` request parameter, or (3) `default_acr_values` configuration parameter
     * of the client application.
     * 
     * <p>It is ensured that all the ACRs in acrs are supported by the authorization server implementation.
     * In other words, it is ensured that all the ACRs are listed in `acr_values_supported` configuration
     * parameter of the authorization server.
     * 
     * <p>If the value of ACRs is `null`, go to the next step ([ISSUE]). Otherwise, follow the sub steps
     * described below.
     * 
     * <p>(i) Get the ACR performed for the authentication of the current end-user. Note that this value is
     * managed not by Authlete but by the authorization server implementation. (If the authorization server
     * implementation cannot handle ACRs, it should not have listed ACRs as `acr_values_supported`.)
     * 
     * <p>(ii) Compare the ACR value obtained in the above step to each element in the ACR array (`acrs`)
     * in the listed order.
     * 
     * <p>(iii) If the ACR value was found in the array, (= the ACR performed for the authentication of the
     * current end-user did not match any one of the ACRs requested by the client application), check
     * whether one of the requested ACRs must be satisfied or not using `acrEssential` parameter in the
     * `/auth/authorization` API response. If the value of `acrEssential` parameter is `true`, call Authlete's
     * `/auth/authorization/fail` API with `reason=ACR_NOT_SATISFIED` and use the response from the API
     * to generate a response to the client application. Otherwise, go to the next step ([SCOPES]).
     * 
     * <p>[5] SCOPES
     * 
     * <p>Get the value of `scopes` from the `/auth/authorization` API response. If the array contains a
     * scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), which is only available in a dedicated/onpremise Authlete server (contact sales@authlete.com
     * for details).
     * 
     * <p>[6] DYNAMIC SCOPES
     * 
     * <p>Get the value of `dynamicScopes` from the `/auth/authorization` API response. If the array contains
     * a scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs) but dynamic scopes are not remembered as granted scopes.
     * 
     * <p>[7] RESOURCES
     * 
     * <p>Get the value of `resources` from the `/auth/authorization` API response. The array represents
     * the values of the `resource` request parameters. If you want to reject the request, call Authlete's
     * `/auth/authorization/fail` API with `reason=INVALID_TARGET` and use the response from the API to
     * generate a response to the client application. Otherwise, go to the next step ([ISSUE]).
     * 
     * <p>See "Resource Indicators for OAuth 2.0" for details.
     * 
     * <p>[8] ISSUE
     * 
     * <p>If all the above steps succeeded, the last step is to issue an authorization code, an ID token
     * and/or an access token. (There is a special case, though. In the case of `response_type=none`,
     * nothing is issued.) It can be performed by calling Authlete's `/auth/authorization/issue` API.
     * The API requires the following parameters. Prepare these parameters and call `/auth/authorization/issue`
     * API and use the response to generate a response to the client application.
     * 
     * <p>- &lt;u&gt;`ticket` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents a ticket which is exchanged with tokens at `/auth/authorization/issue`.
     *   Use the value of `ticket` contained in the `/auth/authorization` API response.
     * 
     * <p>- &lt;u&gt;`subject` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the unique identifier of the current end-user. It is often called "user ID"
     *   and it may or may not be visible to the user. In any case, it is a number or a string assigned
     *   to an end-user by the authorization server implementation. Authlete does not care about the format
     *   of the value of subject, but it must consist of only ASCII letters and its length must not exceed 100.
     * 
     * <p>  When the value of `subject` parameter in the /auth/authorization API response is not `null`,
     *   it is necessarily identical to the value of `subject` parameter in the `/auth/authorization/issue`
     *   API request.
     * 
     * <p>  The value of this parameter will be embedded in an ID token as the value of `sub` claim. When
     *   the value of `subject_type` configuration parameter of the client application is `PAIRWISE`,
     *   the value of sub claim is different from the value specified by this parameter, See [8. Subject
     *   Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes) of OpenID
     *   Connect Core 1.0 for details about subject types.
     * 
     * <p>  You can use the `sub` request parameter to adjust the value of the `sub` claim in an ID token.
     *   See the description of the `sub` request parameter for details.
     * 
     * <p>- &lt;u&gt;`authTime` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the time when the end-user authentication occurred. Its value is the
     *   number of seconds from `1970-01-01`. The value of this parameter will be embedded in an ID token
     *   as the value of `auth_time` claim.
     * 
     * <p>- &lt;u&gt;`acr` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the ACR (Authentication Context Class Reference) which the authentication
     *   of the end-user satisfies. When `acrs` in the `/auth/authorization` API response is a non-empty
     *   array and the value of `acrEssential` is `true`, the value of this parameter must be one of the
     *   array elements. Otherwise, even `null` is allowed. The value of this parameter will be embedded
     *   in an ID token as the value of `acr` claim.
     * 
     * <p>- &lt;u&gt;`claims` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents claims of the end-user. "Claims" here are pieces of information about
     *   the end-user such as `"name"`, `"email"` and `"birthdate"`. The authorization server implementation
     *   is required to gather claims of the end-user, format the claim values into JSON and set the JSON
     *   string as the value of this parameter.
     * 
     * <p>  The claims which the authorization server implementation is required to gather are listed in
     *   `claims` parameter in the `/auth/authorization` API response.
     * 
     * <p>  For example, if claims parameter lists `"name"`, `"email"` and `"birthdate"`, the value of this
     *   parameter should look like the following.
     * 
     * <p>  ```json
     *   {
     *     "name": "John Smith",
     *     "email": "john@example.com",
     *     "birthdate": "1974-05-06"
     *   }
     *   ```
     * 
     * <p>  `claimsLocales` parameter in the `/auth/authorization` API response lists the end-user's preferred
     *   languages and scripts, ordered by preference. When `claimsLocales` parameter is a non-empty array,
     *   its elements should be taken into account when the authorization server implementation gathers
     *   claim values. Especially, note the excerpt below from [5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
     *   of OpenID Connect Core 1.0.
     * 
     * <p>  &gt; When the OP determines, either through the `claims_locales` parameter, or by other means, that
     *   the End-User and Client are requesting Claims in only one set of languages and scripts, it is
     *   RECOMMENDED that OPs return Claims without language tags when they employ this language and script.
     *   It is also RECOMMENDED that Clients be written in a manner that they can handle and utilize Claims
     *   using language tags.
     * 
     * <p>  If `claims` parameter in the `/auth/authorization` API response is `null` or an empty array,
     *   the value of this parameter should be `null`.
     * 
     * <p>  See [5.1. Standard Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)
     *   of OpenID Connect core 1.0 for claim names and their value formats. Note (1) that the authorization
     *   server implementation support its special claims ([5.1.2. Additional Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims))
     *   and (2) that claim names may be followed by a language tag ([5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)).
     *   Read the specification of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
     *   for details.
     * 
     * <p>  The claim values in this parameter will be embedded in an ID token.
     * 
     * <p>  Note that `idTokenClaims` parameter is available in the `/auth/authorization` API response.
     *   The parameter has the value of the `"id_token"` property in the `claims` request parameter or
     *   in the `"claims"` property in a request object. The value of this parameter should be considered
     *   when you prepare claim values.
     * 
     * <p>- &lt;u&gt;`properties` (optional)&lt;/u&gt;&lt;br&gt;
     *   Extra properties to associate with an access token and/or an authorization code that may be issued
     *   by this request. Note that `properties` parameter is accepted only when `Content-Type` of the
     *   request is `application/json`, so don't use `application/x-www-form-urlencoded` for details.
     * 
     * <p>- &lt;u&gt;`scopes` (optional)&lt;/u&gt;&lt;br&gt;
     *   Scopes to associate with an access token and/or an authorization code. If this parameter is `null`,
     *   the scopes specified in the original authorization request from the client application are used.
     *   In other cases, including the case of an empty array, the specified scopes will replace the original
     *   scopes contained in the original authorization request.
     * 
     * <p>  Even scopes that are not included in the original authorization request can be specified. However,
     *   as an exception, `openid` scope is ignored on the server side if it is not included in the original
     *   request. It is because the existence of `openid` scope considerably changes the validation steps
     *   and because adding `openid` triggers generation of an ID token (although the client application
     *   has not requested it) and the behavior is a major violation against the specification.
     * 
     * <p>  If you add `offline_access` scope although it is not included in the original request, keep in
     *   mind that the specification requires explicit consent from the user for the scope ([OpenID Connect
     *   Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess)).
     *   When `offline_access` is included in the original request, the current implementation of Authlete's
     *   `/auth/authorization` API checks whether the request has come along with `prompt` request parameter
     *   and the value includes consent. However, note that the implementation of Authlete's `/auth/authorization/issue`
     *   API does not perform such checking if `offline_access` scope is added via this `scopes` parameter.
     * 
     * <p>- &lt;u&gt;`sub` (optional)&lt;/u&gt;&lt;br&gt;
     *   The value of the `sub` claim in an ID token. If the value of this request parameter is not empty,
     *   it is used as the value of the `sub` claim. Otherwise, the value of the `subject` request parameter
     *   is used as the value of the `sub` claim. The main purpose of this parameter is to hide the actual
     *   value of the subject from client applications.
     * 
     * <p>  Note that even if this `sub` parameter is not empty, the value of the subject request parameter
     *   is used as the value of the subject which is associated with the access token.
     * 
     * <p>**INTERACTION**
     * 
     * <p>When the value of `action` is `INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request with user interaction by an HTML form.
     * The purpose of the UI displayed to the end-user is to ask the end-user to grant authorization to
     * the client application. The items described below are some points which the service implementation
     * should take into account when it builds the UI.
     * 
     * <p>[1] DISPLAY MODE
     * 
     * <p>The response from `/auth/authorization` API has `display` parameter. It is one of `PAGE` (default),
     * `POPUP`, `TOUCH` and `WAP` The meanings of the values are described in [3.1.2.1. Authentication
     * Request of OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * Basically, the authorization server implementation should display the UI which is suitable for the
     * display mode, but it is okay for the authorization server implementation to "attempt to detect the
     * capabilities of the User Agent and present an appropriate display".
     * 
     * <p>It is ensured that the value of `display` is one of the supported display modes which are specified
     * by `supportedDisplays` configuration parameter of the service.
     * 
     * <p>[2] UI LOCALE
     * 
     * <p>The response from `/auth/authorization` API has `uiLocales` parameter. It it is not `null`, it lists
     * language tag values (such as `fr-CA`, `ja-JP` and `en`) ordered by preference. The service implementation
     * should display the UI in one of the language listed in the parameter when possible. It is ensured
     * that language tags listed in `uiLocales` are contained in the list of supported UI locales which
     * are specified by `supportedUiLocales` configuration parameter of the service.
     * 
     * <p>[3] CLIENT INFORMATION
     * 
     * <p>The authorization server implementation should show information about the client application to
     * the end-user. The information is embedded in `client` parameter in the response from `/auth/authorization`
     * API.
     * 
     * <p>[4] SCOPES
     * 
     * <p>A client application requires authorization for specific permissions. In OAuth 2.0 specification,
     * "scope" is a technical term which represents a permission. `scopes` parameter in the response
     * from `/auth/authorization` API is a list of scopes requested by the client application. The service
     * implementation should show the end-user the scopes.
     * 
     * <p>The authorization server implementation may choose not to show scopes to which the end-user has
     * given consent in the past. To put it the other way around, the authorization server implementation
     * may show only the scopes to which the end-user has not given consent yet. However, if the value
     * of `prompts` response parameter contains `CONSENT`, the authorization server implementation has
     * to obtain explicit consent from the end-user even if the end-user has given consent to all the
     * requested scopes in the past.
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), but the APIs work only in the case the Authlete server you use is a dedicated Authlete server
     * (contact sales@authlete.com for details). In other words, the APIs of the shared Authlete server
     * are disabled intentionally (in order to prevent garbage data from being accumulated) and they
     * return 403 Forbidden.
     * 
     * <p>It is ensured that the values in `scopes` parameter are contained in the list of supported scopes
     * which are specified by `supportedScopes` configuration parameter of the service.
     * 
     * <p>[5] DYNAMIC SCOPES
     * 
     * <p>The authorization request may include dynamic scopes. The list of recognized dynamic scopes are
     * accessible by getDynamicScopes() method. See the description of the [DynamicScope](https://authlete.github.io/authlete-java-common/com/authlete/common/dto/DynamicScope.html)
     * class for details about dynamic scopes.
     * 
     * <p>[6] AUTHORIZATION DETAILS
     * 
     * <p>The authorization server implementation should show the end-user "authorization details" if the
     * request includes it. The value of `authorization_details` parameter in the response is the content
     * of the `authorization_details` request parameter.
     * 
     * <p>See "OAuth 2.0 Rich Authorization Requests" for details.
     * 
     * <p>[7] PURPOSE
     * 
     * <p>The authorization server implementation must show the value of the `purpose` request parameter if
     * it supports [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html).
     * See [8. Transaction-specific Purpose](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.8)
     * in the specification for details.
     * 
     * <p>Note that the value of `purpose` response parameter is the value of the purpose request parameter.
     * 
     * <p>[7] END-USER AUTHENTICATION
     * 
     * <p>Necessarily, the end-user must be authenticated (= must login the service) before granting authorization
     * to the client application. Simply put, a login form is expected to be displayed for end-user authentication.
     * The service implementation must follow the steps described below to comply with OpenID Connect.
     * (Or just always show a login form if it's too much of a bother.)
     * 
     * <p>(i) Get the value of `prompts` response parameter. It corresponds to the value of the `prompt`
     * request parameter. Details of the request parameter are described in [3.1.2.1. Authentication
     * Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) of OpenID Connect Core 1.0.
     * 
     * <p>(ii) If the value of `prompts` parameter is `SELECT_ACCOUNT` display a form to let the end-user
     * select on of his/her accounts for login. If `subject` response parameter is not `null`, it is the
     * end-user ID that the client application expects, so the value should be used to determine the value
     * of the login ID. Note that a subject and a login ID are not necessarily equal. If the value of
     * `subject` response parameter is `null`, the value of `loginHint` response parameter should be referred
     * to as a hint to determine the value of the login ID. The value of `loginHint` response parameter
     * is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iii) If the value of `prompts` response parameter contains `LOGIN`, display a form to urge the
     * end-user to login even if the end-user has already logged in. If the value of `subject` response
     * parameter is not `null`, it is the end-user ID that the client application expects, so the value
     * should be used to determine the value of the login ID. Note that a subject and a login ID are not
     * necessarily equal. If the value of `subject` response parameter is `null`, the value of `loginHint`
     * response parameter should be referred to as a hint to determine the value of the login ID. The value
     * of `loginHint` response parameter is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iv) If the value of `prompts` response parameter does not contain `LOGIN`, the authorization server
     * implementation does not have to authenticate the end-user if all the conditions described below
     * are satisfied. If any one of the conditions is not satisfied, show a login form to authenticate
     * the end-user.
     * 
     * <p>- An end-user has already logged in the service.
     * 
     * <p>- The login ID of the current end-user matches the value of `subject` response parameter.
     * This check is required only when the value of `subject` response parameter is a non-null value.
     * 
     * <p>- The max age, which is the number of seconds contained in `maxAge` response parameter,
     * has not passed since the current end-user logged in your service. This check is required only when
     * the value of `maxAge` response parameter is a non-zero value.
     * 
     * <p>- If the authorization server implementation does not manage authentication time of end-users
     * (= if the authorization server implementation cannot know when end-users logged in) and if the
     * value of `maxAge` response parameter is a non-zero value, a login form should be displayed.
     * 
     * <p>- The ACR (Authentication Context Class Reference) of the authentication performed for
     * the current end-user satisfies one of the ACRs listed in `acrs` response parameter. This check is
     * required only when the value of `acrs` response parameter is a non-empty array.
     * 
     * <p>In every case, the end-user authentication must satisfy one of the ACRs listed in `acrs` response
     * parameter when the value of `acrs` response parameter is a non-empty array and `acrEssential`
     * response parameter is `true`.
     * 
     * <p>[9] GRANT/DENY BUTTONS
     * 
     * <p>The end-user is supposed to choose either (1) to grant authorization to the client application or
     * (2) to deny the authorization request. The UI must have UI components to accept the judgment by
     * the user. Usually, a button to grant authorization and a button to deny the request are provided.
     * 
     * <p>When the value of `subject` response parameter is not `null`, the end-user authentication must be
     * performed for the subject, meaning that the authorization server implementation should repeatedly
     * show a login form until the subject is successfully authenticated.
     * 
     * <p>The end-user will choose either (1) to grant authorization to the client application or (2) to
     * deny the authorization request. When the end-user chose to deny the authorization request, call
     * Authlete's `/auth/authorization/fail` API with `reason=DENIED` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>When the end-user chose to grant authorization to the client application, the authorization server
     * implementation has to issue an authorization code, an ID token, and/or an access token to the client
     * application. (There is a special case. When `response_type=none`, nothing is issued.) Issuing the
     * tokens can be performed by calling Authlete's `/auth/authorization/issue` API. Read [ISSUE] written
     * above in the description for the case of `action=NO_INTERACTION`.
     * &lt;/details&gt;
     * 
     * @param serviceId A service ID.
     * @param requestBody 
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public AuthAuthorizationApiResponse process(@Nonnull String serviceId, @Nonnull AuthAuthorizationApiRequestBody requestBody) throws Exception {
        return process(serviceId, requestBody, null);
    }

    /**
     * Process Authorization Request
     * 
     * <p>This API parses request parameters of an authorization request and returns necessary data for the authorization server
     * implementation to process the authorization request further.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the authorization endpoint of
     * the service. The endpoint implementation must extract the request parameters from the authorization
     * request from the client application and pass them as the value of parameters request parameter for
     * Authlete's `/auth/authorization` API.
     * 
     * <p>The value of `parameters` is either (1) the entire query string when the HTTP method of the request
     * from the client application is `GET` or (2) the entire entity body (which is formatted in
     * `application/x-www-form-urlencoded`) when the HTTP method of the request from the client application
     * is `POST`.
     * 
     * <p>The following code snippet is an example in JAX-RS showing how to extract request parameters from
     * the authorization request.
     * 
     * <p>```java
     * @GET
     * public Response get(@Context UriInfo uriInfo)
     * {
     *     // The query parameters of the authorization request.
     *     String parameters = uriInfo.getRequestUri().getQuery();
     *     ......
     * }
     * 
     * <p>@POST
     * @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
     * public Response post(String parameters)
     * {
     *     // 'parameters' is the entity body of the authorization request.
     *     ......
     * }
     * ```
     * 
     * <p>The endpoint implementation does not have to parse the request parameters from the client application
     * because Authlete's `/auth/authorization` API does it.
     * 
     * <p>The response from `/auth/authorization` API has various parameters. Among them, it is `action`
     * parameter that the authorization server implementation should check first because it denotes the
     * next action that the authorization server implementation should take. According to the value of
     * `action`, the service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete.
     * In either case, from the viewpoint of the client application, it is an error on the server side.
     * Therefore, the service implementation should generate a response to the client application with
     * HTTP status of "500 Internal Server Error". Authlete recommends `application/json` as the content
     * type although OAuth 2.0 specification does not mention the format of the error response when the
     * redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application
     * since "500 Internal Server Error" is not required by OAuth 2.0.
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * is invalid.
     * 
     * <p>A response with HTTP status of "400 Bad Request" should be returned to the client application and
     * Authlete recommends `application/json` as the content type although OAuth 2.0 specification does
     * not mention the format of the error response when the redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application since
     * "400 Bad Request" is not required by OAuth 2.0.
     * 
     * <p>**LOCATION**
     * 
     * <p>When the value of `action` is `LOCATION`, it means that the request from the client application
     * is invalid but the redirect URI
     * to which the error should be reported has been determined.
     * 
     * <p>A response with HTTP status of "302 Found" must be returned to the client application with `Location`
     * header which has a redirect URI with error parameter.
     * 
     * <p>The value of `responseContent` is a redirect URI with `error` parameter, so it can be used as the
     * value of `Location` header.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 302 Found
     * Location: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORM**
     * 
     * <p>When the value of `action` is `FORM`, it means that the request from the client application is
     * invalid but the redirect URI to which the error should be reported has been determined, and that
     * the authorization request contains `response_mode=form_post` as is defined in [OAuth 2.0 Form Post
     * Response Mode](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html).
     * 
     * <p>The HTTP status of the response returned to the client application should be "200 OK" and the
     * content type should be `text/html;charset=UTF-8`.
     * 
     * <p>The value of `responseContent` is an HTML which can be used as the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Content-Type: text/html;charset=UTF-8
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>**NO_INTERACTION**
     * 
     * <p>When the value of `action` is `NO_INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request without displaying any user interface
     * pages for authentication or consent. This case happens when the authorization request contains
     * `prompt=none`.
     * 
     * <p>The service must follow the steps described below.
     * 
     * <p>[1] END-USER AUTHENTICATION
     * 
     * <p>Check whether an end-user has already logged in. If an end-user has logged in, go to the next step ([MAX_AGE]).
     * Otherwise, call Authlete's `/auth/authorization/fail` API with `reason=NOT_LOGGED_IN` and use the response from
     * the API to generate a response to the client application.
     * 
     * <p>[2] MAX AGE
     * 
     * <p>Get the value of `maxAge` parameter from the `/auth/authorization` API response. The value represents
     * the maximum authentication age which has come from `max_age` request parameter or `defaultMaxAge`
     * configuration parameter of the client application. If the value is `0`, go to the next step ([SUBJECT]).
     * Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Get the time at which the end-user was authenticated. that this value is not managed by Authlete,
     * meaning that it is expected that the service implementation manages the value. If the service implementation
     * does not manage authentication time of end-users, call Authlete's `/auth/authorization/fail` API
     * with `reason=MAX_AGE_NOT_SUPPORTED` and use the API response to generate a response to the client
     * application.
     * 
     * <p>(ii) Add the value of the maximum authentication age (which is represented in seconds) to the authentication
     * time. The calculated value is the expiration time.
     * 
     * <p>(iii) Check whether the calculated value is equal to or greater than the current time. If this condition
     * is satisfied, go to the next step ([SUBJECT]). Otherwise, call Authlete's `/auth/authorization/fail`
     * API with `reason=EXCEEDS_MAX_AGE` and use the API response to generate a response to the client
     * application.
     * 
     * <p>[3] SUBJECT
     * 
     * <p>Get the value of `subject` from the `/auth/authorization` API response. The value represents an
     * end-user who the client application expects to grant authorization. If the value is `null`, go to
     * the next step ([ACRs]). Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Compare the value of the requested subject to the current end-user.
     * 
     * <p>(ii) If they are equal, go to the next step ([ACRs]). If they are not equal, call Authlete's
     * `/auth/authorization/fail` API with `reason=DIFFERENT_SUBJECT` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>[4] ACRs
     * 
     * <p>Get the value of `acrs` from the `/auth/authorization` API response. The value represents a list
     * of ACRs (Authentication Context Class References) and comes from (1) acr claim in `claims` request
     * parameter, (2) `acr_values` request parameter, or (3) `default_acr_values` configuration parameter
     * of the client application.
     * 
     * <p>It is ensured that all the ACRs in acrs are supported by the authorization server implementation.
     * In other words, it is ensured that all the ACRs are listed in `acr_values_supported` configuration
     * parameter of the authorization server.
     * 
     * <p>If the value of ACRs is `null`, go to the next step ([ISSUE]). Otherwise, follow the sub steps
     * described below.
     * 
     * <p>(i) Get the ACR performed for the authentication of the current end-user. Note that this value is
     * managed not by Authlete but by the authorization server implementation. (If the authorization server
     * implementation cannot handle ACRs, it should not have listed ACRs as `acr_values_supported`.)
     * 
     * <p>(ii) Compare the ACR value obtained in the above step to each element in the ACR array (`acrs`)
     * in the listed order.
     * 
     * <p>(iii) If the ACR value was found in the array, (= the ACR performed for the authentication of the
     * current end-user did not match any one of the ACRs requested by the client application), check
     * whether one of the requested ACRs must be satisfied or not using `acrEssential` parameter in the
     * `/auth/authorization` API response. If the value of `acrEssential` parameter is `true`, call Authlete's
     * `/auth/authorization/fail` API with `reason=ACR_NOT_SATISFIED` and use the response from the API
     * to generate a response to the client application. Otherwise, go to the next step ([SCOPES]).
     * 
     * <p>[5] SCOPES
     * 
     * <p>Get the value of `scopes` from the `/auth/authorization` API response. If the array contains a
     * scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), which is only available in a dedicated/onpremise Authlete server (contact sales@authlete.com
     * for details).
     * 
     * <p>[6] DYNAMIC SCOPES
     * 
     * <p>Get the value of `dynamicScopes` from the `/auth/authorization` API response. If the array contains
     * a scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs) but dynamic scopes are not remembered as granted scopes.
     * 
     * <p>[7] RESOURCES
     * 
     * <p>Get the value of `resources` from the `/auth/authorization` API response. The array represents
     * the values of the `resource` request parameters. If you want to reject the request, call Authlete's
     * `/auth/authorization/fail` API with `reason=INVALID_TARGET` and use the response from the API to
     * generate a response to the client application. Otherwise, go to the next step ([ISSUE]).
     * 
     * <p>See "Resource Indicators for OAuth 2.0" for details.
     * 
     * <p>[8] ISSUE
     * 
     * <p>If all the above steps succeeded, the last step is to issue an authorization code, an ID token
     * and/or an access token. (There is a special case, though. In the case of `response_type=none`,
     * nothing is issued.) It can be performed by calling Authlete's `/auth/authorization/issue` API.
     * The API requires the following parameters. Prepare these parameters and call `/auth/authorization/issue`
     * API and use the response to generate a response to the client application.
     * 
     * <p>- &lt;u&gt;`ticket` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents a ticket which is exchanged with tokens at `/auth/authorization/issue`.
     *   Use the value of `ticket` contained in the `/auth/authorization` API response.
     * 
     * <p>- &lt;u&gt;`subject` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the unique identifier of the current end-user. It is often called "user ID"
     *   and it may or may not be visible to the user. In any case, it is a number or a string assigned
     *   to an end-user by the authorization server implementation. Authlete does not care about the format
     *   of the value of subject, but it must consist of only ASCII letters and its length must not exceed 100.
     * 
     * <p>  When the value of `subject` parameter in the /auth/authorization API response is not `null`,
     *   it is necessarily identical to the value of `subject` parameter in the `/auth/authorization/issue`
     *   API request.
     * 
     * <p>  The value of this parameter will be embedded in an ID token as the value of `sub` claim. When
     *   the value of `subject_type` configuration parameter of the client application is `PAIRWISE`,
     *   the value of sub claim is different from the value specified by this parameter, See [8. Subject
     *   Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes) of OpenID
     *   Connect Core 1.0 for details about subject types.
     * 
     * <p>  You can use the `sub` request parameter to adjust the value of the `sub` claim in an ID token.
     *   See the description of the `sub` request parameter for details.
     * 
     * <p>- &lt;u&gt;`authTime` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the time when the end-user authentication occurred. Its value is the
     *   number of seconds from `1970-01-01`. The value of this parameter will be embedded in an ID token
     *   as the value of `auth_time` claim.
     * 
     * <p>- &lt;u&gt;`acr` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the ACR (Authentication Context Class Reference) which the authentication
     *   of the end-user satisfies. When `acrs` in the `/auth/authorization` API response is a non-empty
     *   array and the value of `acrEssential` is `true`, the value of this parameter must be one of the
     *   array elements. Otherwise, even `null` is allowed. The value of this parameter will be embedded
     *   in an ID token as the value of `acr` claim.
     * 
     * <p>- &lt;u&gt;`claims` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents claims of the end-user. "Claims" here are pieces of information about
     *   the end-user such as `"name"`, `"email"` and `"birthdate"`. The authorization server implementation
     *   is required to gather claims of the end-user, format the claim values into JSON and set the JSON
     *   string as the value of this parameter.
     * 
     * <p>  The claims which the authorization server implementation is required to gather are listed in
     *   `claims` parameter in the `/auth/authorization` API response.
     * 
     * <p>  For example, if claims parameter lists `"name"`, `"email"` and `"birthdate"`, the value of this
     *   parameter should look like the following.
     * 
     * <p>  ```json
     *   {
     *     "name": "John Smith",
     *     "email": "john@example.com",
     *     "birthdate": "1974-05-06"
     *   }
     *   ```
     * 
     * <p>  `claimsLocales` parameter in the `/auth/authorization` API response lists the end-user's preferred
     *   languages and scripts, ordered by preference. When `claimsLocales` parameter is a non-empty array,
     *   its elements should be taken into account when the authorization server implementation gathers
     *   claim values. Especially, note the excerpt below from [5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
     *   of OpenID Connect Core 1.0.
     * 
     * <p>  &gt; When the OP determines, either through the `claims_locales` parameter, or by other means, that
     *   the End-User and Client are requesting Claims in only one set of languages and scripts, it is
     *   RECOMMENDED that OPs return Claims without language tags when they employ this language and script.
     *   It is also RECOMMENDED that Clients be written in a manner that they can handle and utilize Claims
     *   using language tags.
     * 
     * <p>  If `claims` parameter in the `/auth/authorization` API response is `null` or an empty array,
     *   the value of this parameter should be `null`.
     * 
     * <p>  See [5.1. Standard Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)
     *   of OpenID Connect core 1.0 for claim names and their value formats. Note (1) that the authorization
     *   server implementation support its special claims ([5.1.2. Additional Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims))
     *   and (2) that claim names may be followed by a language tag ([5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)).
     *   Read the specification of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
     *   for details.
     * 
     * <p>  The claim values in this parameter will be embedded in an ID token.
     * 
     * <p>  Note that `idTokenClaims` parameter is available in the `/auth/authorization` API response.
     *   The parameter has the value of the `"id_token"` property in the `claims` request parameter or
     *   in the `"claims"` property in a request object. The value of this parameter should be considered
     *   when you prepare claim values.
     * 
     * <p>- &lt;u&gt;`properties` (optional)&lt;/u&gt;&lt;br&gt;
     *   Extra properties to associate with an access token and/or an authorization code that may be issued
     *   by this request. Note that `properties` parameter is accepted only when `Content-Type` of the
     *   request is `application/json`, so don't use `application/x-www-form-urlencoded` for details.
     * 
     * <p>- &lt;u&gt;`scopes` (optional)&lt;/u&gt;&lt;br&gt;
     *   Scopes to associate with an access token and/or an authorization code. If this parameter is `null`,
     *   the scopes specified in the original authorization request from the client application are used.
     *   In other cases, including the case of an empty array, the specified scopes will replace the original
     *   scopes contained in the original authorization request.
     * 
     * <p>  Even scopes that are not included in the original authorization request can be specified. However,
     *   as an exception, `openid` scope is ignored on the server side if it is not included in the original
     *   request. It is because the existence of `openid` scope considerably changes the validation steps
     *   and because adding `openid` triggers generation of an ID token (although the client application
     *   has not requested it) and the behavior is a major violation against the specification.
     * 
     * <p>  If you add `offline_access` scope although it is not included in the original request, keep in
     *   mind that the specification requires explicit consent from the user for the scope ([OpenID Connect
     *   Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess)).
     *   When `offline_access` is included in the original request, the current implementation of Authlete's
     *   `/auth/authorization` API checks whether the request has come along with `prompt` request parameter
     *   and the value includes consent. However, note that the implementation of Authlete's `/auth/authorization/issue`
     *   API does not perform such checking if `offline_access` scope is added via this `scopes` parameter.
     * 
     * <p>- &lt;u&gt;`sub` (optional)&lt;/u&gt;&lt;br&gt;
     *   The value of the `sub` claim in an ID token. If the value of this request parameter is not empty,
     *   it is used as the value of the `sub` claim. Otherwise, the value of the `subject` request parameter
     *   is used as the value of the `sub` claim. The main purpose of this parameter is to hide the actual
     *   value of the subject from client applications.
     * 
     * <p>  Note that even if this `sub` parameter is not empty, the value of the subject request parameter
     *   is used as the value of the subject which is associated with the access token.
     * 
     * <p>**INTERACTION**
     * 
     * <p>When the value of `action` is `INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request with user interaction by an HTML form.
     * The purpose of the UI displayed to the end-user is to ask the end-user to grant authorization to
     * the client application. The items described below are some points which the service implementation
     * should take into account when it builds the UI.
     * 
     * <p>[1] DISPLAY MODE
     * 
     * <p>The response from `/auth/authorization` API has `display` parameter. It is one of `PAGE` (default),
     * `POPUP`, `TOUCH` and `WAP` The meanings of the values are described in [3.1.2.1. Authentication
     * Request of OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * Basically, the authorization server implementation should display the UI which is suitable for the
     * display mode, but it is okay for the authorization server implementation to "attempt to detect the
     * capabilities of the User Agent and present an appropriate display".
     * 
     * <p>It is ensured that the value of `display` is one of the supported display modes which are specified
     * by `supportedDisplays` configuration parameter of the service.
     * 
     * <p>[2] UI LOCALE
     * 
     * <p>The response from `/auth/authorization` API has `uiLocales` parameter. It it is not `null`, it lists
     * language tag values (such as `fr-CA`, `ja-JP` and `en`) ordered by preference. The service implementation
     * should display the UI in one of the language listed in the parameter when possible. It is ensured
     * that language tags listed in `uiLocales` are contained in the list of supported UI locales which
     * are specified by `supportedUiLocales` configuration parameter of the service.
     * 
     * <p>[3] CLIENT INFORMATION
     * 
     * <p>The authorization server implementation should show information about the client application to
     * the end-user. The information is embedded in `client` parameter in the response from `/auth/authorization`
     * API.
     * 
     * <p>[4] SCOPES
     * 
     * <p>A client application requires authorization for specific permissions. In OAuth 2.0 specification,
     * "scope" is a technical term which represents a permission. `scopes` parameter in the response
     * from `/auth/authorization` API is a list of scopes requested by the client application. The service
     * implementation should show the end-user the scopes.
     * 
     * <p>The authorization server implementation may choose not to show scopes to which the end-user has
     * given consent in the past. To put it the other way around, the authorization server implementation
     * may show only the scopes to which the end-user has not given consent yet. However, if the value
     * of `prompts` response parameter contains `CONSENT`, the authorization server implementation has
     * to obtain explicit consent from the end-user even if the end-user has given consent to all the
     * requested scopes in the past.
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), but the APIs work only in the case the Authlete server you use is a dedicated Authlete server
     * (contact sales@authlete.com for details). In other words, the APIs of the shared Authlete server
     * are disabled intentionally (in order to prevent garbage data from being accumulated) and they
     * return 403 Forbidden.
     * 
     * <p>It is ensured that the values in `scopes` parameter are contained in the list of supported scopes
     * which are specified by `supportedScopes` configuration parameter of the service.
     * 
     * <p>[5] DYNAMIC SCOPES
     * 
     * <p>The authorization request may include dynamic scopes. The list of recognized dynamic scopes are
     * accessible by getDynamicScopes() method. See the description of the [DynamicScope](https://authlete.github.io/authlete-java-common/com/authlete/common/dto/DynamicScope.html)
     * class for details about dynamic scopes.
     * 
     * <p>[6] AUTHORIZATION DETAILS
     * 
     * <p>The authorization server implementation should show the end-user "authorization details" if the
     * request includes it. The value of `authorization_details` parameter in the response is the content
     * of the `authorization_details` request parameter.
     * 
     * <p>See "OAuth 2.0 Rich Authorization Requests" for details.
     * 
     * <p>[7] PURPOSE
     * 
     * <p>The authorization server implementation must show the value of the `purpose` request parameter if
     * it supports [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html).
     * See [8. Transaction-specific Purpose](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.8)
     * in the specification for details.
     * 
     * <p>Note that the value of `purpose` response parameter is the value of the purpose request parameter.
     * 
     * <p>[7] END-USER AUTHENTICATION
     * 
     * <p>Necessarily, the end-user must be authenticated (= must login the service) before granting authorization
     * to the client application. Simply put, a login form is expected to be displayed for end-user authentication.
     * The service implementation must follow the steps described below to comply with OpenID Connect.
     * (Or just always show a login form if it's too much of a bother.)
     * 
     * <p>(i) Get the value of `prompts` response parameter. It corresponds to the value of the `prompt`
     * request parameter. Details of the request parameter are described in [3.1.2.1. Authentication
     * Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) of OpenID Connect Core 1.0.
     * 
     * <p>(ii) If the value of `prompts` parameter is `SELECT_ACCOUNT` display a form to let the end-user
     * select on of his/her accounts for login. If `subject` response parameter is not `null`, it is the
     * end-user ID that the client application expects, so the value should be used to determine the value
     * of the login ID. Note that a subject and a login ID are not necessarily equal. If the value of
     * `subject` response parameter is `null`, the value of `loginHint` response parameter should be referred
     * to as a hint to determine the value of the login ID. The value of `loginHint` response parameter
     * is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iii) If the value of `prompts` response parameter contains `LOGIN`, display a form to urge the
     * end-user to login even if the end-user has already logged in. If the value of `subject` response
     * parameter is not `null`, it is the end-user ID that the client application expects, so the value
     * should be used to determine the value of the login ID. Note that a subject and a login ID are not
     * necessarily equal. If the value of `subject` response parameter is `null`, the value of `loginHint`
     * response parameter should be referred to as a hint to determine the value of the login ID. The value
     * of `loginHint` response parameter is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iv) If the value of `prompts` response parameter does not contain `LOGIN`, the authorization server
     * implementation does not have to authenticate the end-user if all the conditions described below
     * are satisfied. If any one of the conditions is not satisfied, show a login form to authenticate
     * the end-user.
     * 
     * <p>- An end-user has already logged in the service.
     * 
     * <p>- The login ID of the current end-user matches the value of `subject` response parameter.
     * This check is required only when the value of `subject` response parameter is a non-null value.
     * 
     * <p>- The max age, which is the number of seconds contained in `maxAge` response parameter,
     * has not passed since the current end-user logged in your service. This check is required only when
     * the value of `maxAge` response parameter is a non-zero value.
     * 
     * <p>- If the authorization server implementation does not manage authentication time of end-users
     * (= if the authorization server implementation cannot know when end-users logged in) and if the
     * value of `maxAge` response parameter is a non-zero value, a login form should be displayed.
     * 
     * <p>- The ACR (Authentication Context Class Reference) of the authentication performed for
     * the current end-user satisfies one of the ACRs listed in `acrs` response parameter. This check is
     * required only when the value of `acrs` response parameter is a non-empty array.
     * 
     * <p>In every case, the end-user authentication must satisfy one of the ACRs listed in `acrs` response
     * parameter when the value of `acrs` response parameter is a non-empty array and `acrEssential`
     * response parameter is `true`.
     * 
     * <p>[9] GRANT/DENY BUTTONS
     * 
     * <p>The end-user is supposed to choose either (1) to grant authorization to the client application or
     * (2) to deny the authorization request. The UI must have UI components to accept the judgment by
     * the user. Usually, a button to grant authorization and a button to deny the request are provided.
     * 
     * <p>When the value of `subject` response parameter is not `null`, the end-user authentication must be
     * performed for the subject, meaning that the authorization server implementation should repeatedly
     * show a login form until the subject is successfully authenticated.
     * 
     * <p>The end-user will choose either (1) to grant authorization to the client application or (2) to
     * deny the authorization request. When the end-user chose to deny the authorization request, call
     * Authlete's `/auth/authorization/fail` API with `reason=DENIED` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>When the end-user chose to grant authorization to the client application, the authorization server
     * implementation has to issue an authorization code, an ID token, and/or an access token to the client
     * application. (There is a special case. When `response_type=none`, nothing is issued.) Issuing the
     * tokens can be performed by calling Authlete's `/auth/authorization/issue` API. Read [ISSUE] written
     * above in the description for the case of `action=NO_INTERACTION`.
     * &lt;/details&gt;
     * 
     * @param serviceId A service ID.
     * @param requestBody 
     * @param serverURL Overrides the server URL.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public AuthAuthorizationApiResponse process(
            @Nonnull String serviceId, @Nonnull AuthAuthorizationApiRequestBody requestBody,
            @Nullable String serverURL) throws Exception {
        AuthAuthorizationApiRequest request = new AuthAuthorizationApiRequest(serviceId, requestBody);
        RequestOperation<AuthAuthorizationApiRequest, AuthAuthorizationApiResponse> operation
              = new AuthAuthorizationApi.Sync(sdkConfiguration, serverURL);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Process Authorization Request
     * 
     * <p>This API parses request parameters of an authorization request and returns necessary data for the authorization server
     * implementation to process the authorization request further.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the authorization endpoint of
     * the service. The endpoint implementation must extract the request parameters from the authorization
     * request from the client application and pass them as the value of parameters request parameter for
     * Authlete's `/auth/authorization` API.
     * 
     * <p>The value of `parameters` is either (1) the entire query string when the HTTP method of the request
     * from the client application is `GET` or (2) the entire entity body (which is formatted in
     * `application/x-www-form-urlencoded`) when the HTTP method of the request from the client application
     * is `POST`.
     * 
     * <p>The following code snippet is an example in JAX-RS showing how to extract request parameters from
     * the authorization request.
     * 
     * <p>```java
     * @GET
     * public Response get(@Context UriInfo uriInfo)
     * {
     *     // The query parameters of the authorization request.
     *     String parameters = uriInfo.getRequestUri().getQuery();
     *     ......
     * }
     * 
     * <p>@POST
     * @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
     * public Response post(String parameters)
     * {
     *     // 'parameters' is the entity body of the authorization request.
     *     ......
     * }
     * ```
     * 
     * <p>The endpoint implementation does not have to parse the request parameters from the client application
     * because Authlete's `/auth/authorization` API does it.
     * 
     * <p>The response from `/auth/authorization` API has various parameters. Among them, it is `action`
     * parameter that the authorization server implementation should check first because it denotes the
     * next action that the authorization server implementation should take. According to the value of
     * `action`, the service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete.
     * In either case, from the viewpoint of the client application, it is an error on the server side.
     * Therefore, the service implementation should generate a response to the client application with
     * HTTP status of "500 Internal Server Error". Authlete recommends `application/json` as the content
     * type although OAuth 2.0 specification does not mention the format of the error response when the
     * redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application
     * since "500 Internal Server Error" is not required by OAuth 2.0.
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * is invalid.
     * 
     * <p>A response with HTTP status of "400 Bad Request" should be returned to the client application and
     * Authlete recommends `application/json` as the content type although OAuth 2.0 specification does
     * not mention the format of the error response when the redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application since
     * "400 Bad Request" is not required by OAuth 2.0.
     * 
     * <p>**LOCATION**
     * 
     * <p>When the value of `action` is `LOCATION`, it means that the request from the client application
     * is invalid but the redirect URI
     * to which the error should be reported has been determined.
     * 
     * <p>A response with HTTP status of "302 Found" must be returned to the client application with `Location`
     * header which has a redirect URI with error parameter.
     * 
     * <p>The value of `responseContent` is a redirect URI with `error` parameter, so it can be used as the
     * value of `Location` header.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 302 Found
     * Location: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORM**
     * 
     * <p>When the value of `action` is `FORM`, it means that the request from the client application is
     * invalid but the redirect URI to which the error should be reported has been determined, and that
     * the authorization request contains `response_mode=form_post` as is defined in [OAuth 2.0 Form Post
     * Response Mode](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html).
     * 
     * <p>The HTTP status of the response returned to the client application should be "200 OK" and the
     * content type should be `text/html;charset=UTF-8`.
     * 
     * <p>The value of `responseContent` is an HTML which can be used as the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Content-Type: text/html;charset=UTF-8
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>**NO_INTERACTION**
     * 
     * <p>When the value of `action` is `NO_INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request without displaying any user interface
     * pages for authentication or consent. This case happens when the authorization request contains
     * `prompt=none`.
     * 
     * <p>The service must follow the steps described below.
     * 
     * <p>[1] END-USER AUTHENTICATION
     * 
     * <p>Check whether an end-user has already logged in. If an end-user has logged in, go to the next step ([MAX_AGE]).
     * Otherwise, call Authlete's `/auth/authorization/fail` API with `reason=NOT_LOGGED_IN` and use the response from
     * the API to generate a response to the client application.
     * 
     * <p>[2] MAX AGE
     * 
     * <p>Get the value of `maxAge` parameter from the `/auth/authorization` API response. The value represents
     * the maximum authentication age which has come from `max_age` request parameter or `defaultMaxAge`
     * configuration parameter of the client application. If the value is `0`, go to the next step ([SUBJECT]).
     * Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Get the time at which the end-user was authenticated. that this value is not managed by Authlete,
     * meaning that it is expected that the service implementation manages the value. If the service implementation
     * does not manage authentication time of end-users, call Authlete's `/auth/authorization/fail` API
     * with `reason=MAX_AGE_NOT_SUPPORTED` and use the API response to generate a response to the client
     * application.
     * 
     * <p>(ii) Add the value of the maximum authentication age (which is represented in seconds) to the authentication
     * time. The calculated value is the expiration time.
     * 
     * <p>(iii) Check whether the calculated value is equal to or greater than the current time. If this condition
     * is satisfied, go to the next step ([SUBJECT]). Otherwise, call Authlete's `/auth/authorization/fail`
     * API with `reason=EXCEEDS_MAX_AGE` and use the API response to generate a response to the client
     * application.
     * 
     * <p>[3] SUBJECT
     * 
     * <p>Get the value of `subject` from the `/auth/authorization` API response. The value represents an
     * end-user who the client application expects to grant authorization. If the value is `null`, go to
     * the next step ([ACRs]). Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Compare the value of the requested subject to the current end-user.
     * 
     * <p>(ii) If they are equal, go to the next step ([ACRs]). If they are not equal, call Authlete's
     * `/auth/authorization/fail` API with `reason=DIFFERENT_SUBJECT` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>[4] ACRs
     * 
     * <p>Get the value of `acrs` from the `/auth/authorization` API response. The value represents a list
     * of ACRs (Authentication Context Class References) and comes from (1) acr claim in `claims` request
     * parameter, (2) `acr_values` request parameter, or (3) `default_acr_values` configuration parameter
     * of the client application.
     * 
     * <p>It is ensured that all the ACRs in acrs are supported by the authorization server implementation.
     * In other words, it is ensured that all the ACRs are listed in `acr_values_supported` configuration
     * parameter of the authorization server.
     * 
     * <p>If the value of ACRs is `null`, go to the next step ([ISSUE]). Otherwise, follow the sub steps
     * described below.
     * 
     * <p>(i) Get the ACR performed for the authentication of the current end-user. Note that this value is
     * managed not by Authlete but by the authorization server implementation. (If the authorization server
     * implementation cannot handle ACRs, it should not have listed ACRs as `acr_values_supported`.)
     * 
     * <p>(ii) Compare the ACR value obtained in the above step to each element in the ACR array (`acrs`)
     * in the listed order.
     * 
     * <p>(iii) If the ACR value was found in the array, (= the ACR performed for the authentication of the
     * current end-user did not match any one of the ACRs requested by the client application), check
     * whether one of the requested ACRs must be satisfied or not using `acrEssential` parameter in the
     * `/auth/authorization` API response. If the value of `acrEssential` parameter is `true`, call Authlete's
     * `/auth/authorization/fail` API with `reason=ACR_NOT_SATISFIED` and use the response from the API
     * to generate a response to the client application. Otherwise, go to the next step ([SCOPES]).
     * 
     * <p>[5] SCOPES
     * 
     * <p>Get the value of `scopes` from the `/auth/authorization` API response. If the array contains a
     * scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), which is only available in a dedicated/onpremise Authlete server (contact sales@authlete.com
     * for details).
     * 
     * <p>[6] DYNAMIC SCOPES
     * 
     * <p>Get the value of `dynamicScopes` from the `/auth/authorization` API response. If the array contains
     * a scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs) but dynamic scopes are not remembered as granted scopes.
     * 
     * <p>[7] RESOURCES
     * 
     * <p>Get the value of `resources` from the `/auth/authorization` API response. The array represents
     * the values of the `resource` request parameters. If you want to reject the request, call Authlete's
     * `/auth/authorization/fail` API with `reason=INVALID_TARGET` and use the response from the API to
     * generate a response to the client application. Otherwise, go to the next step ([ISSUE]).
     * 
     * <p>See "Resource Indicators for OAuth 2.0" for details.
     * 
     * <p>[8] ISSUE
     * 
     * <p>If all the above steps succeeded, the last step is to issue an authorization code, an ID token
     * and/or an access token. (There is a special case, though. In the case of `response_type=none`,
     * nothing is issued.) It can be performed by calling Authlete's `/auth/authorization/issue` API.
     * The API requires the following parameters. Prepare these parameters and call `/auth/authorization/issue`
     * API and use the response to generate a response to the client application.
     * 
     * <p>- &lt;u&gt;`ticket` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents a ticket which is exchanged with tokens at `/auth/authorization/issue`.
     *   Use the value of `ticket` contained in the `/auth/authorization` API response.
     * 
     * <p>- &lt;u&gt;`subject` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the unique identifier of the current end-user. It is often called "user ID"
     *   and it may or may not be visible to the user. In any case, it is a number or a string assigned
     *   to an end-user by the authorization server implementation. Authlete does not care about the format
     *   of the value of subject, but it must consist of only ASCII letters and its length must not exceed 100.
     * 
     * <p>  When the value of `subject` parameter in the /auth/authorization API response is not `null`,
     *   it is necessarily identical to the value of `subject` parameter in the `/auth/authorization/issue`
     *   API request.
     * 
     * <p>  The value of this parameter will be embedded in an ID token as the value of `sub` claim. When
     *   the value of `subject_type` configuration parameter of the client application is `PAIRWISE`,
     *   the value of sub claim is different from the value specified by this parameter, See [8. Subject
     *   Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes) of OpenID
     *   Connect Core 1.0 for details about subject types.
     * 
     * <p>  You can use the `sub` request parameter to adjust the value of the `sub` claim in an ID token.
     *   See the description of the `sub` request parameter for details.
     * 
     * <p>- &lt;u&gt;`authTime` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the time when the end-user authentication occurred. Its value is the
     *   number of seconds from `1970-01-01`. The value of this parameter will be embedded in an ID token
     *   as the value of `auth_time` claim.
     * 
     * <p>- &lt;u&gt;`acr` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the ACR (Authentication Context Class Reference) which the authentication
     *   of the end-user satisfies. When `acrs` in the `/auth/authorization` API response is a non-empty
     *   array and the value of `acrEssential` is `true`, the value of this parameter must be one of the
     *   array elements. Otherwise, even `null` is allowed. The value of this parameter will be embedded
     *   in an ID token as the value of `acr` claim.
     * 
     * <p>- &lt;u&gt;`claims` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents claims of the end-user. "Claims" here are pieces of information about
     *   the end-user such as `"name"`, `"email"` and `"birthdate"`. The authorization server implementation
     *   is required to gather claims of the end-user, format the claim values into JSON and set the JSON
     *   string as the value of this parameter.
     * 
     * <p>  The claims which the authorization server implementation is required to gather are listed in
     *   `claims` parameter in the `/auth/authorization` API response.
     * 
     * <p>  For example, if claims parameter lists `"name"`, `"email"` and `"birthdate"`, the value of this
     *   parameter should look like the following.
     * 
     * <p>  ```json
     *   {
     *     "name": "John Smith",
     *     "email": "john@example.com",
     *     "birthdate": "1974-05-06"
     *   }
     *   ```
     * 
     * <p>  `claimsLocales` parameter in the `/auth/authorization` API response lists the end-user's preferred
     *   languages and scripts, ordered by preference. When `claimsLocales` parameter is a non-empty array,
     *   its elements should be taken into account when the authorization server implementation gathers
     *   claim values. Especially, note the excerpt below from [5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
     *   of OpenID Connect Core 1.0.
     * 
     * <p>  &gt; When the OP determines, either through the `claims_locales` parameter, or by other means, that
     *   the End-User and Client are requesting Claims in only one set of languages and scripts, it is
     *   RECOMMENDED that OPs return Claims without language tags when they employ this language and script.
     *   It is also RECOMMENDED that Clients be written in a manner that they can handle and utilize Claims
     *   using language tags.
     * 
     * <p>  If `claims` parameter in the `/auth/authorization` API response is `null` or an empty array,
     *   the value of this parameter should be `null`.
     * 
     * <p>  See [5.1. Standard Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)
     *   of OpenID Connect core 1.0 for claim names and their value formats. Note (1) that the authorization
     *   server implementation support its special claims ([5.1.2. Additional Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims))
     *   and (2) that claim names may be followed by a language tag ([5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)).
     *   Read the specification of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
     *   for details.
     * 
     * <p>  The claim values in this parameter will be embedded in an ID token.
     * 
     * <p>  Note that `idTokenClaims` parameter is available in the `/auth/authorization` API response.
     *   The parameter has the value of the `"id_token"` property in the `claims` request parameter or
     *   in the `"claims"` property in a request object. The value of this parameter should be considered
     *   when you prepare claim values.
     * 
     * <p>- &lt;u&gt;`properties` (optional)&lt;/u&gt;&lt;br&gt;
     *   Extra properties to associate with an access token and/or an authorization code that may be issued
     *   by this request. Note that `properties` parameter is accepted only when `Content-Type` of the
     *   request is `application/json`, so don't use `application/x-www-form-urlencoded` for details.
     * 
     * <p>- &lt;u&gt;`scopes` (optional)&lt;/u&gt;&lt;br&gt;
     *   Scopes to associate with an access token and/or an authorization code. If this parameter is `null`,
     *   the scopes specified in the original authorization request from the client application are used.
     *   In other cases, including the case of an empty array, the specified scopes will replace the original
     *   scopes contained in the original authorization request.
     * 
     * <p>  Even scopes that are not included in the original authorization request can be specified. However,
     *   as an exception, `openid` scope is ignored on the server side if it is not included in the original
     *   request. It is because the existence of `openid` scope considerably changes the validation steps
     *   and because adding `openid` triggers generation of an ID token (although the client application
     *   has not requested it) and the behavior is a major violation against the specification.
     * 
     * <p>  If you add `offline_access` scope although it is not included in the original request, keep in
     *   mind that the specification requires explicit consent from the user for the scope ([OpenID Connect
     *   Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess)).
     *   When `offline_access` is included in the original request, the current implementation of Authlete's
     *   `/auth/authorization` API checks whether the request has come along with `prompt` request parameter
     *   and the value includes consent. However, note that the implementation of Authlete's `/auth/authorization/issue`
     *   API does not perform such checking if `offline_access` scope is added via this `scopes` parameter.
     * 
     * <p>- &lt;u&gt;`sub` (optional)&lt;/u&gt;&lt;br&gt;
     *   The value of the `sub` claim in an ID token. If the value of this request parameter is not empty,
     *   it is used as the value of the `sub` claim. Otherwise, the value of the `subject` request parameter
     *   is used as the value of the `sub` claim. The main purpose of this parameter is to hide the actual
     *   value of the subject from client applications.
     * 
     * <p>  Note that even if this `sub` parameter is not empty, the value of the subject request parameter
     *   is used as the value of the subject which is associated with the access token.
     * 
     * <p>**INTERACTION**
     * 
     * <p>When the value of `action` is `INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request with user interaction by an HTML form.
     * The purpose of the UI displayed to the end-user is to ask the end-user to grant authorization to
     * the client application. The items described below are some points which the service implementation
     * should take into account when it builds the UI.
     * 
     * <p>[1] DISPLAY MODE
     * 
     * <p>The response from `/auth/authorization` API has `display` parameter. It is one of `PAGE` (default),
     * `POPUP`, `TOUCH` and `WAP` The meanings of the values are described in [3.1.2.1. Authentication
     * Request of OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * Basically, the authorization server implementation should display the UI which is suitable for the
     * display mode, but it is okay for the authorization server implementation to "attempt to detect the
     * capabilities of the User Agent and present an appropriate display".
     * 
     * <p>It is ensured that the value of `display` is one of the supported display modes which are specified
     * by `supportedDisplays` configuration parameter of the service.
     * 
     * <p>[2] UI LOCALE
     * 
     * <p>The response from `/auth/authorization` API has `uiLocales` parameter. It it is not `null`, it lists
     * language tag values (such as `fr-CA`, `ja-JP` and `en`) ordered by preference. The service implementation
     * should display the UI in one of the language listed in the parameter when possible. It is ensured
     * that language tags listed in `uiLocales` are contained in the list of supported UI locales which
     * are specified by `supportedUiLocales` configuration parameter of the service.
     * 
     * <p>[3] CLIENT INFORMATION
     * 
     * <p>The authorization server implementation should show information about the client application to
     * the end-user. The information is embedded in `client` parameter in the response from `/auth/authorization`
     * API.
     * 
     * <p>[4] SCOPES
     * 
     * <p>A client application requires authorization for specific permissions. In OAuth 2.0 specification,
     * "scope" is a technical term which represents a permission. `scopes` parameter in the response
     * from `/auth/authorization` API is a list of scopes requested by the client application. The service
     * implementation should show the end-user the scopes.
     * 
     * <p>The authorization server implementation may choose not to show scopes to which the end-user has
     * given consent in the past. To put it the other way around, the authorization server implementation
     * may show only the scopes to which the end-user has not given consent yet. However, if the value
     * of `prompts` response parameter contains `CONSENT`, the authorization server implementation has
     * to obtain explicit consent from the end-user even if the end-user has given consent to all the
     * requested scopes in the past.
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), but the APIs work only in the case the Authlete server you use is a dedicated Authlete server
     * (contact sales@authlete.com for details). In other words, the APIs of the shared Authlete server
     * are disabled intentionally (in order to prevent garbage data from being accumulated) and they
     * return 403 Forbidden.
     * 
     * <p>It is ensured that the values in `scopes` parameter are contained in the list of supported scopes
     * which are specified by `supportedScopes` configuration parameter of the service.
     * 
     * <p>[5] DYNAMIC SCOPES
     * 
     * <p>The authorization request may include dynamic scopes. The list of recognized dynamic scopes are
     * accessible by getDynamicScopes() method. See the description of the [DynamicScope](https://authlete.github.io/authlete-java-common/com/authlete/common/dto/DynamicScope.html)
     * class for details about dynamic scopes.
     * 
     * <p>[6] AUTHORIZATION DETAILS
     * 
     * <p>The authorization server implementation should show the end-user "authorization details" if the
     * request includes it. The value of `authorization_details` parameter in the response is the content
     * of the `authorization_details` request parameter.
     * 
     * <p>See "OAuth 2.0 Rich Authorization Requests" for details.
     * 
     * <p>[7] PURPOSE
     * 
     * <p>The authorization server implementation must show the value of the `purpose` request parameter if
     * it supports [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html).
     * See [8. Transaction-specific Purpose](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.8)
     * in the specification for details.
     * 
     * <p>Note that the value of `purpose` response parameter is the value of the purpose request parameter.
     * 
     * <p>[7] END-USER AUTHENTICATION
     * 
     * <p>Necessarily, the end-user must be authenticated (= must login the service) before granting authorization
     * to the client application. Simply put, a login form is expected to be displayed for end-user authentication.
     * The service implementation must follow the steps described below to comply with OpenID Connect.
     * (Or just always show a login form if it's too much of a bother.)
     * 
     * <p>(i) Get the value of `prompts` response parameter. It corresponds to the value of the `prompt`
     * request parameter. Details of the request parameter are described in [3.1.2.1. Authentication
     * Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) of OpenID Connect Core 1.0.
     * 
     * <p>(ii) If the value of `prompts` parameter is `SELECT_ACCOUNT` display a form to let the end-user
     * select on of his/her accounts for login. If `subject` response parameter is not `null`, it is the
     * end-user ID that the client application expects, so the value should be used to determine the value
     * of the login ID. Note that a subject and a login ID are not necessarily equal. If the value of
     * `subject` response parameter is `null`, the value of `loginHint` response parameter should be referred
     * to as a hint to determine the value of the login ID. The value of `loginHint` response parameter
     * is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iii) If the value of `prompts` response parameter contains `LOGIN`, display a form to urge the
     * end-user to login even if the end-user has already logged in. If the value of `subject` response
     * parameter is not `null`, it is the end-user ID that the client application expects, so the value
     * should be used to determine the value of the login ID. Note that a subject and a login ID are not
     * necessarily equal. If the value of `subject` response parameter is `null`, the value of `loginHint`
     * response parameter should be referred to as a hint to determine the value of the login ID. The value
     * of `loginHint` response parameter is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iv) If the value of `prompts` response parameter does not contain `LOGIN`, the authorization server
     * implementation does not have to authenticate the end-user if all the conditions described below
     * are satisfied. If any one of the conditions is not satisfied, show a login form to authenticate
     * the end-user.
     * 
     * <p>- An end-user has already logged in the service.
     * 
     * <p>- The login ID of the current end-user matches the value of `subject` response parameter.
     * This check is required only when the value of `subject` response parameter is a non-null value.
     * 
     * <p>- The max age, which is the number of seconds contained in `maxAge` response parameter,
     * has not passed since the current end-user logged in your service. This check is required only when
     * the value of `maxAge` response parameter is a non-zero value.
     * 
     * <p>- If the authorization server implementation does not manage authentication time of end-users
     * (= if the authorization server implementation cannot know when end-users logged in) and if the
     * value of `maxAge` response parameter is a non-zero value, a login form should be displayed.
     * 
     * <p>- The ACR (Authentication Context Class Reference) of the authentication performed for
     * the current end-user satisfies one of the ACRs listed in `acrs` response parameter. This check is
     * required only when the value of `acrs` response parameter is a non-empty array.
     * 
     * <p>In every case, the end-user authentication must satisfy one of the ACRs listed in `acrs` response
     * parameter when the value of `acrs` response parameter is a non-empty array and `acrEssential`
     * response parameter is `true`.
     * 
     * <p>[9] GRANT/DENY BUTTONS
     * 
     * <p>The end-user is supposed to choose either (1) to grant authorization to the client application or
     * (2) to deny the authorization request. The UI must have UI components to accept the judgment by
     * the user. Usually, a button to grant authorization and a button to deny the request are provided.
     * 
     * <p>When the value of `subject` response parameter is not `null`, the end-user authentication must be
     * performed for the subject, meaning that the authorization server implementation should repeatedly
     * show a login form until the subject is successfully authenticated.
     * 
     * <p>The end-user will choose either (1) to grant authorization to the client application or (2) to
     * deny the authorization request. When the end-user chose to deny the authorization request, call
     * Authlete's `/auth/authorization/fail` API with `reason=DENIED` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>When the end-user chose to grant authorization to the client application, the authorization server
     * implementation has to issue an authorization code, an ID token, and/or an access token to the client
     * application. (There is a special case. When `response_type=none`, nothing is issued.) Issuing the
     * tokens can be performed by calling Authlete's `/auth/authorization/issue` API. Read [ISSUE] written
     * above in the description for the case of `action=NO_INTERACTION`.
     * &lt;/details&gt;
     * 
     * @return The call builder
     */
    public AuthAuthorizationApiFormRequestBuilder processForm() {
        return new AuthAuthorizationApiFormRequestBuilder(sdkConfiguration);
    }

    /**
     * Process Authorization Request
     * 
     * <p>This API parses request parameters of an authorization request and returns necessary data for the authorization server
     * implementation to process the authorization request further.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the authorization endpoint of
     * the service. The endpoint implementation must extract the request parameters from the authorization
     * request from the client application and pass them as the value of parameters request parameter for
     * Authlete's `/auth/authorization` API.
     * 
     * <p>The value of `parameters` is either (1) the entire query string when the HTTP method of the request
     * from the client application is `GET` or (2) the entire entity body (which is formatted in
     * `application/x-www-form-urlencoded`) when the HTTP method of the request from the client application
     * is `POST`.
     * 
     * <p>The following code snippet is an example in JAX-RS showing how to extract request parameters from
     * the authorization request.
     * 
     * <p>```java
     * @GET
     * public Response get(@Context UriInfo uriInfo)
     * {
     *     // The query parameters of the authorization request.
     *     String parameters = uriInfo.getRequestUri().getQuery();
     *     ......
     * }
     * 
     * <p>@POST
     * @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
     * public Response post(String parameters)
     * {
     *     // 'parameters' is the entity body of the authorization request.
     *     ......
     * }
     * ```
     * 
     * <p>The endpoint implementation does not have to parse the request parameters from the client application
     * because Authlete's `/auth/authorization` API does it.
     * 
     * <p>The response from `/auth/authorization` API has various parameters. Among them, it is `action`
     * parameter that the authorization server implementation should check first because it denotes the
     * next action that the authorization server implementation should take. According to the value of
     * `action`, the service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete.
     * In either case, from the viewpoint of the client application, it is an error on the server side.
     * Therefore, the service implementation should generate a response to the client application with
     * HTTP status of "500 Internal Server Error". Authlete recommends `application/json` as the content
     * type although OAuth 2.0 specification does not mention the format of the error response when the
     * redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application
     * since "500 Internal Server Error" is not required by OAuth 2.0.
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * is invalid.
     * 
     * <p>A response with HTTP status of "400 Bad Request" should be returned to the client application and
     * Authlete recommends `application/json` as the content type although OAuth 2.0 specification does
     * not mention the format of the error response when the redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application since
     * "400 Bad Request" is not required by OAuth 2.0.
     * 
     * <p>**LOCATION**
     * 
     * <p>When the value of `action` is `LOCATION`, it means that the request from the client application
     * is invalid but the redirect URI
     * to which the error should be reported has been determined.
     * 
     * <p>A response with HTTP status of "302 Found" must be returned to the client application with `Location`
     * header which has a redirect URI with error parameter.
     * 
     * <p>The value of `responseContent` is a redirect URI with `error` parameter, so it can be used as the
     * value of `Location` header.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 302 Found
     * Location: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORM**
     * 
     * <p>When the value of `action` is `FORM`, it means that the request from the client application is
     * invalid but the redirect URI to which the error should be reported has been determined, and that
     * the authorization request contains `response_mode=form_post` as is defined in [OAuth 2.0 Form Post
     * Response Mode](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html).
     * 
     * <p>The HTTP status of the response returned to the client application should be "200 OK" and the
     * content type should be `text/html;charset=UTF-8`.
     * 
     * <p>The value of `responseContent` is an HTML which can be used as the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Content-Type: text/html;charset=UTF-8
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>**NO_INTERACTION**
     * 
     * <p>When the value of `action` is `NO_INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request without displaying any user interface
     * pages for authentication or consent. This case happens when the authorization request contains
     * `prompt=none`.
     * 
     * <p>The service must follow the steps described below.
     * 
     * <p>[1] END-USER AUTHENTICATION
     * 
     * <p>Check whether an end-user has already logged in. If an end-user has logged in, go to the next step ([MAX_AGE]).
     * Otherwise, call Authlete's `/auth/authorization/fail` API with `reason=NOT_LOGGED_IN` and use the response from
     * the API to generate a response to the client application.
     * 
     * <p>[2] MAX AGE
     * 
     * <p>Get the value of `maxAge` parameter from the `/auth/authorization` API response. The value represents
     * the maximum authentication age which has come from `max_age` request parameter or `defaultMaxAge`
     * configuration parameter of the client application. If the value is `0`, go to the next step ([SUBJECT]).
     * Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Get the time at which the end-user was authenticated. that this value is not managed by Authlete,
     * meaning that it is expected that the service implementation manages the value. If the service implementation
     * does not manage authentication time of end-users, call Authlete's `/auth/authorization/fail` API
     * with `reason=MAX_AGE_NOT_SUPPORTED` and use the API response to generate a response to the client
     * application.
     * 
     * <p>(ii) Add the value of the maximum authentication age (which is represented in seconds) to the authentication
     * time. The calculated value is the expiration time.
     * 
     * <p>(iii) Check whether the calculated value is equal to or greater than the current time. If this condition
     * is satisfied, go to the next step ([SUBJECT]). Otherwise, call Authlete's `/auth/authorization/fail`
     * API with `reason=EXCEEDS_MAX_AGE` and use the API response to generate a response to the client
     * application.
     * 
     * <p>[3] SUBJECT
     * 
     * <p>Get the value of `subject` from the `/auth/authorization` API response. The value represents an
     * end-user who the client application expects to grant authorization. If the value is `null`, go to
     * the next step ([ACRs]). Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Compare the value of the requested subject to the current end-user.
     * 
     * <p>(ii) If they are equal, go to the next step ([ACRs]). If they are not equal, call Authlete's
     * `/auth/authorization/fail` API with `reason=DIFFERENT_SUBJECT` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>[4] ACRs
     * 
     * <p>Get the value of `acrs` from the `/auth/authorization` API response. The value represents a list
     * of ACRs (Authentication Context Class References) and comes from (1) acr claim in `claims` request
     * parameter, (2) `acr_values` request parameter, or (3) `default_acr_values` configuration parameter
     * of the client application.
     * 
     * <p>It is ensured that all the ACRs in acrs are supported by the authorization server implementation.
     * In other words, it is ensured that all the ACRs are listed in `acr_values_supported` configuration
     * parameter of the authorization server.
     * 
     * <p>If the value of ACRs is `null`, go to the next step ([ISSUE]). Otherwise, follow the sub steps
     * described below.
     * 
     * <p>(i) Get the ACR performed for the authentication of the current end-user. Note that this value is
     * managed not by Authlete but by the authorization server implementation. (If the authorization server
     * implementation cannot handle ACRs, it should not have listed ACRs as `acr_values_supported`.)
     * 
     * <p>(ii) Compare the ACR value obtained in the above step to each element in the ACR array (`acrs`)
     * in the listed order.
     * 
     * <p>(iii) If the ACR value was found in the array, (= the ACR performed for the authentication of the
     * current end-user did not match any one of the ACRs requested by the client application), check
     * whether one of the requested ACRs must be satisfied or not using `acrEssential` parameter in the
     * `/auth/authorization` API response. If the value of `acrEssential` parameter is `true`, call Authlete's
     * `/auth/authorization/fail` API with `reason=ACR_NOT_SATISFIED` and use the response from the API
     * to generate a response to the client application. Otherwise, go to the next step ([SCOPES]).
     * 
     * <p>[5] SCOPES
     * 
     * <p>Get the value of `scopes` from the `/auth/authorization` API response. If the array contains a
     * scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), which is only available in a dedicated/onpremise Authlete server (contact sales@authlete.com
     * for details).
     * 
     * <p>[6] DYNAMIC SCOPES
     * 
     * <p>Get the value of `dynamicScopes` from the `/auth/authorization` API response. If the array contains
     * a scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs) but dynamic scopes are not remembered as granted scopes.
     * 
     * <p>[7] RESOURCES
     * 
     * <p>Get the value of `resources` from the `/auth/authorization` API response. The array represents
     * the values of the `resource` request parameters. If you want to reject the request, call Authlete's
     * `/auth/authorization/fail` API with `reason=INVALID_TARGET` and use the response from the API to
     * generate a response to the client application. Otherwise, go to the next step ([ISSUE]).
     * 
     * <p>See "Resource Indicators for OAuth 2.0" for details.
     * 
     * <p>[8] ISSUE
     * 
     * <p>If all the above steps succeeded, the last step is to issue an authorization code, an ID token
     * and/or an access token. (There is a special case, though. In the case of `response_type=none`,
     * nothing is issued.) It can be performed by calling Authlete's `/auth/authorization/issue` API.
     * The API requires the following parameters. Prepare these parameters and call `/auth/authorization/issue`
     * API and use the response to generate a response to the client application.
     * 
     * <p>- &lt;u&gt;`ticket` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents a ticket which is exchanged with tokens at `/auth/authorization/issue`.
     *   Use the value of `ticket` contained in the `/auth/authorization` API response.
     * 
     * <p>- &lt;u&gt;`subject` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the unique identifier of the current end-user. It is often called "user ID"
     *   and it may or may not be visible to the user. In any case, it is a number or a string assigned
     *   to an end-user by the authorization server implementation. Authlete does not care about the format
     *   of the value of subject, but it must consist of only ASCII letters and its length must not exceed 100.
     * 
     * <p>  When the value of `subject` parameter in the /auth/authorization API response is not `null`,
     *   it is necessarily identical to the value of `subject` parameter in the `/auth/authorization/issue`
     *   API request.
     * 
     * <p>  The value of this parameter will be embedded in an ID token as the value of `sub` claim. When
     *   the value of `subject_type` configuration parameter of the client application is `PAIRWISE`,
     *   the value of sub claim is different from the value specified by this parameter, See [8. Subject
     *   Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes) of OpenID
     *   Connect Core 1.0 for details about subject types.
     * 
     * <p>  You can use the `sub` request parameter to adjust the value of the `sub` claim in an ID token.
     *   See the description of the `sub` request parameter for details.
     * 
     * <p>- &lt;u&gt;`authTime` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the time when the end-user authentication occurred. Its value is the
     *   number of seconds from `1970-01-01`. The value of this parameter will be embedded in an ID token
     *   as the value of `auth_time` claim.
     * 
     * <p>- &lt;u&gt;`acr` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the ACR (Authentication Context Class Reference) which the authentication
     *   of the end-user satisfies. When `acrs` in the `/auth/authorization` API response is a non-empty
     *   array and the value of `acrEssential` is `true`, the value of this parameter must be one of the
     *   array elements. Otherwise, even `null` is allowed. The value of this parameter will be embedded
     *   in an ID token as the value of `acr` claim.
     * 
     * <p>- &lt;u&gt;`claims` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents claims of the end-user. "Claims" here are pieces of information about
     *   the end-user such as `"name"`, `"email"` and `"birthdate"`. The authorization server implementation
     *   is required to gather claims of the end-user, format the claim values into JSON and set the JSON
     *   string as the value of this parameter.
     * 
     * <p>  The claims which the authorization server implementation is required to gather are listed in
     *   `claims` parameter in the `/auth/authorization` API response.
     * 
     * <p>  For example, if claims parameter lists `"name"`, `"email"` and `"birthdate"`, the value of this
     *   parameter should look like the following.
     * 
     * <p>  ```json
     *   {
     *     "name": "John Smith",
     *     "email": "john@example.com",
     *     "birthdate": "1974-05-06"
     *   }
     *   ```
     * 
     * <p>  `claimsLocales` parameter in the `/auth/authorization` API response lists the end-user's preferred
     *   languages and scripts, ordered by preference. When `claimsLocales` parameter is a non-empty array,
     *   its elements should be taken into account when the authorization server implementation gathers
     *   claim values. Especially, note the excerpt below from [5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
     *   of OpenID Connect Core 1.0.
     * 
     * <p>  &gt; When the OP determines, either through the `claims_locales` parameter, or by other means, that
     *   the End-User and Client are requesting Claims in only one set of languages and scripts, it is
     *   RECOMMENDED that OPs return Claims without language tags when they employ this language and script.
     *   It is also RECOMMENDED that Clients be written in a manner that they can handle and utilize Claims
     *   using language tags.
     * 
     * <p>  If `claims` parameter in the `/auth/authorization` API response is `null` or an empty array,
     *   the value of this parameter should be `null`.
     * 
     * <p>  See [5.1. Standard Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)
     *   of OpenID Connect core 1.0 for claim names and their value formats. Note (1) that the authorization
     *   server implementation support its special claims ([5.1.2. Additional Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims))
     *   and (2) that claim names may be followed by a language tag ([5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)).
     *   Read the specification of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
     *   for details.
     * 
     * <p>  The claim values in this parameter will be embedded in an ID token.
     * 
     * <p>  Note that `idTokenClaims` parameter is available in the `/auth/authorization` API response.
     *   The parameter has the value of the `"id_token"` property in the `claims` request parameter or
     *   in the `"claims"` property in a request object. The value of this parameter should be considered
     *   when you prepare claim values.
     * 
     * <p>- &lt;u&gt;`properties` (optional)&lt;/u&gt;&lt;br&gt;
     *   Extra properties to associate with an access token and/or an authorization code that may be issued
     *   by this request. Note that `properties` parameter is accepted only when `Content-Type` of the
     *   request is `application/json`, so don't use `application/x-www-form-urlencoded` for details.
     * 
     * <p>- &lt;u&gt;`scopes` (optional)&lt;/u&gt;&lt;br&gt;
     *   Scopes to associate with an access token and/or an authorization code. If this parameter is `null`,
     *   the scopes specified in the original authorization request from the client application are used.
     *   In other cases, including the case of an empty array, the specified scopes will replace the original
     *   scopes contained in the original authorization request.
     * 
     * <p>  Even scopes that are not included in the original authorization request can be specified. However,
     *   as an exception, `openid` scope is ignored on the server side if it is not included in the original
     *   request. It is because the existence of `openid` scope considerably changes the validation steps
     *   and because adding `openid` triggers generation of an ID token (although the client application
     *   has not requested it) and the behavior is a major violation against the specification.
     * 
     * <p>  If you add `offline_access` scope although it is not included in the original request, keep in
     *   mind that the specification requires explicit consent from the user for the scope ([OpenID Connect
     *   Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess)).
     *   When `offline_access` is included in the original request, the current implementation of Authlete's
     *   `/auth/authorization` API checks whether the request has come along with `prompt` request parameter
     *   and the value includes consent. However, note that the implementation of Authlete's `/auth/authorization/issue`
     *   API does not perform such checking if `offline_access` scope is added via this `scopes` parameter.
     * 
     * <p>- &lt;u&gt;`sub` (optional)&lt;/u&gt;&lt;br&gt;
     *   The value of the `sub` claim in an ID token. If the value of this request parameter is not empty,
     *   it is used as the value of the `sub` claim. Otherwise, the value of the `subject` request parameter
     *   is used as the value of the `sub` claim. The main purpose of this parameter is to hide the actual
     *   value of the subject from client applications.
     * 
     * <p>  Note that even if this `sub` parameter is not empty, the value of the subject request parameter
     *   is used as the value of the subject which is associated with the access token.
     * 
     * <p>**INTERACTION**
     * 
     * <p>When the value of `action` is `INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request with user interaction by an HTML form.
     * The purpose of the UI displayed to the end-user is to ask the end-user to grant authorization to
     * the client application. The items described below are some points which the service implementation
     * should take into account when it builds the UI.
     * 
     * <p>[1] DISPLAY MODE
     * 
     * <p>The response from `/auth/authorization` API has `display` parameter. It is one of `PAGE` (default),
     * `POPUP`, `TOUCH` and `WAP` The meanings of the values are described in [3.1.2.1. Authentication
     * Request of OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * Basically, the authorization server implementation should display the UI which is suitable for the
     * display mode, but it is okay for the authorization server implementation to "attempt to detect the
     * capabilities of the User Agent and present an appropriate display".
     * 
     * <p>It is ensured that the value of `display` is one of the supported display modes which are specified
     * by `supportedDisplays` configuration parameter of the service.
     * 
     * <p>[2] UI LOCALE
     * 
     * <p>The response from `/auth/authorization` API has `uiLocales` parameter. It it is not `null`, it lists
     * language tag values (such as `fr-CA`, `ja-JP` and `en`) ordered by preference. The service implementation
     * should display the UI in one of the language listed in the parameter when possible. It is ensured
     * that language tags listed in `uiLocales` are contained in the list of supported UI locales which
     * are specified by `supportedUiLocales` configuration parameter of the service.
     * 
     * <p>[3] CLIENT INFORMATION
     * 
     * <p>The authorization server implementation should show information about the client application to
     * the end-user. The information is embedded in `client` parameter in the response from `/auth/authorization`
     * API.
     * 
     * <p>[4] SCOPES
     * 
     * <p>A client application requires authorization for specific permissions. In OAuth 2.0 specification,
     * "scope" is a technical term which represents a permission. `scopes` parameter in the response
     * from `/auth/authorization` API is a list of scopes requested by the client application. The service
     * implementation should show the end-user the scopes.
     * 
     * <p>The authorization server implementation may choose not to show scopes to which the end-user has
     * given consent in the past. To put it the other way around, the authorization server implementation
     * may show only the scopes to which the end-user has not given consent yet. However, if the value
     * of `prompts` response parameter contains `CONSENT`, the authorization server implementation has
     * to obtain explicit consent from the end-user even if the end-user has given consent to all the
     * requested scopes in the past.
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), but the APIs work only in the case the Authlete server you use is a dedicated Authlete server
     * (contact sales@authlete.com for details). In other words, the APIs of the shared Authlete server
     * are disabled intentionally (in order to prevent garbage data from being accumulated) and they
     * return 403 Forbidden.
     * 
     * <p>It is ensured that the values in `scopes` parameter are contained in the list of supported scopes
     * which are specified by `supportedScopes` configuration parameter of the service.
     * 
     * <p>[5] DYNAMIC SCOPES
     * 
     * <p>The authorization request may include dynamic scopes. The list of recognized dynamic scopes are
     * accessible by getDynamicScopes() method. See the description of the [DynamicScope](https://authlete.github.io/authlete-java-common/com/authlete/common/dto/DynamicScope.html)
     * class for details about dynamic scopes.
     * 
     * <p>[6] AUTHORIZATION DETAILS
     * 
     * <p>The authorization server implementation should show the end-user "authorization details" if the
     * request includes it. The value of `authorization_details` parameter in the response is the content
     * of the `authorization_details` request parameter.
     * 
     * <p>See "OAuth 2.0 Rich Authorization Requests" for details.
     * 
     * <p>[7] PURPOSE
     * 
     * <p>The authorization server implementation must show the value of the `purpose` request parameter if
     * it supports [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html).
     * See [8. Transaction-specific Purpose](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.8)
     * in the specification for details.
     * 
     * <p>Note that the value of `purpose` response parameter is the value of the purpose request parameter.
     * 
     * <p>[7] END-USER AUTHENTICATION
     * 
     * <p>Necessarily, the end-user must be authenticated (= must login the service) before granting authorization
     * to the client application. Simply put, a login form is expected to be displayed for end-user authentication.
     * The service implementation must follow the steps described below to comply with OpenID Connect.
     * (Or just always show a login form if it's too much of a bother.)
     * 
     * <p>(i) Get the value of `prompts` response parameter. It corresponds to the value of the `prompt`
     * request parameter. Details of the request parameter are described in [3.1.2.1. Authentication
     * Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) of OpenID Connect Core 1.0.
     * 
     * <p>(ii) If the value of `prompts` parameter is `SELECT_ACCOUNT` display a form to let the end-user
     * select on of his/her accounts for login. If `subject` response parameter is not `null`, it is the
     * end-user ID that the client application expects, so the value should be used to determine the value
     * of the login ID. Note that a subject and a login ID are not necessarily equal. If the value of
     * `subject` response parameter is `null`, the value of `loginHint` response parameter should be referred
     * to as a hint to determine the value of the login ID. The value of `loginHint` response parameter
     * is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iii) If the value of `prompts` response parameter contains `LOGIN`, display a form to urge the
     * end-user to login even if the end-user has already logged in. If the value of `subject` response
     * parameter is not `null`, it is the end-user ID that the client application expects, so the value
     * should be used to determine the value of the login ID. Note that a subject and a login ID are not
     * necessarily equal. If the value of `subject` response parameter is `null`, the value of `loginHint`
     * response parameter should be referred to as a hint to determine the value of the login ID. The value
     * of `loginHint` response parameter is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iv) If the value of `prompts` response parameter does not contain `LOGIN`, the authorization server
     * implementation does not have to authenticate the end-user if all the conditions described below
     * are satisfied. If any one of the conditions is not satisfied, show a login form to authenticate
     * the end-user.
     * 
     * <p>- An end-user has already logged in the service.
     * 
     * <p>- The login ID of the current end-user matches the value of `subject` response parameter.
     * This check is required only when the value of `subject` response parameter is a non-null value.
     * 
     * <p>- The max age, which is the number of seconds contained in `maxAge` response parameter,
     * has not passed since the current end-user logged in your service. This check is required only when
     * the value of `maxAge` response parameter is a non-zero value.
     * 
     * <p>- If the authorization server implementation does not manage authentication time of end-users
     * (= if the authorization server implementation cannot know when end-users logged in) and if the
     * value of `maxAge` response parameter is a non-zero value, a login form should be displayed.
     * 
     * <p>- The ACR (Authentication Context Class Reference) of the authentication performed for
     * the current end-user satisfies one of the ACRs listed in `acrs` response parameter. This check is
     * required only when the value of `acrs` response parameter is a non-empty array.
     * 
     * <p>In every case, the end-user authentication must satisfy one of the ACRs listed in `acrs` response
     * parameter when the value of `acrs` response parameter is a non-empty array and `acrEssential`
     * response parameter is `true`.
     * 
     * <p>[9] GRANT/DENY BUTTONS
     * 
     * <p>The end-user is supposed to choose either (1) to grant authorization to the client application or
     * (2) to deny the authorization request. The UI must have UI components to accept the judgment by
     * the user. Usually, a button to grant authorization and a button to deny the request are provided.
     * 
     * <p>When the value of `subject` response parameter is not `null`, the end-user authentication must be
     * performed for the subject, meaning that the authorization server implementation should repeatedly
     * show a login form until the subject is successfully authenticated.
     * 
     * <p>The end-user will choose either (1) to grant authorization to the client application or (2) to
     * deny the authorization request. When the end-user chose to deny the authorization request, call
     * Authlete's `/auth/authorization/fail` API with `reason=DENIED` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>When the end-user chose to grant authorization to the client application, the authorization server
     * implementation has to issue an authorization code, an ID token, and/or an access token to the client
     * application. (There is a special case. When `response_type=none`, nothing is issued.) Issuing the
     * tokens can be performed by calling Authlete's `/auth/authorization/issue` API. Read [ISSUE] written
     * above in the description for the case of `action=NO_INTERACTION`.
     * &lt;/details&gt;
     * 
     * @param serviceId A service ID.
     * @param requestBody 
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public AuthAuthorizationApiFormResponse processForm(@Nonnull String serviceId, @Nonnull AuthAuthorizationApiFormRequestBody requestBody) throws Exception {
        return processForm(serviceId, requestBody, null);
    }

    /**
     * Process Authorization Request
     * 
     * <p>This API parses request parameters of an authorization request and returns necessary data for the authorization server
     * implementation to process the authorization request further.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the authorization endpoint of
     * the service. The endpoint implementation must extract the request parameters from the authorization
     * request from the client application and pass them as the value of parameters request parameter for
     * Authlete's `/auth/authorization` API.
     * 
     * <p>The value of `parameters` is either (1) the entire query string when the HTTP method of the request
     * from the client application is `GET` or (2) the entire entity body (which is formatted in
     * `application/x-www-form-urlencoded`) when the HTTP method of the request from the client application
     * is `POST`.
     * 
     * <p>The following code snippet is an example in JAX-RS showing how to extract request parameters from
     * the authorization request.
     * 
     * <p>```java
     * @GET
     * public Response get(@Context UriInfo uriInfo)
     * {
     *     // The query parameters of the authorization request.
     *     String parameters = uriInfo.getRequestUri().getQuery();
     *     ......
     * }
     * 
     * <p>@POST
     * @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
     * public Response post(String parameters)
     * {
     *     // 'parameters' is the entity body of the authorization request.
     *     ......
     * }
     * ```
     * 
     * <p>The endpoint implementation does not have to parse the request parameters from the client application
     * because Authlete's `/auth/authorization` API does it.
     * 
     * <p>The response from `/auth/authorization` API has various parameters. Among them, it is `action`
     * parameter that the authorization server implementation should check first because it denotes the
     * next action that the authorization server implementation should take. According to the value of
     * `action`, the service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete.
     * In either case, from the viewpoint of the client application, it is an error on the server side.
     * Therefore, the service implementation should generate a response to the client application with
     * HTTP status of "500 Internal Server Error". Authlete recommends `application/json` as the content
     * type although OAuth 2.0 specification does not mention the format of the error response when the
     * redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application
     * since "500 Internal Server Error" is not required by OAuth 2.0.
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * is invalid.
     * 
     * <p>A response with HTTP status of "400 Bad Request" should be returned to the client application and
     * Authlete recommends `application/json` as the content type although OAuth 2.0 specification does
     * not mention the format of the error response when the redirect URI is not usable.
     * 
     * <p>The value of `responseContent` is a JSON string which describes the error, so it can be used as
     * the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation should generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * Content-Type: application/json
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>The endpoint implementation may return another different response to the client application since
     * "400 Bad Request" is not required by OAuth 2.0.
     * 
     * <p>**LOCATION**
     * 
     * <p>When the value of `action` is `LOCATION`, it means that the request from the client application
     * is invalid but the redirect URI
     * to which the error should be reported has been determined.
     * 
     * <p>A response with HTTP status of "302 Found" must be returned to the client application with `Location`
     * header which has a redirect URI with error parameter.
     * 
     * <p>The value of `responseContent` is a redirect URI with `error` parameter, so it can be used as the
     * value of `Location` header.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 302 Found
     * Location: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORM**
     * 
     * <p>When the value of `action` is `FORM`, it means that the request from the client application is
     * invalid but the redirect URI to which the error should be reported has been determined, and that
     * the authorization request contains `response_mode=form_post` as is defined in [OAuth 2.0 Form Post
     * Response Mode](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html).
     * 
     * <p>The HTTP status of the response returned to the client application should be "200 OK" and the
     * content type should be `text/html;charset=UTF-8`.
     * 
     * <p>The value of `responseContent` is an HTML which can be used as the entity body of the response.
     * 
     * <p>The following illustrates the response which the service implementation must generate and return
     * to the client application.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Content-Type: text/html;charset=UTF-8
     * Cache-Control: no-store
     * Pragma: no-cache
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>**NO_INTERACTION**
     * 
     * <p>When the value of `action` is `NO_INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request without displaying any user interface
     * pages for authentication or consent. This case happens when the authorization request contains
     * `prompt=none`.
     * 
     * <p>The service must follow the steps described below.
     * 
     * <p>[1] END-USER AUTHENTICATION
     * 
     * <p>Check whether an end-user has already logged in. If an end-user has logged in, go to the next step ([MAX_AGE]).
     * Otherwise, call Authlete's `/auth/authorization/fail` API with `reason=NOT_LOGGED_IN` and use the response from
     * the API to generate a response to the client application.
     * 
     * <p>[2] MAX AGE
     * 
     * <p>Get the value of `maxAge` parameter from the `/auth/authorization` API response. The value represents
     * the maximum authentication age which has come from `max_age` request parameter or `defaultMaxAge`
     * configuration parameter of the client application. If the value is `0`, go to the next step ([SUBJECT]).
     * Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Get the time at which the end-user was authenticated. that this value is not managed by Authlete,
     * meaning that it is expected that the service implementation manages the value. If the service implementation
     * does not manage authentication time of end-users, call Authlete's `/auth/authorization/fail` API
     * with `reason=MAX_AGE_NOT_SUPPORTED` and use the API response to generate a response to the client
     * application.
     * 
     * <p>(ii) Add the value of the maximum authentication age (which is represented in seconds) to the authentication
     * time. The calculated value is the expiration time.
     * 
     * <p>(iii) Check whether the calculated value is equal to or greater than the current time. If this condition
     * is satisfied, go to the next step ([SUBJECT]). Otherwise, call Authlete's `/auth/authorization/fail`
     * API with `reason=EXCEEDS_MAX_AGE` and use the API response to generate a response to the client
     * application.
     * 
     * <p>[3] SUBJECT
     * 
     * <p>Get the value of `subject` from the `/auth/authorization` API response. The value represents an
     * end-user who the client application expects to grant authorization. If the value is `null`, go to
     * the next step ([ACRs]). Otherwise, follow the sub steps described below.
     * 
     * <p>(i) Compare the value of the requested subject to the current end-user.
     * 
     * <p>(ii) If they are equal, go to the next step ([ACRs]). If they are not equal, call Authlete's
     * `/auth/authorization/fail` API with `reason=DIFFERENT_SUBJECT` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>[4] ACRs
     * 
     * <p>Get the value of `acrs` from the `/auth/authorization` API response. The value represents a list
     * of ACRs (Authentication Context Class References) and comes from (1) acr claim in `claims` request
     * parameter, (2) `acr_values` request parameter, or (3) `default_acr_values` configuration parameter
     * of the client application.
     * 
     * <p>It is ensured that all the ACRs in acrs are supported by the authorization server implementation.
     * In other words, it is ensured that all the ACRs are listed in `acr_values_supported` configuration
     * parameter of the authorization server.
     * 
     * <p>If the value of ACRs is `null`, go to the next step ([ISSUE]). Otherwise, follow the sub steps
     * described below.
     * 
     * <p>(i) Get the ACR performed for the authentication of the current end-user. Note that this value is
     * managed not by Authlete but by the authorization server implementation. (If the authorization server
     * implementation cannot handle ACRs, it should not have listed ACRs as `acr_values_supported`.)
     * 
     * <p>(ii) Compare the ACR value obtained in the above step to each element in the ACR array (`acrs`)
     * in the listed order.
     * 
     * <p>(iii) If the ACR value was found in the array, (= the ACR performed for the authentication of the
     * current end-user did not match any one of the ACRs requested by the client application), check
     * whether one of the requested ACRs must be satisfied or not using `acrEssential` parameter in the
     * `/auth/authorization` API response. If the value of `acrEssential` parameter is `true`, call Authlete's
     * `/auth/authorization/fail` API with `reason=ACR_NOT_SATISFIED` and use the response from the API
     * to generate a response to the client application. Otherwise, go to the next step ([SCOPES]).
     * 
     * <p>[5] SCOPES
     * 
     * <p>Get the value of `scopes` from the `/auth/authorization` API response. If the array contains a
     * scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), which is only available in a dedicated/onpremise Authlete server (contact sales@authlete.com
     * for details).
     * 
     * <p>[6] DYNAMIC SCOPES
     * 
     * <p>Get the value of `dynamicScopes` from the `/auth/authorization` API response. If the array contains
     * a scope which has not been granted to the client application by the end-user in the past, call
     * Authlete's `/auth/authorization/fail` API with `reason=CONSENT_REQUIRED` and use the response from
     * the API to generate a response to the client application. Otherwise, go to the next step ([RESOURCES]).
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs) but dynamic scopes are not remembered as granted scopes.
     * 
     * <p>[7] RESOURCES
     * 
     * <p>Get the value of `resources` from the `/auth/authorization` API response. The array represents
     * the values of the `resource` request parameters. If you want to reject the request, call Authlete's
     * `/auth/authorization/fail` API with `reason=INVALID_TARGET` and use the response from the API to
     * generate a response to the client application. Otherwise, go to the next step ([ISSUE]).
     * 
     * <p>See "Resource Indicators for OAuth 2.0" for details.
     * 
     * <p>[8] ISSUE
     * 
     * <p>If all the above steps succeeded, the last step is to issue an authorization code, an ID token
     * and/or an access token. (There is a special case, though. In the case of `response_type=none`,
     * nothing is issued.) It can be performed by calling Authlete's `/auth/authorization/issue` API.
     * The API requires the following parameters. Prepare these parameters and call `/auth/authorization/issue`
     * API and use the response to generate a response to the client application.
     * 
     * <p>- &lt;u&gt;`ticket` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents a ticket which is exchanged with tokens at `/auth/authorization/issue`.
     *   Use the value of `ticket` contained in the `/auth/authorization` API response.
     * 
     * <p>- &lt;u&gt;`subject` (required)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the unique identifier of the current end-user. It is often called "user ID"
     *   and it may or may not be visible to the user. In any case, it is a number or a string assigned
     *   to an end-user by the authorization server implementation. Authlete does not care about the format
     *   of the value of subject, but it must consist of only ASCII letters and its length must not exceed 100.
     * 
     * <p>  When the value of `subject` parameter in the /auth/authorization API response is not `null`,
     *   it is necessarily identical to the value of `subject` parameter in the `/auth/authorization/issue`
     *   API request.
     * 
     * <p>  The value of this parameter will be embedded in an ID token as the value of `sub` claim. When
     *   the value of `subject_type` configuration parameter of the client application is `PAIRWISE`,
     *   the value of sub claim is different from the value specified by this parameter, See [8. Subject
     *   Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes) of OpenID
     *   Connect Core 1.0 for details about subject types.
     * 
     * <p>  You can use the `sub` request parameter to adjust the value of the `sub` claim in an ID token.
     *   See the description of the `sub` request parameter for details.
     * 
     * <p>- &lt;u&gt;`authTime` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the time when the end-user authentication occurred. Its value is the
     *   number of seconds from `1970-01-01`. The value of this parameter will be embedded in an ID token
     *   as the value of `auth_time` claim.
     * 
     * <p>- &lt;u&gt;`acr` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents the ACR (Authentication Context Class Reference) which the authentication
     *   of the end-user satisfies. When `acrs` in the `/auth/authorization` API response is a non-empty
     *   array and the value of `acrEssential` is `true`, the value of this parameter must be one of the
     *   array elements. Otherwise, even `null` is allowed. The value of this parameter will be embedded
     *   in an ID token as the value of `acr` claim.
     * 
     * <p>- &lt;u&gt;`claims` (optional)&lt;/u&gt;&lt;br&gt;
     *   This parameter represents claims of the end-user. "Claims" here are pieces of information about
     *   the end-user such as `"name"`, `"email"` and `"birthdate"`. The authorization server implementation
     *   is required to gather claims of the end-user, format the claim values into JSON and set the JSON
     *   string as the value of this parameter.
     * 
     * <p>  The claims which the authorization server implementation is required to gather are listed in
     *   `claims` parameter in the `/auth/authorization` API response.
     * 
     * <p>  For example, if claims parameter lists `"name"`, `"email"` and `"birthdate"`, the value of this
     *   parameter should look like the following.
     * 
     * <p>  ```json
     *   {
     *     "name": "John Smith",
     *     "email": "john@example.com",
     *     "birthdate": "1974-05-06"
     *   }
     *   ```
     * 
     * <p>  `claimsLocales` parameter in the `/auth/authorization` API response lists the end-user's preferred
     *   languages and scripts, ordered by preference. When `claimsLocales` parameter is a non-empty array,
     *   its elements should be taken into account when the authorization server implementation gathers
     *   claim values. Especially, note the excerpt below from [5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
     *   of OpenID Connect Core 1.0.
     * 
     * <p>  &gt; When the OP determines, either through the `claims_locales` parameter, or by other means, that
     *   the End-User and Client are requesting Claims in only one set of languages and scripts, it is
     *   RECOMMENDED that OPs return Claims without language tags when they employ this language and script.
     *   It is also RECOMMENDED that Clients be written in a manner that they can handle and utilize Claims
     *   using language tags.
     * 
     * <p>  If `claims` parameter in the `/auth/authorization` API response is `null` or an empty array,
     *   the value of this parameter should be `null`.
     * 
     * <p>  See [5.1. Standard Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)
     *   of OpenID Connect core 1.0 for claim names and their value formats. Note (1) that the authorization
     *   server implementation support its special claims ([5.1.2. Additional Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims))
     *   and (2) that claim names may be followed by a language tag ([5.2. Claims Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)).
     *   Read the specification of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
     *   for details.
     * 
     * <p>  The claim values in this parameter will be embedded in an ID token.
     * 
     * <p>  Note that `idTokenClaims` parameter is available in the `/auth/authorization` API response.
     *   The parameter has the value of the `"id_token"` property in the `claims` request parameter or
     *   in the `"claims"` property in a request object. The value of this parameter should be considered
     *   when you prepare claim values.
     * 
     * <p>- &lt;u&gt;`properties` (optional)&lt;/u&gt;&lt;br&gt;
     *   Extra properties to associate with an access token and/or an authorization code that may be issued
     *   by this request. Note that `properties` parameter is accepted only when `Content-Type` of the
     *   request is `application/json`, so don't use `application/x-www-form-urlencoded` for details.
     * 
     * <p>- &lt;u&gt;`scopes` (optional)&lt;/u&gt;&lt;br&gt;
     *   Scopes to associate with an access token and/or an authorization code. If this parameter is `null`,
     *   the scopes specified in the original authorization request from the client application are used.
     *   In other cases, including the case of an empty array, the specified scopes will replace the original
     *   scopes contained in the original authorization request.
     * 
     * <p>  Even scopes that are not included in the original authorization request can be specified. However,
     *   as an exception, `openid` scope is ignored on the server side if it is not included in the original
     *   request. It is because the existence of `openid` scope considerably changes the validation steps
     *   and because adding `openid` triggers generation of an ID token (although the client application
     *   has not requested it) and the behavior is a major violation against the specification.
     * 
     * <p>  If you add `offline_access` scope although it is not included in the original request, keep in
     *   mind that the specification requires explicit consent from the user for the scope ([OpenID Connect
     *   Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess)).
     *   When `offline_access` is included in the original request, the current implementation of Authlete's
     *   `/auth/authorization` API checks whether the request has come along with `prompt` request parameter
     *   and the value includes consent. However, note that the implementation of Authlete's `/auth/authorization/issue`
     *   API does not perform such checking if `offline_access` scope is added via this `scopes` parameter.
     * 
     * <p>- &lt;u&gt;`sub` (optional)&lt;/u&gt;&lt;br&gt;
     *   The value of the `sub` claim in an ID token. If the value of this request parameter is not empty,
     *   it is used as the value of the `sub` claim. Otherwise, the value of the `subject` request parameter
     *   is used as the value of the `sub` claim. The main purpose of this parameter is to hide the actual
     *   value of the subject from client applications.
     * 
     * <p>  Note that even if this `sub` parameter is not empty, the value of the subject request parameter
     *   is used as the value of the subject which is associated with the access token.
     * 
     * <p>**INTERACTION**
     * 
     * <p>When the value of `action` is `INTERACTION`, it means that the request from the client application
     * has no problem and requires the service to process the request with user interaction by an HTML form.
     * The purpose of the UI displayed to the end-user is to ask the end-user to grant authorization to
     * the client application. The items described below are some points which the service implementation
     * should take into account when it builds the UI.
     * 
     * <p>[1] DISPLAY MODE
     * 
     * <p>The response from `/auth/authorization` API has `display` parameter. It is one of `PAGE` (default),
     * `POPUP`, `TOUCH` and `WAP` The meanings of the values are described in [3.1.2.1. Authentication
     * Request of OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * Basically, the authorization server implementation should display the UI which is suitable for the
     * display mode, but it is okay for the authorization server implementation to "attempt to detect the
     * capabilities of the User Agent and present an appropriate display".
     * 
     * <p>It is ensured that the value of `display` is one of the supported display modes which are specified
     * by `supportedDisplays` configuration parameter of the service.
     * 
     * <p>[2] UI LOCALE
     * 
     * <p>The response from `/auth/authorization` API has `uiLocales` parameter. It it is not `null`, it lists
     * language tag values (such as `fr-CA`, `ja-JP` and `en`) ordered by preference. The service implementation
     * should display the UI in one of the language listed in the parameter when possible. It is ensured
     * that language tags listed in `uiLocales` are contained in the list of supported UI locales which
     * are specified by `supportedUiLocales` configuration parameter of the service.
     * 
     * <p>[3] CLIENT INFORMATION
     * 
     * <p>The authorization server implementation should show information about the client application to
     * the end-user. The information is embedded in `client` parameter in the response from `/auth/authorization`
     * API.
     * 
     * <p>[4] SCOPES
     * 
     * <p>A client application requires authorization for specific permissions. In OAuth 2.0 specification,
     * "scope" is a technical term which represents a permission. `scopes` parameter in the response
     * from `/auth/authorization` API is a list of scopes requested by the client application. The service
     * implementation should show the end-user the scopes.
     * 
     * <p>The authorization server implementation may choose not to show scopes to which the end-user has
     * given consent in the past. To put it the other way around, the authorization server implementation
     * may show only the scopes to which the end-user has not given consent yet. However, if the value
     * of `prompts` response parameter contains `CONSENT`, the authorization server implementation has
     * to obtain explicit consent from the end-user even if the end-user has given consent to all the
     * requested scopes in the past.
     * 
     * <p>Note that Authlete provides APIs to manage records of granted scopes (`/api/client/granted_scopes/*`
     * APIs), but the APIs work only in the case the Authlete server you use is a dedicated Authlete server
     * (contact sales@authlete.com for details). In other words, the APIs of the shared Authlete server
     * are disabled intentionally (in order to prevent garbage data from being accumulated) and they
     * return 403 Forbidden.
     * 
     * <p>It is ensured that the values in `scopes` parameter are contained in the list of supported scopes
     * which are specified by `supportedScopes` configuration parameter of the service.
     * 
     * <p>[5] DYNAMIC SCOPES
     * 
     * <p>The authorization request may include dynamic scopes. The list of recognized dynamic scopes are
     * accessible by getDynamicScopes() method. See the description of the [DynamicScope](https://authlete.github.io/authlete-java-common/com/authlete/common/dto/DynamicScope.html)
     * class for details about dynamic scopes.
     * 
     * <p>[6] AUTHORIZATION DETAILS
     * 
     * <p>The authorization server implementation should show the end-user "authorization details" if the
     * request includes it. The value of `authorization_details` parameter in the response is the content
     * of the `authorization_details` request parameter.
     * 
     * <p>See "OAuth 2.0 Rich Authorization Requests" for details.
     * 
     * <p>[7] PURPOSE
     * 
     * <p>The authorization server implementation must show the value of the `purpose` request parameter if
     * it supports [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html).
     * See [8. Transaction-specific Purpose](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.8)
     * in the specification for details.
     * 
     * <p>Note that the value of `purpose` response parameter is the value of the purpose request parameter.
     * 
     * <p>[7] END-USER AUTHENTICATION
     * 
     * <p>Necessarily, the end-user must be authenticated (= must login the service) before granting authorization
     * to the client application. Simply put, a login form is expected to be displayed for end-user authentication.
     * The service implementation must follow the steps described below to comply with OpenID Connect.
     * (Or just always show a login form if it's too much of a bother.)
     * 
     * <p>(i) Get the value of `prompts` response parameter. It corresponds to the value of the `prompt`
     * request parameter. Details of the request parameter are described in [3.1.2.1. Authentication
     * Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) of OpenID Connect Core 1.0.
     * 
     * <p>(ii) If the value of `prompts` parameter is `SELECT_ACCOUNT` display a form to let the end-user
     * select on of his/her accounts for login. If `subject` response parameter is not `null`, it is the
     * end-user ID that the client application expects, so the value should be used to determine the value
     * of the login ID. Note that a subject and a login ID are not necessarily equal. If the value of
     * `subject` response parameter is `null`, the value of `loginHint` response parameter should be referred
     * to as a hint to determine the value of the login ID. The value of `loginHint` response parameter
     * is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iii) If the value of `prompts` response parameter contains `LOGIN`, display a form to urge the
     * end-user to login even if the end-user has already logged in. If the value of `subject` response
     * parameter is not `null`, it is the end-user ID that the client application expects, so the value
     * should be used to determine the value of the login ID. Note that a subject and a login ID are not
     * necessarily equal. If the value of `subject` response parameter is `null`, the value of `loginHint`
     * response parameter should be referred to as a hint to determine the value of the login ID. The value
     * of `loginHint` response parameter is simply the value of the `login_hint` request parameter.
     * 
     * <p>(iv) If the value of `prompts` response parameter does not contain `LOGIN`, the authorization server
     * implementation does not have to authenticate the end-user if all the conditions described below
     * are satisfied. If any one of the conditions is not satisfied, show a login form to authenticate
     * the end-user.
     * 
     * <p>- An end-user has already logged in the service.
     * 
     * <p>- The login ID of the current end-user matches the value of `subject` response parameter.
     * This check is required only when the value of `subject` response parameter is a non-null value.
     * 
     * <p>- The max age, which is the number of seconds contained in `maxAge` response parameter,
     * has not passed since the current end-user logged in your service. This check is required only when
     * the value of `maxAge` response parameter is a non-zero value.
     * 
     * <p>- If the authorization server implementation does not manage authentication time of end-users
     * (= if the authorization server implementation cannot know when end-users logged in) and if the
     * value of `maxAge` response parameter is a non-zero value, a login form should be displayed.
     * 
     * <p>- The ACR (Authentication Context Class Reference) of the authentication performed for
     * the current end-user satisfies one of the ACRs listed in `acrs` response parameter. This check is
     * required only when the value of `acrs` response parameter is a non-empty array.
     * 
     * <p>In every case, the end-user authentication must satisfy one of the ACRs listed in `acrs` response
     * parameter when the value of `acrs` response parameter is a non-empty array and `acrEssential`
     * response parameter is `true`.
     * 
     * <p>[9] GRANT/DENY BUTTONS
     * 
     * <p>The end-user is supposed to choose either (1) to grant authorization to the client application or
     * (2) to deny the authorization request. The UI must have UI components to accept the judgment by
     * the user. Usually, a button to grant authorization and a button to deny the request are provided.
     * 
     * <p>When the value of `subject` response parameter is not `null`, the end-user authentication must be
     * performed for the subject, meaning that the authorization server implementation should repeatedly
     * show a login form until the subject is successfully authenticated.
     * 
     * <p>The end-user will choose either (1) to grant authorization to the client application or (2) to
     * deny the authorization request. When the end-user chose to deny the authorization request, call
     * Authlete's `/auth/authorization/fail` API with `reason=DENIED` and use the response from the API
     * to generate a response to the client application.
     * 
     * <p>When the end-user chose to grant authorization to the client application, the authorization server
     * implementation has to issue an authorization code, an ID token, and/or an access token to the client
     * application. (There is a special case. When `response_type=none`, nothing is issued.) Issuing the
     * tokens can be performed by calling Authlete's `/auth/authorization/issue` API. Read [ISSUE] written
     * above in the description for the case of `action=NO_INTERACTION`.
     * &lt;/details&gt;
     * 
     * @param serviceId A service ID.
     * @param requestBody 
     * @param serverURL Overrides the server URL.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public AuthAuthorizationApiFormResponse processForm(
            @Nonnull String serviceId, @Nonnull AuthAuthorizationApiFormRequestBody requestBody,
            @Nullable String serverURL) throws Exception {
        AuthAuthorizationApiFormRequest request = new AuthAuthorizationApiFormRequest(serviceId, requestBody);
        RequestOperation<AuthAuthorizationApiFormRequest, AuthAuthorizationApiFormResponse> operation
              = new AuthAuthorizationApiForm.Sync(sdkConfiguration, serverURL);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Update Ticket Information
     * 
     * @return The call builder
     */
    public PostApiServiceIdAuthAuthorizationTicketUpdateRequestBuilder updateTicket() {
        return new PostApiServiceIdAuthAuthorizationTicketUpdateRequestBuilder(sdkConfiguration);
    }

    /**
     * Update Ticket Information
     * 
     * @param serviceId 
     * @param requestBody 
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public PostApiServiceIdAuthAuthorizationTicketUpdateResponse updateTicket(@Nonnull String serviceId, @Nonnull PostApiServiceIdAuthAuthorizationTicketUpdateRequestBody requestBody) throws Exception {
        return updateTicket(serviceId, requestBody, null);
    }

    /**
     * Update Ticket Information
     * 
     * @param serviceId 
     * @param requestBody 
     * @param serverURL Overrides the server URL.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public PostApiServiceIdAuthAuthorizationTicketUpdateResponse updateTicket(
            @Nonnull String serviceId, @Nonnull PostApiServiceIdAuthAuthorizationTicketUpdateRequestBody requestBody,
            @Nullable String serverURL) throws Exception {
        PostApiServiceIdAuthAuthorizationTicketUpdateRequest request = new PostApiServiceIdAuthAuthorizationTicketUpdateRequest(serviceId, requestBody);
        RequestOperation<PostApiServiceIdAuthAuthorizationTicketUpdateRequest, PostApiServiceIdAuthAuthorizationTicketUpdateResponse> operation
              = new PostApiServiceIdAuthAuthorizationTicketUpdate.Sync(sdkConfiguration, serverURL);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Update Ticket Information
     * 
     * @return The call builder
     */
    public PostApiServiceIdAuthAuthorizationTicketUpdateFormRequestBuilder updateTicketForm() {
        return new PostApiServiceIdAuthAuthorizationTicketUpdateFormRequestBuilder(sdkConfiguration);
    }

    /**
     * Update Ticket Information
     * 
     * @param serviceId 
     * @param requestBody 
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public PostApiServiceIdAuthAuthorizationTicketUpdateFormResponse updateTicketForm(@Nonnull String serviceId, @Nonnull PostApiServiceIdAuthAuthorizationTicketUpdateFormRequestBody requestBody) throws Exception {
        return updateTicketForm(serviceId, requestBody, null);
    }

    /**
     * Update Ticket Information
     * 
     * @param serviceId 
     * @param requestBody 
     * @param serverURL Overrides the server URL.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public PostApiServiceIdAuthAuthorizationTicketUpdateFormResponse updateTicketForm(
            @Nonnull String serviceId, @Nonnull PostApiServiceIdAuthAuthorizationTicketUpdateFormRequestBody requestBody,
            @Nullable String serverURL) throws Exception {
        PostApiServiceIdAuthAuthorizationTicketUpdateFormRequest request = new PostApiServiceIdAuthAuthorizationTicketUpdateFormRequest(serviceId, requestBody);
        RequestOperation<PostApiServiceIdAuthAuthorizationTicketUpdateFormRequest, PostApiServiceIdAuthAuthorizationTicketUpdateFormResponse> operation
              = new PostApiServiceIdAuthAuthorizationTicketUpdateForm.Sync(sdkConfiguration, serverURL);
        return operation.handleResponse(operation.doRequest(request));
    }

}
