/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package org.openapis.openapi.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.annotation.Nullable;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import org.openapis.openapi.utils.Utils;


public class ServiceUpdateApiRequestBody {
    /**
     * The name of this service.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("serviceName")
    private String serviceName;

    /**
     * The issuer identifier of the service.
     * 
     * <p>A URL that starts with  https:// and has no query or fragment component.
     * 
     * <p>The value of this property is used as `iss` claim in an [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)
     * and `issuer` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issuer")
    private String issuer;

    /**
     * The description about the service.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private String description;

    /**
     * Deprecated. Always `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("clientIdAliasEnabled")
    private Boolean clientIdAliasEnabled;

    /**
     * The `metadata` of the service. The content of the returned array depends on contexts.
     * The predefined service metadata is listed in the following table.
     * 
     * <p>  | Key | Description |
     *   | --- | --- |
     *   | `clientCount` | The number of client applications which belong to this service.  |
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private List<ServiceUpdateApiMetadatumRequest> metadata;

    /**
     * A Web API endpoint for user authentication which is to be prepared on the service side.
     * 
     * <p>The endpoint must be implemented if you do not implement the UI at the authorization endpoint
     * but use the one provided by Authlete.
     * 
     * <p>The user authentication at the authorization endpoint provided by Authlete is performed by making
     * a `POST` request to this endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authenticationCallbackEndpoint")
    private String authenticationCallbackEndpoint;

    /**
     * API key for basic authentication at the authentication callback endpoint.
     * 
     * <p>If the value is not empty, Authlete generates Authorization header for Basic authentication when
     * making a request to the authentication callback endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authenticationCallbackApiKey")
    private String authenticationCallbackApiKey;

    /**
     * API secret for `basic` authentication at the authentication callback endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authenticationCallbackApiSecret")
    private String authenticationCallbackApiSecret;

    /**
     * Values of `grant_type` request parameter that the service supports.
     * 
     * <p>The value of this property is used as `grant_types_supported property` in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedGrantTypes")
    private List<ServiceUpdateApiSupportedGrantTypeRequest> supportedGrantTypes;

    /**
     * Values of `response_type` request parameter that
     * the service supports. Valid values are listed in Response Type.
     * 
     * <p>The value of this property is used as `response_types_supported` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedResponseTypes")
    private List<ServiceUpdateApiSupportedResponseTypeRequest> supportedResponseTypes;

    /**
     * The supported data types that can be used as values of the type field in `authorization_details`.
     * 
     * <p>This property corresponds to the `authorization_details_types_supported` metadata. See "OAuth 2.0
     * Rich Authorization Requests" (RAR) for details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedAuthorizationDetailsTypes")
    private List<String> supportedAuthorizationDetailsTypes;

    /**
     * The profiles that this service supports.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedServiceProfiles")
    private List<ServiceUpdateApiSupportedServiceProfileRequest> supportedServiceProfiles;

    /**
     * The flag to indicate whether the `error_description` response parameter is omitted.
     * 
     * <p>According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include
     * the `error_description` response parameter in error responses.
     * 
     * <p>If `true`, Authlete does not embed the `error_description` response parameter in error responses.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("errorDescriptionOmitted")
    private Boolean errorDescriptionOmitted;

    /**
     * The flag to indicate whether the `error_uri` response parameter is omitted.
     * 
     * <p>According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include the `error_uri` response parameter in error responses.
     * 
     * <p>If `true`, Authlete does not embed the
     * `error_uri` response parameter in error responses.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("errorUriOmitted")
    private Boolean errorUriOmitted;

    /**
     * The authorization endpoint of the service.
     * 
     * <p>A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/authorization`.
     * 
     * <p>The value of this property is used as `authorization_endpoint` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorizationEndpoint")
    private String authorizationEndpoint;

    /**
     * The flag to indicate whether the direct authorization endpoint is enabled or not.
     * 
     * <p>The path of the endpoint is `/api/auth/authorization/direct/service-api-key`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("directAuthorizationEndpointEnabled")
    private Boolean directAuthorizationEndpointEnabled;

    /**
     * UI locales that the service supports.
     * 
     * <p>Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646). For example, `en-US` and `ja-JP`.
     * 
     * <p>The value of this property is used as `ui_locales_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedUiLocales")
    private List<String> supportedUiLocales;

    /**
     * Values of `display` request parameter that service supports.
     * 
     * <p>The value of this property is used as `display_values_supported` property in the Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedDisplays")
    private List<ServiceUpdateApiSupportedDisplayRequest> supportedDisplays;

    /**
     * The flag to indicate whether the use of Proof Key for Code Exchange (PKCE) is always required for authorization requests by Authorization Code Flow.
     * 
     * <p>If `true`, `code_challenge` request parameter is always required for authorization requests using Authorization Code Flow.
     * 
     * <p>See [RFC 7636](https://tools.ietf.org/html/rfc7636) (Proof Key for Code Exchange by OAuth Public Clients) for details about `code_challenge` request parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pkceRequired")
    private Boolean pkceRequired;

    /**
     * The flag to indicate whether `S256` is always required as the code challenge method whenever [PKCE (RFC 7636)](https://tools.ietf.org/html/rfc7636) is used.
     * 
     * <p>If this flag is set to `true`, `code_challenge_method=S256` must be included in the authorization request
     * whenever it includes the `code_challenge` request parameter.
     * Neither omission of the `code_challenge_method` request parameter nor use of plain (`code_challenge_method=plain`) is allowed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pkceS256Required")
    private Boolean pkceS256Required;

    /**
     * The duration of authorization response JWTs in seconds.
     * 
     * <p>[Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
     * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
     * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
     * from the authorization endpoint will be packed into a JWT. This property is used to compute the
     * value of the `exp` claim of the JWT.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorizationResponseDuration")
    private Long authorizationResponseDuration;

    /**
     * The [token endpoint](https://tools.ietf.org/html/rfc6749#section-3.2) of the service.
     * 
     * <p>A URL that starts with `https://` and has not fragment component. For example, `https://example.com/auth/token`.
     * 
     * <p>The value of this property is used as `token_endpoint` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tokenEndpoint")
    private String tokenEndpoint;

    /**
     * The flag to indicate whether the direct token endpoint is enabled or not. The path of the endpoint
     * is `/api/auth/token/direct/service-api-key`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("directTokenEndpointEnabled")
    private Boolean directTokenEndpointEnabled;

    /**
     * Client authentication methods supported by the token endpoint of the service.
     * 
     * <p>The value of this property is used as `token_endpoint_auth_methods_supports` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedTokenAuthMethods")
    private List<ServiceUpdateApiSupportedTokenAuthMethodRequest> supportedTokenAuthMethods;

    /**
     * The flag to indicate token requests from public clients without the `client_id` request parameter are allowed when the client can be guessed from `authorization_code` or `refresh_token`.
     * 
     * <p>This flag should not be set unless you have special reasons.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("missingClientIdAllowed")
    private Boolean missingClientIdAllowed;

    /**
     * The [revocation endpoint](https://tools.ietf.org/html/rfc7009) of the service.
     * 
     * <p>A URL that starts with `https://`. For example, `https://example.com/auth/revocation`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("revocationEndpoint")
    private String revocationEndpoint;

    /**
     * The flag to indicate whether the direct revocation endpoint is enabled or not. The URL of the endpoint is `/api/auth/revocation/direct/service-api-key`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("directRevocationEndpointEnabled")
    private Boolean directRevocationEndpointEnabled;

    /**
     * Client authentication methods supported at the revocation endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedRevocationAuthMethods")
    private List<ServiceUpdateApiSupportedRevocationAuthMethodRequest> supportedRevocationAuthMethods;

    /**
     * The URI of the introspection endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("introspectionEndpoint")
    private String introspectionEndpoint;

    /**
     * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path of the endpoint is `/api/auth/userinfo/direct/{serviceApiKey}`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("directIntrospectionEndpointEnabled")
    private Boolean directIntrospectionEndpointEnabled;

    /**
     * Client authentication methods supported at the introspection endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedIntrospectionAuthMethods")
    private List<ServiceUpdateApiSupportedIntrospectionAuthMethodRequest> supportedIntrospectionAuthMethods;

    /**
     * The URI of the pushed authorization request endpoint.
     * 
     * <p>This property corresponds to the `pushed_authorization_request_endpoint` metadata defined in "[5. Authorization Server Metadata](https://tools.ietf.org/html/draft-lodderstedt-oauth-par#section-5)" of OAuth 2.0 Pushed Authorization Requests.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pushedAuthReqEndpoint")
    private String pushedAuthReqEndpoint;

    /**
     * The duration of pushed authorization requests in seconds.
     * 
     * <p>[OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par)
     * defines an endpoint (called "pushed authorization request endpoint") which client applications
     * can register authorization requests into and get corresponding URIs (called "request URIs") from.
     * The issued URIs represent the registered authorization requests. The client applications can use
     * the URIs as the value of the `request_uri` request parameter in an authorization request.
     * 
     * <p>The property represents the duration of registered authorization requests and is used as the value
     * of the `expires_in` parameter in responses from the pushed authorization request endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pushedAuthReqDuration")
    private Long pushedAuthReqDuration;

    /**
     * The flag to indicate whether this service requires that clients use the pushed authorization
     * request endpoint.
     * 
     * <p>This property corresponds to the `require_pushed_authorization_requests` server metadata defined
     * in [OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parRequired")
    private Boolean parRequired;

    /**
     * The flag to indicate whether this service requires that authorization requests always utilize
     * a request object by using either request or `request_uri` request parameter.
     * 
     * <p>If this flag is set to `true` and the value of `traditionalRequestObjectProcessingApplied` is
     * `false`, the value of `require_signed_request_object` server metadata of this service is reported
     * as `true` in the discovery document. The metadata is defined in JAR (JWT Secured Authorization Request).
     * That `require_signed_request_object` is `true` means that authorization requests which don't
     * conform to the JAR specification are rejected.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("requestObjectRequired")
    private Boolean requestObjectRequired;

    /**
     * The flag to indicate whether a request object is processed based on rules defined in
     * [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) or JAR (JWT
     * Secured Authorization Request).
     * 
     * <p>Differences between rules in OpenID Connect Core 1.0 and ones in JAR are as follows.
     *   - JAR requires that a request object be always -signed.
     *   - JAR does not allow request parameters outside a request object to be referred to.
     *   - OIDC Core 1.0 requires that response_type request parameter exist outside a request object even if the request object includes the request parameter.
     *   - OIDC Core 1.0 requires that scope request parameter exist outside a request object if the authorization request is an
     *   - OIDC request even if the request object includes the request parameter.
     * 
     * <p>If this flag is set to `false` and the value of `requestObjectRequired` is `true`, the value of
     * `require_signed_request_object` server metadata of this service
     * is reported as `true` in the discovery document. The metadata is defined in JAR (JWT Secured
     * Authorization Request). That `require_signed_request_object` is `true` means that authorization
     * requests which don't conform to the JAR specification are rejected.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("traditionalRequestObjectProcessingApplied")
    private Boolean traditionalRequestObjectProcessingApplied;

    /**
     * The flag to indicate whether this service validates certificate chains during PKI-based client mutual TLS authentication.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mutualTlsValidatePkiCertChain")
    private Boolean mutualTlsValidatePkiCertChain;

    /**
     * The list of root certificates trusted by this service for PKI-based client mutual TLS authentication.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("trustedRootCertificates")
    private List<String> trustedRootCertificates;

    /**
     * The MTLS endpoint aliases.
     * 
     * <p>This property corresponds to the mtls_endpoint_aliases metadata defined in "5. Metadata for Mutual TLS Endpoint Aliases" of [OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens](https://datatracker.ietf.org/doc/rfc8705/).
     * 
     * <p>The aliases will be embedded in the response from the discovery endpoint like the following.
     * 
     * <p>```json
     * {
     *   ......,
     *   "mtls_endpoint_aliases": {
     *     "token_endpoint":         "https://mtls.example.com/token",
     *     "revocation_endpoint":    "https://mtls.example.com/revo",
     *     "introspection_endpoint": "https://mtls.example.com/introspect"
     *   }
     * }
     * ```
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mtlsEndpointAliases")
    private List<ServiceUpdateApiMtlsEndpointAliasRequest> mtlsEndpointAliases;

    /**
     * The access token type.
     * 
     * <p>This value is used as the value of `token_type` property in access token responses. If this service
     * complies with [RFC 6750](https://tools.ietf.org/html/rfc6750), the value of this property should
     * be `Bearer`.
     * 
     * <p>See [RFC 6749 (OAuth 2.0), 7.1. Access Token Types](https://tools.ietf.org/html/rfc6749#section-7.1) for details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessTokenType")
    private String accessTokenType;

    /**
     * The flag to indicate whether this service supports issuing TLS client certificate bound access tokens.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tlsClientCertificateBoundAccessTokens")
    private Boolean tlsClientCertificateBoundAccessTokens;

    /**
     * The duration of access tokens in seconds. This value is used as the value of `expires_in` property
     * in access token responses. `expires_in` is defined [RFC 6749, 5.1. Successful Response](https://tools.ietf.org/html/rfc6749#section-5.1).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessTokenDuration")
    private Long accessTokenDuration;

    /**
     * The flag to indicate whether the number of access tokens per subject (and per client) is at most one or can be more.
     * 
     * <p>If `true`, an attempt to issue a new access token invalidates existing access tokens that are associated with the same subject and the same client.
     * 
     * <p>Note that, however, attempts by [Client Credentials Flow](https://tools.ietf.org/html/rfc6749#section-4.4) do not invalidate existing access tokens because access tokens issued by Client Credentials Flow are not associated with any end-user's subject. Also note that an attempt by [Refresh Token Flow](https://tools.ietf.org/html/rfc6749#section-6) invalidates the coupled access token only and this invalidation is always performed regardless of whether the value of this setting item is `true` or `false`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("singleAccessTokenPerSubject")
    private Boolean singleAccessTokenPerSubject;

    /**
     * The signature algorithm for JWT. This value is represented on 'alg' attribute
     * of the header of JWT.
     * 
     * <p>it's semantics depends upon where is this defined, for instance:
     *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
     *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
     *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessTokenSignAlg")
    private ServiceUpdateApiAccessTokenSignAlgRequest accessTokenSignAlg;

    /**
     * The key ID to identify a JWK used for signing access tokens.
     * 
     * <p>A JWK Set can be registered as a property of a service. A JWK Set can contain 0 or more JWKs.
     * Authlete Server has to pick up one JWK for signing from the JWK Set when it generates a JWT-based
     * access token. Authlete Server searches the registered JWK Set for a JWK which satisfies conditions
     * for access token signature. If the number of JWK candidates which satisfy the conditions is 1,
     * there is no problem. On the other hand, if there exist multiple candidates, a Key ID is needed
     * to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessTokenSignatureKeyId")
    private String accessTokenSignatureKeyId;

    /**
     * The duration of refresh tokens in seconds. The related specifications have no requirements on refresh token duration, but Authlete sets expiration for refresh tokens.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("refreshTokenDuration")
    private Long refreshTokenDuration;

    /**
     * The flag to indicate whether the remaining duration of the used refresh token is taken over to
     * the newly issued refresh token.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("refreshTokenDurationKept")
    private Boolean refreshTokenDurationKept;

    /**
     * The flag which indicates whether duration of refresh tokens are reset when they are used even
     * if the `refreshTokenKept` property of this service set to is `true` (= even if "Refresh Token
     * Continuous Use" is "Kept").
     * 
     * <p>This flag has no effect when the `refreshTokenKept` property is set to `false`. In other words,
     * if this service issues a new refresh token on every refresh token request, the refresh token
     * will have fresh duration (unless `refreshTokenDurationKept` is set to `true`) and this
     * `refreshTokenDurationReset` property is not referenced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("refreshTokenDurationReset")
    private Boolean refreshTokenDurationReset;

    /**
     * The flag to indicate whether a refresh token remains unchanged or gets renewed after its use.
     * 
     * <p>If `true`, a refresh token used to get a new access token remains valid after its use. Otherwise, if `false`, a refresh token is invalidated after its use and a new refresh token is issued.
     * 
     * <p>See [RFC 6749 6. Refreshing an Access Token](https://tools.ietf.org/html/rfc6749#section-6), as to how to get a new access token using a refresh token.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("refreshTokenKept")
    private Boolean refreshTokenKept;

    /**
     * Scopes supported by the service.
     * 
     * <p>Authlete strongly recommends that the service register at least the following scopes.
     * 
     * <p>| Name | Description |
     * | --- | --- |
     * | openid | A permission to get an ID token of an end-user. The `openid` scope appears in [OpenID Connect Core 1.0, 3.1.2.1. Authentication Request, scope](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest). Without this scope, Authlete does not allow `response_type` request parameter to have values other than code and token. |
     * | profile | A permission to get information about `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale` and `updated_at` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
     * | email | A permission to get information about `email` and `email_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
     * | address | A permission to get information about address from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) and [5.1.1. Address Claim](https://openid.net/specs/openid-connect-core-1_0.html#AddressClaim) for details. |
     * | phone | A permission to get information about `phone_number` and `phone_number_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
     * | offline_access | A permission to get information from the user info endpoint even when the end-user is not present. See [OpenID Connect Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess) for details. |
     * 
     * <p>The value of this property is used as `scopes_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedScopes")
    private List<ServiceUpdateApiSupportedScopeRequest> supportedScopes;

    /**
     * The flag to indicate whether requests that request no scope are rejected or not.
     * 
     * <p>When a request has no explicit `scope` parameter and the service's pre-defined default scope set is empty,
     * the authorization server regards the request requests no scope. When this flag is set to `true`,
     * requests that request no scope are rejected.
     * 
     * <p>The requirement below excerpted from [RFC 6749 Section 3.3](https://tools.ietf.org/html/rfc6749#section-3.3)
     * does not explicitly mention the case where the default scope set is empty.
     * 
     * <p>&gt; If the client omits the scope parameter when requesting authorization, the authorization server
     * MUST either process the request using a pre-defined default value or fail the request indicating an invalid scope.
     * 
     * <p>However, if you interpret *"the default scope set exists but is empty"* as *"the default scope set does not exist"*
     * and want to strictly conform to the requirement above, this flag has to be `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("scopeRequired")
    private Boolean scopeRequired;

    /**
     * 'The duration of [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)s
     * in seconds. This value is used to calculate the value of `exp` claim in an ID token.'
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("idTokenDuration")
    private Long idTokenDuration;

    /**
     * The allowable clock skew between the server and clients in seconds.
     * 
     * <p>The clock skew is taken into consideration when time-related claims in a JWT (e.g. `exp`, `iat`, `nbf`) are verified.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowableClockSkew")
    private Integer allowableClockSkew;

    /**
     * Claim types supported by the service. Valid values are listed in Claim Type. Note that Authlete
     * currently doesn't provide any API to help implementations for `AGGREGATED` and `DISTRIBUTED`.
     * 
     * <p>The value of this property is used as `claim_types_supported` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedClaimTypes")
    private List<ServiceUpdateApiSupportedClaimTypeRequest> supportedClaimTypes;

    /**
     * Claim locales that the service supports. Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646).
     * For example, `en-US` and `ja-JP`. See [OpenID Connect Core 1.0, 5.2. Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
     * for details.
     * 
     * <p>The value of this property is used as `claims_locales_supported` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedClaimLocales")
    private List<String> supportedClaimLocales;

    /**
     * Claim names that the service supports. The standard claim names listed in [OpenID Connect Core 1.0,
     * 5.1. Standard Claim](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) should
     * be supported. The following is the list of standard claims.
     * 
     * <p>- `sub`
     * - `name`
     * - `given_name`
     * - `family_name`
     * - `middle_name`
     * - `nickname`
     * - `preferred_username`
     * - `profile`
     * - `picture`
     * - `website`
     * - `email`
     * - `email_verified`
     * - `gender`
     * - `birthdate`
     * - `zoneinfo`
     * - `locale`
     * - `phone_number`
     * - `phone_number_verified`
     * - `address`
     * - `updated_at`
     * 
     * <p>The value of this property is used as `claims_supported` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     * 
     * <p>The service may support its original claim names. See [OpenID Connect Core 1.0, 5.1.2. Additional
     * Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedClaims")
    private List<String> supportedClaims;

    /**
     * The flag indicating whether claims specified by shortcut scopes (e.g. `profile`) are included
     * in the issued ID token only when no access token is issued.
     * 
     * <p>To strictly conform to the description below excerpted from [OpenID Connect Core 1.0 Section
     * 5.4](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims), this flag has to be `true`.
     * 
     * <p>&gt; The Claims requested by the profile, email, address, and phone scope values are returned from
     * the UserInfo Endpoint, as described in Section 5.3.2, when a response_type value is used that
     * results in an Access Token being issued. However, when no Access Token is issued (which is the
     * case for the response_type value id_token), the resulting Claims are returned in the ID Token.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("claimShortcutRestrictive")
    private Boolean claimShortcutRestrictive;

    /**
     * The URL of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document. For
     * example, `http://example.com/auth/jwks`.
     * 
     * <p>Client applications accesses this URL (1) to get the public key of the service to validate the
     * signature of an ID token issued by the service and (2) to get the public key of the service to
     * encrypt an request object of the client application. See [OpenID Connect Core 1.0, 10. Signatures
     * and Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
     * 
     * <p>The value of this property is used as `jwks_uri` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("jwksUri")
    private String jwksUri;

    /**
     * 'The flag to indicate whether the direct jwks endpoint is enabled or not. The path of the endpoint
     * is `/api/service/jwks/get/direct/service-api-key`. '
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("directJwksEndpointEnabled")
    private Boolean directJwksEndpointEnabled;

    /**
     * The content of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document.
     * 
     * <p>If this property is not `null` in a `/service/create` request or a `/service/update` request,
     * Authlete hosts the content in the database. This property must not be `null` and must contain
     * pairs of public/private keys if the service wants to support asymmetric signatures for ID tokens
     * and asymmetric encryption for request objects. See [OpenID Connect Core 1.0, 10. Signatures and
     * Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("jwks")
    private String jwks;

    /**
     * The key ID to identify a JWK used for ID token signature using an asymmetric key.
     * 
     * <p>A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
     * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
     * to pick up one JWK for signature from the JWK Set when it generates an ID token and signature
     * using an asymmetric key is required. Authlete Server searches the registered JWK Set for a JWK
     * which satisfies conditions for ID token signature. If the number of JWK candidates which satisfy
     * the conditions is 1, there is no problem. On the other hand, if there exist multiple candidates,
     * a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5) is needed to be specified so that
     * Authlete Server can pick up one JWK from among the JWK candidates.
     * 
     * <p>This `idTokenSignatureKeyId` property exists for the purpose described above. For key rotation
     * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
     * this mechanism is needed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("idTokenSignatureKeyId")
    private String idTokenSignatureKeyId;

    /**
     * The key ID to identify a JWK used for user info signature using an asymmetric key.
     * 
     * <p>A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
     * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
     * to pick up one JWK for signature from the JWK Set when it is required to sign user info (which
     * is returned from [userinfo endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo))
     * using an asymmetric key. Authlete Server searches the registered JWK Set for a JWK which satisfies
     * conditions for user info signature. If the number of JWK candidates which satisfy the conditions
     * is 1, there is no problem. On the other hand, if there exist multiple candidates, a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5)
     * is needed to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
     * 
     * <p>This `userInfoSignatureKeyId` property exists for the purpose described above. For key rotation
     * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
     * this mechanism is needed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userInfoSignatureKeyId")
    private String userInfoSignatureKeyId;

    /**
     * The key ID to identify a JWK used for signing authorization responses using an asymmetric key.
     * 
     * <p>[Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
     * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
     * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
     * from the authorization endpoint will be packed into a JWT. This property is used to compute the
     * value of the `exp` claim of the JWT.
     * 
     * <p>Authlete Server searches the JWK Set for a JWK which satisfies conditions for authorization response
     * signature. If the number of JWK candidates which satisfy the conditions is 1, there is no problem.
     * On the other hand, if there exist multiple candidates, a Key ID is needed to be specified so that
     * Authlete Server can pick up one JWK from among the JWK candidates. This property exists to specify
     * the key ID.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorizationSignatureKeyId")
    private String authorizationSignatureKeyId;

    /**
     * The [user info endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo) of the
     * service. A URL that starts with `https://`. For example, `https://example.com/auth/userinfo`.
     * 
     * <p>The value of this property is used as `userinfo_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userInfoEndpoint")
    private String userInfoEndpoint;

    /**
     * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path
     * of the endpoint is `/api/auth/userinfo/direct/service-api-key`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("directUserInfoEndpointEnabled")
    private Boolean directUserInfoEndpointEnabled;

    /**
     * The boolean flag which indicates whether the [OAuth 2.0 Dynamic Client Registration Protocol](https://tools.ietf.org/html/rfc7591)
     * is supported.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dynamicRegistrationSupported")
    private Boolean dynamicRegistrationSupported;

    /**
     * The [registration endpoint](http://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration)
     * of the service. A URL that starts with `https://`. For example, `https://example.com/auth/registration`.
     * 
     * <p>The value of this property is used as `registration_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("registrationEndpoint")
    private String registrationEndpoint;

    /**
     * The URI of the registration management endpoint. If dynamic client registration is supported,
     * and this is set, this URI will be used as the basis of the client's management endpoint by appending
     * `/clientid}/` to it as a path element. If this is unset, the value of `registrationEndpoint` will
     * be used as the URI base instead.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("registrationManagementEndpoint")
    private String registrationManagementEndpoint;

    /**
     * The URL of the "Policy" of the service.
     * 
     * <p>The value of this property is used as `op_policy_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("policyUri")
    private String policyUri;

    /**
     * The URL of the "Terms Of Service" of the service.
     * 
     * <p>The value of this property is used as `op_tos_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tosUri")
    private String tosUri;

    /**
     * The URL of a page where documents for developers can be found.
     * 
     * <p>The value of this property is used as `service_documentation` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("serviceDocumentation")
    private String serviceDocumentation;

    /**
     * The URI of backchannel authentication endpoint, which is defined in the specification of [CIBA
     * (Client Initiated Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backchannelAuthenticationEndpoint")
    private String backchannelAuthenticationEndpoint;

    /**
     * The supported backchannel token delivery modes. This property corresponds to the `backchannel_token_delivery_modes_supported`
     * metadata.
     * 
     * <p>Backchannel token delivery modes are defined in the specification of [CIBA (Client Initiated
     * Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedBackchannelTokenDeliveryModes")
    private List<ServiceUpdateApiSupportedBackchannelTokenDeliveryModeRequest> supportedBackchannelTokenDeliveryModes;

    /**
     * The duration of backchannel authentication request IDs issued from the backchannel authentication
     * endpoint in seconds. This is used as the value of the `expires_in` property in responses from
     * the backchannel authentication endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backchannelAuthReqIdDuration")
    private Integer backchannelAuthReqIdDuration;

    /**
     * The minimum interval between polling requests to the token endpoint from client applications in
     * seconds. This is used as the value of the `interval` property in responses from the backchannel
     * authentication endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backchannelPollingInterval")
    private Integer backchannelPollingInterval;

    /**
     * The boolean flag which indicates whether the `user_code` request parameter is supported at the
     * backchannel authentication endpoint. This property corresponds to the `backchannel_user_code_parameter_supported`
     * metadata.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backchannelUserCodeParameterSupported")
    private Boolean backchannelUserCodeParameterSupported;

    /**
     * The flag to indicate whether the `binding_message` request parameter is always required whenever
     * a backchannel authentication request is judged as a request for Financial-grade API.
     * 
     * <p>The FAPI-CIBA profile requires that the authorization server _"shall ensure unique authorization
     * context exists in the authorization request or require a `binding_message` in the authorization
     * request"_ (FAPI-CIBA, 5.2.2, 2). The simplest way to fulfill this requirement is to set this property
     * to `true`.
     * 
     * <p>If this property is set to `false`, the `binding_message` request parameter remains optional
     * even in FAPI context, but in exchange, your authorization server must implement a custom mechanism
     * that ensures each backchannel authentication request has unique context.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backchannelBindingMessageRequiredInFapi")
    private Boolean backchannelBindingMessageRequiredInFapi;

    /**
     * The URI of the device authorization endpoint.
     * 
     * <p>Device authorization endpoint is defined in the specification of OAuth 2.0 Device Authorization Grant.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("deviceAuthorizationEndpoint")
    private String deviceAuthorizationEndpoint;

    /**
     * The verification URI for the device flow. This URI is used as the value of the `verification_uri`
     * parameter in responses from the device authorization endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("deviceVerificationUri")
    private String deviceVerificationUri;

    /**
     * The verification URI for the device flow with a placeholder for a user code. This URI is used
     * to build the value of the `verification_uri_complete` parameter in responses from the device
     * authorization endpoint.
     * 
     * <p>It is expected that the URI contains a fixed string `USER_CODE` somewhere as a placeholder for
     * a user code. For example, like the following.
     * 
     * <p>`https://example.com/device?user\_code=USER\_CODE`
     * 
     * <p>The fixed string is replaced with an actual user code when Authlete builds a verification URI
     * with a user code for the `verification_uri_complete` parameter.
     * 
     * <p>If this URI is not set, the `verification_uri_complete` parameter won't appear in device authorization
     * responses.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("deviceVerificationUriComplete")
    private String deviceVerificationUriComplete;

    /**
     * The duration of device verification codes and end-user verification codes issued from the device
     * authorization endpoint in seconds. This is used as the value of the `expires_in` property in responses
     * from the device authorization endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("deviceFlowCodeDuration")
    private Integer deviceFlowCodeDuration;

    /**
     * The minimum interval between polling requests to the token endpoint from client applications in
     * seconds in device flow. This is used as the value of the `interval` property in responses from
     * the device authorization endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("deviceFlowPollingInterval")
    private Integer deviceFlowPollingInterval;

    /**
     * The character set for end-user verification codes (`user_code`) for Device Flow.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userCodeCharset")
    private ServiceUpdateApiUserCodeCharsetRequest userCodeCharset;

    /**
     * The length of end-user verification codes (`user_code`) for Device Flow.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userCodeLength")
    private Integer userCodeLength;

    /**
     * Trust frameworks supported by this service. This corresponds to the `trust_frameworks_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedTrustFrameworks")
    private List<String> supportedTrustFrameworks;

    /**
     * Evidence supported by this service. This corresponds to the `evidence_supported` [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedEvidence")
    private List<String> supportedEvidence;

    /**
     * Identity documents supported by this service. This corresponds to the `id_documents_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedIdentityDocuments")
    private List<String> supportedIdentityDocuments;

    /**
     * Verification methods supported by this service. This corresponds to the `id_documents_verification_methods_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedVerificationMethods")
    private List<String> supportedVerificationMethods;

    /**
     * Verified claims supported by this service. This corresponds to the `claims_in_verified_claims_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedVerifiedClaims")
    private List<String> supportedVerifiedClaims;

    /**
     * OIDC4IDA / verifiedClaimsValidationSchemaSet
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("verifiedClaimsValidationSchemaSet")
    private ServiceUpdateApiVerifiedClaimsValidationSchemaSetRequest verifiedClaimsValidationSchemaSet;

    /**
     * The attributes of this service.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("attributes")
    private List<ServiceUpdateApiAttributeRequest> attributes;

    /**
     * The flag indicating whether the nbf claim in the request object is optional even when the authorization
     * request is regarded as a FAPI-Part2 request.
     * 
     * <p>The final version of Financial-grade API was approved in January, 2021. The Part 2 of the final
     * version has new requirements on lifetime of request objects. They require that request objects
     * contain an `nbf` claim and the lifetime computed by `exp` - `nbf` be no longer than 60 minutes.
     * 
     * <p>Therefore, when an authorization request is regarded as a FAPI-Part2 request, the request object
     * used in the authorization request must contain an nbf claim. Otherwise, the authorization server
     * rejects the authorization request.
     * 
     * <p>When this flag is `true`, the `nbf` claim is treated as an optional claim even when the authorization
     * request is regarded as a FAPI-Part2 request. That is, the authorization server does not perform
     * the validation on lifetime of the request object.
     * 
     * <p>Skipping the validation is a violation of the FAPI specification. The reason why this flag has
     * been prepared nevertheless is that the new requirements (which do not exist in the Implementer's
     * Draft 2 released in October, 2018) have big impacts on deployed implementations of client
     * applications and Authlete thinks there should be a mechanism whereby to make the migration
     * from ID2 to Final smooth without breaking live systems.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nbfOptional")
    private Boolean nbfOptional;

    /**
     * The flag indicating whether generation of the iss response parameter is suppressed.
     * 
     * <p>"OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response" has defined a new
     * authorization response parameter, `iss`, as a countermeasure for a certain type of mix-up attacks.
     * 
     * <p>The specification requires that the `iss` response parameter always be included in authorization
     * responses unless JARM (JWT Secured Authorization Response Mode) is used.
     * 
     * <p>When this flag is `true`, the authorization server does not include the `iss` response parameter
     * in authorization responses. By turning this flag on and off, developers of client applications
     * can experiment the mix-up attack and the effect of the `iss` response parameter.
     * 
     * <p>Note that this flag should not be `true` in production environment unless there are special
     * reasons for it.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issSuppressed")
    private Boolean issSuppressed;

    /**
     * custom client metadata supported by this service.
     * 
     * <p>Standard specifications define client metadata as necessary. The following are such examples.
     * 
     * <p>* [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
     * * [RFC 7591 OAuth 2.0 Dynamic Client Registration Protocol](https://www.rfc-editor.org/rfc/rfc7591.html)
     * * [RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens](https://www.rfc-editor.org/rfc/rfc8705.html)
     * * [OpenID Connect Client-Initiated Backchannel Authentication Flow - Core 1.0](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html)
     * * [The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-jwsreq/)
     * * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
     * * [OAuth 2.0 Pushed Authorization Requests (PAR)](https://datatracker.ietf.org/doc/rfc9126/)
     * * [OAuth 2.0 Rich Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/)
     * 
     * <p>Standard client metadata included in Client Registration Request and Client Update Request (cf.
     * [OIDC DynReg](https://openid.net/specs/openid-connect-registration-1_0.html), [RFC 7591](https://www.rfc-editor.org/rfc/rfc7591.html)
     * and [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)) are, if supported by Authlete, stored
     * into Authlete database. On the other hand, unrecognized client metadata are discarded.
     * 
     * <p>By listing up custom client metadata in advance by using this property (`supportedCustomClientMetadata`),
     * Authlete can recognize them and stores their values into the database. The stored custom client
     * metadata values can be referenced by `customMetadata`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedCustomClientMetadata")
    private List<String> supportedCustomClientMetadata;

    /**
     * The flag indicating whether the expiration date of an access token never exceeds that of the
     * corresponding refresh token.
     * 
     * <p>When a new access token is issued by a refresh token request (= a token request with `grant_type=refresh_token`),
     * the expiration date of the access token may exceed the expiration date of the corresponding
     * refresh token. This behavior itself is not wrong and may happen when `refreshTokenKept` is
     * `true` and/or when `refreshTokenDurationKept` is `true`.
     * 
     * <p>When this flag is `true`, the expiration date of an access token never exceeds that of the corresponding
     * refresh token regardless of the calculated duration based on other settings such as `accessTokenDuration`,
     * `accessTokenDuration` in `extension` and `access_token.duration` scope attribute.
     * 
     * <p>It is technically possible to set a value which is bigger than the duration of refresh tokens
     * as the duration of access tokens although it is strange. In the case, the duration of an access
     * token becomes longer than the duration of the refresh token which is issued together with the
     * access token. Even if the duration values are configured so, if this flag is `true`, the expiration
     * date of the access token does not exceed that of the refresh token. That is, the duration of
     * the access token will be shortened, and as a result, the access token and the refresh token
     * will have the same expiration date.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tokenExpirationLinked")
    private Boolean tokenExpirationLinked;

    /**
     * The flag indicating whether encryption of request object is required when the request object
     * is passed through the front channel.
     * 
     * <p>This flag does not affect the processing of request objects at the Pushed Authorization Request
     * Endpoint, which is defined in [OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/).
     * Unecrypted request objects are accepted at the endpoint even if this flag is `true`.
     * 
     * <p>This flag does not indicate whether a request object is always required. There is a different
     * flag, `requestObjectRequired`, for the purpose. See the description of `requestObjectRequired`
     * for details.
     * 
     * <p>Even if this flag is `false`, encryption of request object is required if the `frontChannelRequestObjectEncryptionRequired`
     * flag of the client is `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("frontChannelRequestObjectEncryptionRequired")
    private Boolean frontChannelRequestObjectEncryptionRequired;

    /**
     * The flag indicating whether the JWE alg of encrypted request object must match the `request_object_encryption_alg`
     * client metadata of the client that has sent the request object.
     * 
     * <p>The request_object_encryption_alg client metadata itself is defined in [OpenID Connect Dynamic
     * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
     * 
     * <p>&gt; request_object_encryption_alg
     * &gt;
     * &gt; OPTIONAL. JWE [JWE] alg algorithm [JWA] the RP is declaring that it may use for encrypting
     * Request Objects sent to the OP. This parameter SHOULD be included when symmetric encryption
     * will be used, since this signals to the OP that a client_secret value needs to be returned
     * from which the symmetric key will be derived, that might not otherwise be returned. The RP
     * MAY still use other supported encryption algorithms or send unencrypted Request Objects, even
     * when this parameter is present. If both signing and encryption are requested, the Request Object
     * will be signed then encrypted, with the result being a Nested JWT, as defined in [JWT]. The
     * default, if omitted, is that the RP is not declaring whether it might encrypt any Request Objects.
     * 
     * <p>The point here is "The RP MAY still use other supported encryption algorithms or send unencrypted
     * Request Objects, even when this parameter is present."
     * 
     * <p>The Client's property that represents the client metadata is `requestEncryptionAlg`. See the
     * description of `requestEncryptionAlg` for details.
     * 
     * <p>Even if this flag is `false`, the match is required if the `requestObjectEncryptionAlgMatchRequired`
     * flag of the client is `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("requestObjectEncryptionAlgMatchRequired")
    private Boolean requestObjectEncryptionAlgMatchRequired;

    /**
     * The flag indicating whether the JWE `enc` of encrypted request object must match the `request_object_encryption_enc`
     * client metadata of the client that has sent the request object.
     * 
     * <p>The `request_object_encryption_enc` client metadata itself is defined in [OpenID Connect Dynamic
     * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
     * 
     * <p>&gt; request_object_encryption_enc
     * &gt;
     * &gt; OPTIONAL. JWE enc algorithm [JWA] the RP is declaring that it may use for encrypting Request
     * Objects sent to the OP. If request_object_encryption_alg is specified, the default for this
     * value is A128CBC-HS256. When request_object_encryption_enc is included, request_object_encryption_alg
     * MUST also be provided.
     * 
     * <p>The Client's property that represents the client metadata is `requestEncryptionEnc`. See the
     * description of `requestEncryptionEnc` for details.
     * 
     * <p>Even if this flag is false, the match is required if the `requestObjectEncryptionEncMatchRequired`
     * flag is `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("requestObjectEncryptionEncMatchRequired")
    private Boolean requestObjectEncryptionEncMatchRequired;

    /**
     * The flag indicating whether HSM (Hardware Security Module) support is enabled for this service.
     * 
     * <p>When this flag is `false`, keys managed in HSMs are not used even if they exist. In addition,
     * `/api/hsk/*` APIs reject all requests.
     * 
     * <p>Even if this flag is `true`, HSM-related features do not work if the configuration of the Authlete
     * server you are using does not support HSM.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hsmEnabled")
    private Boolean hsmEnabled;

    /**
     * The information about keys managed on HSMs (Hardware Security Modules).
     * 
     * <p>This `hsks` property is output only, meaning that `hsks` in requests to `/api/service/create`
     * API and `/api/service/update` API do not have any effect. The contents of this property is controlled
     * only by `/api/hsk/*` APIs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hsks")
    private List<ServiceUpdateApiHskRequest> hsks;

    /**
     * The URL of the grant management endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grantManagementEndpoint")
    private String grantManagementEndpoint;

    /**
     * The flag indicating whether every authorization request (and any request serving as an authorization
     * request such as CIBA backchannel authentication request and device authorization request) must
     * include the `grant_management_action` request parameter.
     * 
     * <p>This property corresponds to the `grant_management_action_required` server metadata defined
     * in [Grant Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html).
     * 
     * <p>Note that setting true to this property will result in blocking all public clients because
     * the specification requires that grant management be usable only by confidential clients for
     * security reasons.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grantManagementActionRequired")
    private Boolean grantManagementActionRequired;

    /**
     * The flag indicating whether Authlete's `/api/client/registration` API uses `UNAUTHORIZED` as
     * a value of the `action` response parameter when appropriate.
     * 
     * <p>The `UNAUTHORIZED` enum value was initially not defined as a possible value of the `action`
     * parameter in an `/api/client/registration` API response. This means that implementations of
     * client `configuration` endpoint were not able to conform to [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)
     * strictly.
     * 
     * <p>For backward compatibility (to avoid breaking running systems), Authlete's `/api/client/registration`
     * API does not return the `UNAUTHORIZED` enum value if this flag is not turned on.
     * 
     * <p>The steps an existing implementation of client configuration endpoint has to do in order to
     * conform to the requirement related to "401 Unauthorized" are as follows.
     * 
     * <p>1. Update the Authlete library (e.g. authlete-java-common) your system is using.
     * 2. Update your implementation of client configuration endpoint so that it can handle the
     * `UNAUTHORIZED` action.
     * 3. Turn on this `unauthorizedOnClientConfigSupported` flag.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("unauthorizedOnClientConfigSupported")
    private Boolean unauthorizedOnClientConfigSupported;

    /**
     * The flag indicating whether the `scope` request parameter in dynamic client registration and
     * update requests (RFC 7591 and RFC 7592) is used as scopes that the client can request.
     * 
     * <p>Limiting the range of scopes that a client can request is achieved by listing scopes in the
     * `client.extension.requestableScopes` property and setting the `client.extension.requestableScopesEnabled`
     * property to `true`. This feature is called "requestable scopes".
     * 
     * <p>This property affects behaviors of `/api/client/registration` and other family APIs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dcrScopeUsedAsRequestable")
    private Boolean dcrScopeUsedAsRequestable;

    /**
     * The endpoint for clients ending the sessions.
     * 
     * <p>A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/endSession`.
     * 
     * <p>The value of this property is used as `end_session_endpoint` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("endSessionEndpoint")
    private String endSessionEndpoint;

    /**
     * The flag indicating whether the port number component of redirection URIs can be variable when
     * the host component indicates loopback.
     * 
     * <p>When this flag is `true`, if the host component of a redirection URI specified in an authorization
     * request indicates loopback (to be precise, when the host component is localhost, `127.0.0.1`
     * or `::1`), the port number component is ignored when the specified redirection URI is compared
     * to pre-registered ones. This behavior is described in [7.3. Loopback Interface Redirection](
     * https://www.rfc-editor.org/rfc/rfc8252.html#section-7.3) of [RFC 8252 OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8252.html)
     * for Native Apps.
     * 
     * <p>[3.1.2.3. Dynamic Configuration](https://www.rfc-editor.org/rfc/rfc6749.html#section-3.1.2.3)
     * of [RFC 6749](https://www.rfc-editor.org/rfc/rfc6749.html) states _"If the client registration
     * included the full redirection URI, the authorization server MUST compare the two URIs using
     * simple string comparison as defined in [RFC3986] Section 6.2.1."_ Also, the description of
     * `redirect_uri` in [3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest)
     * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) states
     * _"This URI MUST exactly match one of the Redirection URI values for the Client pre-registered
     * at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [RFC3986]
     * (**Simple String Comparison**)."_ These "Simple String Comparison" requirements are preceded
     * by this flag. That is, even when the conditions described in RFC 6749 and OpenID Connect Core 1.0
     * are satisfied, the port number component of loopback redirection URIs can be variable when this
     * flag is `true`.
     * 
     * <p>[8.3. Loopback Redirect Considerations](https://www.rfc-editor.org/rfc/rfc8252.html#section-8.3)
     * of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) states as follows.
     * 
     * <p>&gt; While redirect URIs using localhost (i.e., `"http://localhost:{port}/{path}"`) function
     * similarly to loopback IP redirects described in Section 7.3, the use of localhost is NOT RECOMMENDED.
     * Specifying a redirect URI with the loopback IP literal rather than localhost avoids inadvertently
     * listening on network interfaces other than the loopback interface. It is also less susceptible
     * to client-side firewalls and misconfigured host name resolution on the user's device.
     * 
     * <p>However, Authlete allows the port number component to be variable in the case of `localhost`,
     * too. It is left to client applications whether they use `localhost` or a literal loopback IP
     * address (`127.0.0.1` for IPv4 or `::1` for IPv6).
     * 
     * <p>Section 7.3 and Section 8.3 of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) state
     * that loopback redirection URIs use the `"http"` scheme, but Authlete allows the port number
     * component to be variable in other cases (e.g. in the case of the `"https"` scheme), too.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("loopbackRedirectionUriVariable")
    private Boolean loopbackRedirectionUriVariable;

    /**
     * The flag indicating whether Authlete checks whether the `aud` claim of request objects matches
     * the issuer identifier of this service.
     * 
     * <p>[Section 6.1. Passing a Request Object by Value](https://openid.net/specs/openid-connect-core-1_0.html#JWTRequests)
     * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) has the following
     * statement.
     * 
     * <p>&gt; The `aud` value SHOULD be or include the OP's Issuer Identifier URL.
     * 
     * <p>Likewise, [Section 4. Request Object](https://www.rfc-editor.org/rfc/rfc9101.html#section-4) of
     * [RFC 9101](https://www.rfc-editor.org/rfc/rfc9101.html) (The OAuth 2.0 Authorization Framework:
     * JWT-Secured Authorization Request (JAR)) has the following statement.
     * 
     * <p>&gt; The value of aud should be the value of the authorization server (AS) issuer, as defined in
     * [RFC 8414](https://www.rfc-editor.org/rfc/rfc8414.html).
     * 
     * <p>As excerpted above, validation on the `aud` claim of request objects is optional. However, if
     * this flag is turned on, Authlete checks whether the `aud` claim of request objects matches the issuer
     * identifier of this service and raises an error if they are different.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("requestObjectAudienceChecked")
    private Boolean requestObjectAudienceChecked;

    /**
     * The flag indicating whether Authlete generates access tokens for
     * external attachments and embeds them in ID tokens and userinfo
     * responses.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessTokenForExternalAttachmentEmbedded")
    private Boolean accessTokenForExternalAttachmentEmbedded;

    /**
     * Identifiers of entities that can issue entity statements for this
     * service. This property corresponds to the `authority_hints`
     * property that appears in a self-signed entity statement that is
     * defined in OpenID Connect Federation 1.0.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorityHints")
    private List<String> authorityHints;

    /**
     * flag indicating whether this service supports OpenID Connect Federation 1
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("federationEnabled")
    private Boolean federationEnabled;

    /**
     * JWK Set document containing keys that are used to sign (1) self-signed
     * entity statement of this service and (2) the response from
     * `signed_jwks_uri`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("federationJwks")
    private String federationJwks;

    /**
     * A key ID to identify a JWK used to sign the entity configuration and
     * the signed JWK Set.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("federationSignatureKeyId")
    private String federationSignatureKeyId;

    /**
     * The duration of the entity configuration in seconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("federationConfigurationDuration")
    private Long federationConfigurationDuration;

    /**
     * The URI of the federation registration endpoint. This property corresponds
     * to the `federation_registration_endpoint` server metadata that is
     * defined in OpenID Connect Federation 1.0.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("federationRegistrationEndpoint")
    private String federationRegistrationEndpoint;

    /**
     * The human-readable name representing the organization that operates
     * this service. This property corresponds to the `organization_name`
     * server metadata that is defined in OpenID Connect Federation 1.0.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("organizationName")
    private String organizationName;

    /**
     * The transformed claims predefined by this service in JSON format.
     * This property corresponds to the `transformed_claims_predefined`
     * server metadata.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("predefinedTransformedClaims")
    private String predefinedTransformedClaims;

    /**
     * flag indicating whether refresh token requests with the same
     * refresh token can be made multiple times in quick succession and
     * they can obtain the same renewed refresh token within the short
     * period.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("refreshTokenIdempotent")
    private Boolean refreshTokenIdempotent;

    /**
     * The URI of the endpoint that returns this service's JWK Set document in
     * the JWT format. This property corresponds to the `signed_jwks_uri`
     * server metadata defined in OpenID Connect Federation 1.0.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("signedJwksUri")
    private String signedJwksUri;

    /**
     * Supported attachment types. This property corresponds to the {@code
     * attachments_supported} server metadata which was added by the third
     * implementer's draft of OpenID Connect for Identity Assurance 1.0.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedAttachments")
    private List<ServiceUpdateApiSupportedAttachmentRequest> supportedAttachments;

    /**
     * Supported algorithms used to compute digest values of external
     * attachments. This property corresponds to the
     * `digest_algorithms_supported` server metadata which was added
     * by the third implementer's draft of OpenID Connect for Identity
     * Assurance 1.0.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedDigestAlgorithms")
    private List<String> supportedDigestAlgorithms;

    /**
     * Document types supported by this service. This property corresponds
     * to the `documents_supported` server metadata.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedDocuments")
    private List<String> supportedDocuments;

    /**
     * validation and verification processes supported by this service.
     * This property corresponds to the `documents_methods_supported`
     * server metadata.
     * 
     * <p>The third implementer's draft of [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     * renamed the
     * `id_documents_verification_methods_supported` server metadata to
     * `documents_methods_supported`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedDocumentsMethods")
    private List<String> supportedDocumentsMethods;

    /**
     * Document validation methods supported by this service. This property
     * corresponds to the `documents_validation_methods_supported` server
     * metadata which was added by the third implementer's draft of &lt;a href=
     * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedDocumentsValidationMethods")
    private List<String> supportedDocumentsValidationMethods;

    /**
     * Document verification methods supported by this service. This property
     * corresponds to the `documents_verification_methods_supported` server
     * metadata which was added by the third implementer's draft of
     * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedDocumentsVerificationMethods")
    private List<String> supportedDocumentsVerificationMethods;

    /**
     * Electronic record types supported by this service. This property
     * corresponds to the `electronic_records_supported` server metadata
     * which was added by the third implementer's draft of
     * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedElectronicRecords")
    private List<String> supportedElectronicRecords;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedClientRegistrationTypes")
    private List<ServiceUpdateApiSupportedClientRegistrationTypeRequest> supportedClientRegistrationTypes;

    /**
     * The flag indicating whether to prohibit unidentifiable clients from
     * making token exchange requests.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tokenExchangeByIdentifiableClientsOnly")
    private Boolean tokenExchangeByIdentifiableClientsOnly;

    /**
     * The flag indicating whether to prohibit public clients from making
     * token exchange requests.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tokenExchangeByConfidentialClientsOnly")
    private Boolean tokenExchangeByConfidentialClientsOnly;

    /**
     * The flag indicating whether to prohibit clients that have no explicit
     * permission from making token exchange requests.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tokenExchangeByPermittedClientsOnly")
    private Boolean tokenExchangeByPermittedClientsOnly;

    /**
     * The flag indicating whether to reject token exchange requests which
     * use encrypted JWTs as input tokens.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tokenExchangeEncryptedJwtRejected")
    private Boolean tokenExchangeEncryptedJwtRejected;

    /**
     * The flag indicating whether to reject token exchange requests which
     * use unsigned JWTs as input tokens.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tokenExchangeUnsignedJwtRejected")
    private Boolean tokenExchangeUnsignedJwtRejected;

    /**
     * The flag indicating whether to prohibit unidentifiable clients from
     * using the grant type "urn:ietf:params:oauth:grant-type:jwt-bearer".
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("jwtGrantByIdentifiableClientsOnly")
    private Boolean jwtGrantByIdentifiableClientsOnly;

    /**
     * The flag indicating whether to reject token requests that use an
     * encrypted JWT as an authorization grant with the grant type
     * "urn:ietf:params:oauth:grant-type:jwt-bearer".
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("jwtGrantEncryptedJwtRejected")
    private Boolean jwtGrantEncryptedJwtRejected;

    /**
     * The flag indicating whether to reject token requests that use an
     * unsigned JWT as an authorization grant with the grant type
     * "urn:ietf:params:oauth:grant-type:jwt-bearer".
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("jwtGrantUnsignedJwtRejected")
    private Boolean jwtGrantUnsignedJwtRejected;

    /**
     * The flag indicating whether to block DCR (Dynamic Client Registration)
     * requests whose "software_id" has already been used previously.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dcrDuplicateSoftwareIdBlocked")
    private Boolean dcrDuplicateSoftwareIdBlocked;

    /**
     * The trust anchors that are referenced when this service resolves
     * trust chains of relying parties.
     * 
     * <p>If this property is empty, client registration fails regardless of
     * whether its type is `automatic` or `explicit`. It means
     * that OpenID Connect Federation 1.0 does not work.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("trustAnchors")
    private List<ServiceUpdateApiTrustAnchorRequest> trustAnchors;

    /**
     * The flag indicating whether the openid scope should be dropped from
     * scopes list assigned to access token issued when a refresh token grant
     * is used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("openidDroppedOnRefreshWithoutOfflineAccess")
    private Boolean openidDroppedOnRefreshWithoutOfflineAccess;

    /**
     * Supported document check methods. This property corresponds to the `documents_check_methods_supported`
     * server metadata which was added by the fourth implementer's draft of OpenID Connect for Identity
     * Assurance 1.0.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedDocumentsCheckMethods")
    private List<String> supportedDocumentsCheckMethods;

    /**
     * The flag indicating whether this service signs responses from the resource server.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("rsResponseSigned")
    private Boolean rsResponseSigned;

    /**
     * The duration of `c_nonce`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cnonceDuration")
    private Long cnonceDuration;

    /**
     * Whether to require DPoP proof JWTs to include the `nonce` claim
     * whenever they are presented.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dpopNonceRequired")
    private Boolean dpopNonceRequired;

    /**
     * Get the flag indicating whether the feature of Verifiable Credentials
     * for this service is enabled or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("verifiableCredentialsEnabled")
    private Boolean verifiableCredentialsEnabled;

    /**
     * The URL at which the JWK Set document of the credential issuer is
     * exposed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("credentialJwksUri")
    private String credentialJwksUri;

    /**
     * The default duration of credential offers in seconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("credentialOfferDuration")
    private Long credentialOfferDuration;

    /**
     * The duration of nonce values for DPoP proof JWTs in seconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dpopNonceDuration")
    private Long dpopNonceDuration;

    /**
     * The flag indicating whether token requests using the pre-authorized
     * code grant flow by unidentifiable clients are allowed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("preAuthorizedGrantAnonymousAccessSupported")
    private Boolean preAuthorizedGrantAnonymousAccessSupported;

    /**
     * The duration of transaction ID in seconds that may be issued as a
     * result of a credential request or a batch credential request.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("credentialTransactionDuration")
    private Long credentialTransactionDuration;

    /**
     * The key ID of the key for signing introspection responses.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("introspectionSignatureKeyId")
    private String introspectionSignatureKeyId;

    /**
     * The key ID of the key for signing introspection responses.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resourceSignatureKeyId")
    private String resourceSignatureKeyId;

    /**
     * The default length of user PINs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userPinLength")
    private Integer userPinLength;

    /**
     * The supported `prompt` values.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supportedPromptValues")
    private List<ServiceUpdateApiSupportedPromptValueRequest> supportedPromptValues;

    /**
     * The flag indicating whether to enable the feature of ID token
     * reissuance in the refresh token flow.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("idTokenReissuable")
    private Boolean idTokenReissuable;

    /**
     * The JWK Set document containing private keys that are used to sign
     * verifiable credentials.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("credentialJwks")
    private String credentialJwks;

    /**
     * FAPI modes for this service.
     * 
     * <p>When the value of this property is not `null`, Authlete always processes requests to this service based
     * on the specified FAPI modes if the FAPI feature is enabled in Authlete and the FAPI profile is supported
     * by this service.
     * 
     * <p>For instance, when this property is set to an array containing `FAPI1_ADVANCED` only, Authlete always
     * processes requests to this service based on "Financial-grade API Security Profile 1.0 - Part 2:
     * Advanced" if the FAPI feature is enabled in Authlete and the FAPI profile is supported by this service.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fapiModes")
    private List<ServiceUpdateApiFapiModeRequest> fapiModes;

    /**
     * The default duration of verifiable credentials in seconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("credentialDuration")
    private Long credentialDuration;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("credentialIssuerMetadata")
    private ServiceUpdateApiCredentialIssuerMetadataRequest credentialIssuerMetadata;

    /**
     * The type of the `aud` claim in ID tokens.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("idTokenAudType")
    private String idTokenAudType;

    @JsonCreator
    public ServiceUpdateApiRequestBody(
            @JsonProperty("serviceName") @Nullable String serviceName,
            @JsonProperty("issuer") @Nullable String issuer,
            @JsonProperty("description") @Nullable String description,
            @JsonProperty("clientIdAliasEnabled") @Nullable Boolean clientIdAliasEnabled,
            @JsonProperty("metadata") @Nullable List<ServiceUpdateApiMetadatumRequest> metadata,
            @JsonProperty("authenticationCallbackEndpoint") @Nullable String authenticationCallbackEndpoint,
            @JsonProperty("authenticationCallbackApiKey") @Nullable String authenticationCallbackApiKey,
            @JsonProperty("authenticationCallbackApiSecret") @Nullable String authenticationCallbackApiSecret,
            @JsonProperty("supportedGrantTypes") @Nullable List<ServiceUpdateApiSupportedGrantTypeRequest> supportedGrantTypes,
            @JsonProperty("supportedResponseTypes") @Nullable List<ServiceUpdateApiSupportedResponseTypeRequest> supportedResponseTypes,
            @JsonProperty("supportedAuthorizationDetailsTypes") @Nullable List<String> supportedAuthorizationDetailsTypes,
            @JsonProperty("supportedServiceProfiles") @Nullable List<ServiceUpdateApiSupportedServiceProfileRequest> supportedServiceProfiles,
            @JsonProperty("errorDescriptionOmitted") @Nullable Boolean errorDescriptionOmitted,
            @JsonProperty("errorUriOmitted") @Nullable Boolean errorUriOmitted,
            @JsonProperty("authorizationEndpoint") @Nullable String authorizationEndpoint,
            @JsonProperty("directAuthorizationEndpointEnabled") @Nullable Boolean directAuthorizationEndpointEnabled,
            @JsonProperty("supportedUiLocales") @Nullable List<String> supportedUiLocales,
            @JsonProperty("supportedDisplays") @Nullable List<ServiceUpdateApiSupportedDisplayRequest> supportedDisplays,
            @JsonProperty("pkceRequired") @Nullable Boolean pkceRequired,
            @JsonProperty("pkceS256Required") @Nullable Boolean pkceS256Required,
            @JsonProperty("authorizationResponseDuration") @Nullable Long authorizationResponseDuration,
            @JsonProperty("tokenEndpoint") @Nullable String tokenEndpoint,
            @JsonProperty("directTokenEndpointEnabled") @Nullable Boolean directTokenEndpointEnabled,
            @JsonProperty("supportedTokenAuthMethods") @Nullable List<ServiceUpdateApiSupportedTokenAuthMethodRequest> supportedTokenAuthMethods,
            @JsonProperty("missingClientIdAllowed") @Nullable Boolean missingClientIdAllowed,
            @JsonProperty("revocationEndpoint") @Nullable String revocationEndpoint,
            @JsonProperty("directRevocationEndpointEnabled") @Nullable Boolean directRevocationEndpointEnabled,
            @JsonProperty("supportedRevocationAuthMethods") @Nullable List<ServiceUpdateApiSupportedRevocationAuthMethodRequest> supportedRevocationAuthMethods,
            @JsonProperty("introspectionEndpoint") @Nullable String introspectionEndpoint,
            @JsonProperty("directIntrospectionEndpointEnabled") @Nullable Boolean directIntrospectionEndpointEnabled,
            @JsonProperty("supportedIntrospectionAuthMethods") @Nullable List<ServiceUpdateApiSupportedIntrospectionAuthMethodRequest> supportedIntrospectionAuthMethods,
            @JsonProperty("pushedAuthReqEndpoint") @Nullable String pushedAuthReqEndpoint,
            @JsonProperty("pushedAuthReqDuration") @Nullable Long pushedAuthReqDuration,
            @JsonProperty("parRequired") @Nullable Boolean parRequired,
            @JsonProperty("requestObjectRequired") @Nullable Boolean requestObjectRequired,
            @JsonProperty("traditionalRequestObjectProcessingApplied") @Nullable Boolean traditionalRequestObjectProcessingApplied,
            @JsonProperty("mutualTlsValidatePkiCertChain") @Nullable Boolean mutualTlsValidatePkiCertChain,
            @JsonProperty("trustedRootCertificates") @Nullable List<String> trustedRootCertificates,
            @JsonProperty("mtlsEndpointAliases") @Nullable List<ServiceUpdateApiMtlsEndpointAliasRequest> mtlsEndpointAliases,
            @JsonProperty("accessTokenType") @Nullable String accessTokenType,
            @JsonProperty("tlsClientCertificateBoundAccessTokens") @Nullable Boolean tlsClientCertificateBoundAccessTokens,
            @JsonProperty("accessTokenDuration") @Nullable Long accessTokenDuration,
            @JsonProperty("singleAccessTokenPerSubject") @Nullable Boolean singleAccessTokenPerSubject,
            @JsonProperty("accessTokenSignAlg") @Nullable ServiceUpdateApiAccessTokenSignAlgRequest accessTokenSignAlg,
            @JsonProperty("accessTokenSignatureKeyId") @Nullable String accessTokenSignatureKeyId,
            @JsonProperty("refreshTokenDuration") @Nullable Long refreshTokenDuration,
            @JsonProperty("refreshTokenDurationKept") @Nullable Boolean refreshTokenDurationKept,
            @JsonProperty("refreshTokenDurationReset") @Nullable Boolean refreshTokenDurationReset,
            @JsonProperty("refreshTokenKept") @Nullable Boolean refreshTokenKept,
            @JsonProperty("supportedScopes") @Nullable List<ServiceUpdateApiSupportedScopeRequest> supportedScopes,
            @JsonProperty("scopeRequired") @Nullable Boolean scopeRequired,
            @JsonProperty("idTokenDuration") @Nullable Long idTokenDuration,
            @JsonProperty("allowableClockSkew") @Nullable Integer allowableClockSkew,
            @JsonProperty("supportedClaimTypes") @Nullable List<ServiceUpdateApiSupportedClaimTypeRequest> supportedClaimTypes,
            @JsonProperty("supportedClaimLocales") @Nullable List<String> supportedClaimLocales,
            @JsonProperty("supportedClaims") @Nullable List<String> supportedClaims,
            @JsonProperty("claimShortcutRestrictive") @Nullable Boolean claimShortcutRestrictive,
            @JsonProperty("jwksUri") @Nullable String jwksUri,
            @JsonProperty("directJwksEndpointEnabled") @Nullable Boolean directJwksEndpointEnabled,
            @JsonProperty("jwks") @Nullable String jwks,
            @JsonProperty("idTokenSignatureKeyId") @Nullable String idTokenSignatureKeyId,
            @JsonProperty("userInfoSignatureKeyId") @Nullable String userInfoSignatureKeyId,
            @JsonProperty("authorizationSignatureKeyId") @Nullable String authorizationSignatureKeyId,
            @JsonProperty("userInfoEndpoint") @Nullable String userInfoEndpoint,
            @JsonProperty("directUserInfoEndpointEnabled") @Nullable Boolean directUserInfoEndpointEnabled,
            @JsonProperty("dynamicRegistrationSupported") @Nullable Boolean dynamicRegistrationSupported,
            @JsonProperty("registrationEndpoint") @Nullable String registrationEndpoint,
            @JsonProperty("registrationManagementEndpoint") @Nullable String registrationManagementEndpoint,
            @JsonProperty("policyUri") @Nullable String policyUri,
            @JsonProperty("tosUri") @Nullable String tosUri,
            @JsonProperty("serviceDocumentation") @Nullable String serviceDocumentation,
            @JsonProperty("backchannelAuthenticationEndpoint") @Nullable String backchannelAuthenticationEndpoint,
            @JsonProperty("supportedBackchannelTokenDeliveryModes") @Nullable List<ServiceUpdateApiSupportedBackchannelTokenDeliveryModeRequest> supportedBackchannelTokenDeliveryModes,
            @JsonProperty("backchannelAuthReqIdDuration") @Nullable Integer backchannelAuthReqIdDuration,
            @JsonProperty("backchannelPollingInterval") @Nullable Integer backchannelPollingInterval,
            @JsonProperty("backchannelUserCodeParameterSupported") @Nullable Boolean backchannelUserCodeParameterSupported,
            @JsonProperty("backchannelBindingMessageRequiredInFapi") @Nullable Boolean backchannelBindingMessageRequiredInFapi,
            @JsonProperty("deviceAuthorizationEndpoint") @Nullable String deviceAuthorizationEndpoint,
            @JsonProperty("deviceVerificationUri") @Nullable String deviceVerificationUri,
            @JsonProperty("deviceVerificationUriComplete") @Nullable String deviceVerificationUriComplete,
            @JsonProperty("deviceFlowCodeDuration") @Nullable Integer deviceFlowCodeDuration,
            @JsonProperty("deviceFlowPollingInterval") @Nullable Integer deviceFlowPollingInterval,
            @JsonProperty("userCodeCharset") @Nullable ServiceUpdateApiUserCodeCharsetRequest userCodeCharset,
            @JsonProperty("userCodeLength") @Nullable Integer userCodeLength,
            @JsonProperty("supportedTrustFrameworks") @Nullable List<String> supportedTrustFrameworks,
            @JsonProperty("supportedEvidence") @Nullable List<String> supportedEvidence,
            @JsonProperty("supportedIdentityDocuments") @Nullable List<String> supportedIdentityDocuments,
            @JsonProperty("supportedVerificationMethods") @Nullable List<String> supportedVerificationMethods,
            @JsonProperty("supportedVerifiedClaims") @Nullable List<String> supportedVerifiedClaims,
            @JsonProperty("verifiedClaimsValidationSchemaSet") @Nullable ServiceUpdateApiVerifiedClaimsValidationSchemaSetRequest verifiedClaimsValidationSchemaSet,
            @JsonProperty("attributes") @Nullable List<ServiceUpdateApiAttributeRequest> attributes,
            @JsonProperty("nbfOptional") @Nullable Boolean nbfOptional,
            @JsonProperty("issSuppressed") @Nullable Boolean issSuppressed,
            @JsonProperty("supportedCustomClientMetadata") @Nullable List<String> supportedCustomClientMetadata,
            @JsonProperty("tokenExpirationLinked") @Nullable Boolean tokenExpirationLinked,
            @JsonProperty("frontChannelRequestObjectEncryptionRequired") @Nullable Boolean frontChannelRequestObjectEncryptionRequired,
            @JsonProperty("requestObjectEncryptionAlgMatchRequired") @Nullable Boolean requestObjectEncryptionAlgMatchRequired,
            @JsonProperty("requestObjectEncryptionEncMatchRequired") @Nullable Boolean requestObjectEncryptionEncMatchRequired,
            @JsonProperty("hsmEnabled") @Nullable Boolean hsmEnabled,
            @JsonProperty("hsks") @Nullable List<ServiceUpdateApiHskRequest> hsks,
            @JsonProperty("grantManagementEndpoint") @Nullable String grantManagementEndpoint,
            @JsonProperty("grantManagementActionRequired") @Nullable Boolean grantManagementActionRequired,
            @JsonProperty("unauthorizedOnClientConfigSupported") @Nullable Boolean unauthorizedOnClientConfigSupported,
            @JsonProperty("dcrScopeUsedAsRequestable") @Nullable Boolean dcrScopeUsedAsRequestable,
            @JsonProperty("endSessionEndpoint") @Nullable String endSessionEndpoint,
            @JsonProperty("loopbackRedirectionUriVariable") @Nullable Boolean loopbackRedirectionUriVariable,
            @JsonProperty("requestObjectAudienceChecked") @Nullable Boolean requestObjectAudienceChecked,
            @JsonProperty("accessTokenForExternalAttachmentEmbedded") @Nullable Boolean accessTokenForExternalAttachmentEmbedded,
            @JsonProperty("authorityHints") @Nullable List<String> authorityHints,
            @JsonProperty("federationEnabled") @Nullable Boolean federationEnabled,
            @JsonProperty("federationJwks") @Nullable String federationJwks,
            @JsonProperty("federationSignatureKeyId") @Nullable String federationSignatureKeyId,
            @JsonProperty("federationConfigurationDuration") @Nullable Long federationConfigurationDuration,
            @JsonProperty("federationRegistrationEndpoint") @Nullable String federationRegistrationEndpoint,
            @JsonProperty("organizationName") @Nullable String organizationName,
            @JsonProperty("predefinedTransformedClaims") @Nullable String predefinedTransformedClaims,
            @JsonProperty("refreshTokenIdempotent") @Nullable Boolean refreshTokenIdempotent,
            @JsonProperty("signedJwksUri") @Nullable String signedJwksUri,
            @JsonProperty("supportedAttachments") @Nullable List<ServiceUpdateApiSupportedAttachmentRequest> supportedAttachments,
            @JsonProperty("supportedDigestAlgorithms") @Nullable List<String> supportedDigestAlgorithms,
            @JsonProperty("supportedDocuments") @Nullable List<String> supportedDocuments,
            @JsonProperty("supportedDocumentsMethods") @Nullable List<String> supportedDocumentsMethods,
            @JsonProperty("supportedDocumentsValidationMethods") @Nullable List<String> supportedDocumentsValidationMethods,
            @JsonProperty("supportedDocumentsVerificationMethods") @Nullable List<String> supportedDocumentsVerificationMethods,
            @JsonProperty("supportedElectronicRecords") @Nullable List<String> supportedElectronicRecords,
            @JsonProperty("supportedClientRegistrationTypes") @Nullable List<ServiceUpdateApiSupportedClientRegistrationTypeRequest> supportedClientRegistrationTypes,
            @JsonProperty("tokenExchangeByIdentifiableClientsOnly") @Nullable Boolean tokenExchangeByIdentifiableClientsOnly,
            @JsonProperty("tokenExchangeByConfidentialClientsOnly") @Nullable Boolean tokenExchangeByConfidentialClientsOnly,
            @JsonProperty("tokenExchangeByPermittedClientsOnly") @Nullable Boolean tokenExchangeByPermittedClientsOnly,
            @JsonProperty("tokenExchangeEncryptedJwtRejected") @Nullable Boolean tokenExchangeEncryptedJwtRejected,
            @JsonProperty("tokenExchangeUnsignedJwtRejected") @Nullable Boolean tokenExchangeUnsignedJwtRejected,
            @JsonProperty("jwtGrantByIdentifiableClientsOnly") @Nullable Boolean jwtGrantByIdentifiableClientsOnly,
            @JsonProperty("jwtGrantEncryptedJwtRejected") @Nullable Boolean jwtGrantEncryptedJwtRejected,
            @JsonProperty("jwtGrantUnsignedJwtRejected") @Nullable Boolean jwtGrantUnsignedJwtRejected,
            @JsonProperty("dcrDuplicateSoftwareIdBlocked") @Nullable Boolean dcrDuplicateSoftwareIdBlocked,
            @JsonProperty("trustAnchors") @Nullable List<ServiceUpdateApiTrustAnchorRequest> trustAnchors,
            @JsonProperty("openidDroppedOnRefreshWithoutOfflineAccess") @Nullable Boolean openidDroppedOnRefreshWithoutOfflineAccess,
            @JsonProperty("supportedDocumentsCheckMethods") @Nullable List<String> supportedDocumentsCheckMethods,
            @JsonProperty("rsResponseSigned") @Nullable Boolean rsResponseSigned,
            @JsonProperty("cnonceDuration") @Nullable Long cnonceDuration,
            @JsonProperty("dpopNonceRequired") @Nullable Boolean dpopNonceRequired,
            @JsonProperty("verifiableCredentialsEnabled") @Nullable Boolean verifiableCredentialsEnabled,
            @JsonProperty("credentialJwksUri") @Nullable String credentialJwksUri,
            @JsonProperty("credentialOfferDuration") @Nullable Long credentialOfferDuration,
            @JsonProperty("dpopNonceDuration") @Nullable Long dpopNonceDuration,
            @JsonProperty("preAuthorizedGrantAnonymousAccessSupported") @Nullable Boolean preAuthorizedGrantAnonymousAccessSupported,
            @JsonProperty("credentialTransactionDuration") @Nullable Long credentialTransactionDuration,
            @JsonProperty("introspectionSignatureKeyId") @Nullable String introspectionSignatureKeyId,
            @JsonProperty("resourceSignatureKeyId") @Nullable String resourceSignatureKeyId,
            @JsonProperty("userPinLength") @Nullable Integer userPinLength,
            @JsonProperty("supportedPromptValues") @Nullable List<ServiceUpdateApiSupportedPromptValueRequest> supportedPromptValues,
            @JsonProperty("idTokenReissuable") @Nullable Boolean idTokenReissuable,
            @JsonProperty("credentialJwks") @Nullable String credentialJwks,
            @JsonProperty("fapiModes") @Nullable List<ServiceUpdateApiFapiModeRequest> fapiModes,
            @JsonProperty("credentialDuration") @Nullable Long credentialDuration,
            @JsonProperty("credentialIssuerMetadata") @Nullable ServiceUpdateApiCredentialIssuerMetadataRequest credentialIssuerMetadata,
            @JsonProperty("idTokenAudType") @Nullable String idTokenAudType) {
        this.serviceName = serviceName;
        this.issuer = issuer;
        this.description = description;
        this.clientIdAliasEnabled = clientIdAliasEnabled;
        this.metadata = metadata;
        this.authenticationCallbackEndpoint = authenticationCallbackEndpoint;
        this.authenticationCallbackApiKey = authenticationCallbackApiKey;
        this.authenticationCallbackApiSecret = authenticationCallbackApiSecret;
        this.supportedGrantTypes = supportedGrantTypes;
        this.supportedResponseTypes = supportedResponseTypes;
        this.supportedAuthorizationDetailsTypes = supportedAuthorizationDetailsTypes;
        this.supportedServiceProfiles = supportedServiceProfiles;
        this.errorDescriptionOmitted = errorDescriptionOmitted;
        this.errorUriOmitted = errorUriOmitted;
        this.authorizationEndpoint = authorizationEndpoint;
        this.directAuthorizationEndpointEnabled = directAuthorizationEndpointEnabled;
        this.supportedUiLocales = supportedUiLocales;
        this.supportedDisplays = supportedDisplays;
        this.pkceRequired = pkceRequired;
        this.pkceS256Required = pkceS256Required;
        this.authorizationResponseDuration = authorizationResponseDuration;
        this.tokenEndpoint = tokenEndpoint;
        this.directTokenEndpointEnabled = directTokenEndpointEnabled;
        this.supportedTokenAuthMethods = supportedTokenAuthMethods;
        this.missingClientIdAllowed = missingClientIdAllowed;
        this.revocationEndpoint = revocationEndpoint;
        this.directRevocationEndpointEnabled = directRevocationEndpointEnabled;
        this.supportedRevocationAuthMethods = supportedRevocationAuthMethods;
        this.introspectionEndpoint = introspectionEndpoint;
        this.directIntrospectionEndpointEnabled = directIntrospectionEndpointEnabled;
        this.supportedIntrospectionAuthMethods = supportedIntrospectionAuthMethods;
        this.pushedAuthReqEndpoint = pushedAuthReqEndpoint;
        this.pushedAuthReqDuration = pushedAuthReqDuration;
        this.parRequired = parRequired;
        this.requestObjectRequired = requestObjectRequired;
        this.traditionalRequestObjectProcessingApplied = traditionalRequestObjectProcessingApplied;
        this.mutualTlsValidatePkiCertChain = mutualTlsValidatePkiCertChain;
        this.trustedRootCertificates = trustedRootCertificates;
        this.mtlsEndpointAliases = mtlsEndpointAliases;
        this.accessTokenType = accessTokenType;
        this.tlsClientCertificateBoundAccessTokens = tlsClientCertificateBoundAccessTokens;
        this.accessTokenDuration = accessTokenDuration;
        this.singleAccessTokenPerSubject = singleAccessTokenPerSubject;
        this.accessTokenSignAlg = accessTokenSignAlg;
        this.accessTokenSignatureKeyId = accessTokenSignatureKeyId;
        this.refreshTokenDuration = refreshTokenDuration;
        this.refreshTokenDurationKept = refreshTokenDurationKept;
        this.refreshTokenDurationReset = refreshTokenDurationReset;
        this.refreshTokenKept = refreshTokenKept;
        this.supportedScopes = supportedScopes;
        this.scopeRequired = scopeRequired;
        this.idTokenDuration = idTokenDuration;
        this.allowableClockSkew = allowableClockSkew;
        this.supportedClaimTypes = supportedClaimTypes;
        this.supportedClaimLocales = supportedClaimLocales;
        this.supportedClaims = supportedClaims;
        this.claimShortcutRestrictive = claimShortcutRestrictive;
        this.jwksUri = jwksUri;
        this.directJwksEndpointEnabled = directJwksEndpointEnabled;
        this.jwks = jwks;
        this.idTokenSignatureKeyId = idTokenSignatureKeyId;
        this.userInfoSignatureKeyId = userInfoSignatureKeyId;
        this.authorizationSignatureKeyId = authorizationSignatureKeyId;
        this.userInfoEndpoint = userInfoEndpoint;
        this.directUserInfoEndpointEnabled = directUserInfoEndpointEnabled;
        this.dynamicRegistrationSupported = dynamicRegistrationSupported;
        this.registrationEndpoint = registrationEndpoint;
        this.registrationManagementEndpoint = registrationManagementEndpoint;
        this.policyUri = policyUri;
        this.tosUri = tosUri;
        this.serviceDocumentation = serviceDocumentation;
        this.backchannelAuthenticationEndpoint = backchannelAuthenticationEndpoint;
        this.supportedBackchannelTokenDeliveryModes = supportedBackchannelTokenDeliveryModes;
        this.backchannelAuthReqIdDuration = backchannelAuthReqIdDuration;
        this.backchannelPollingInterval = backchannelPollingInterval;
        this.backchannelUserCodeParameterSupported = backchannelUserCodeParameterSupported;
        this.backchannelBindingMessageRequiredInFapi = backchannelBindingMessageRequiredInFapi;
        this.deviceAuthorizationEndpoint = deviceAuthorizationEndpoint;
        this.deviceVerificationUri = deviceVerificationUri;
        this.deviceVerificationUriComplete = deviceVerificationUriComplete;
        this.deviceFlowCodeDuration = deviceFlowCodeDuration;
        this.deviceFlowPollingInterval = deviceFlowPollingInterval;
        this.userCodeCharset = userCodeCharset;
        this.userCodeLength = userCodeLength;
        this.supportedTrustFrameworks = supportedTrustFrameworks;
        this.supportedEvidence = supportedEvidence;
        this.supportedIdentityDocuments = supportedIdentityDocuments;
        this.supportedVerificationMethods = supportedVerificationMethods;
        this.supportedVerifiedClaims = supportedVerifiedClaims;
        this.verifiedClaimsValidationSchemaSet = verifiedClaimsValidationSchemaSet;
        this.attributes = attributes;
        this.nbfOptional = nbfOptional;
        this.issSuppressed = issSuppressed;
        this.supportedCustomClientMetadata = supportedCustomClientMetadata;
        this.tokenExpirationLinked = tokenExpirationLinked;
        this.frontChannelRequestObjectEncryptionRequired = frontChannelRequestObjectEncryptionRequired;
        this.requestObjectEncryptionAlgMatchRequired = requestObjectEncryptionAlgMatchRequired;
        this.requestObjectEncryptionEncMatchRequired = requestObjectEncryptionEncMatchRequired;
        this.hsmEnabled = hsmEnabled;
        this.hsks = hsks;
        this.grantManagementEndpoint = grantManagementEndpoint;
        this.grantManagementActionRequired = grantManagementActionRequired;
        this.unauthorizedOnClientConfigSupported = unauthorizedOnClientConfigSupported;
        this.dcrScopeUsedAsRequestable = dcrScopeUsedAsRequestable;
        this.endSessionEndpoint = endSessionEndpoint;
        this.loopbackRedirectionUriVariable = loopbackRedirectionUriVariable;
        this.requestObjectAudienceChecked = requestObjectAudienceChecked;
        this.accessTokenForExternalAttachmentEmbedded = accessTokenForExternalAttachmentEmbedded;
        this.authorityHints = authorityHints;
        this.federationEnabled = federationEnabled;
        this.federationJwks = federationJwks;
        this.federationSignatureKeyId = federationSignatureKeyId;
        this.federationConfigurationDuration = federationConfigurationDuration;
        this.federationRegistrationEndpoint = federationRegistrationEndpoint;
        this.organizationName = organizationName;
        this.predefinedTransformedClaims = predefinedTransformedClaims;
        this.refreshTokenIdempotent = refreshTokenIdempotent;
        this.signedJwksUri = signedJwksUri;
        this.supportedAttachments = supportedAttachments;
        this.supportedDigestAlgorithms = supportedDigestAlgorithms;
        this.supportedDocuments = supportedDocuments;
        this.supportedDocumentsMethods = supportedDocumentsMethods;
        this.supportedDocumentsValidationMethods = supportedDocumentsValidationMethods;
        this.supportedDocumentsVerificationMethods = supportedDocumentsVerificationMethods;
        this.supportedElectronicRecords = supportedElectronicRecords;
        this.supportedClientRegistrationTypes = supportedClientRegistrationTypes;
        this.tokenExchangeByIdentifiableClientsOnly = tokenExchangeByIdentifiableClientsOnly;
        this.tokenExchangeByConfidentialClientsOnly = tokenExchangeByConfidentialClientsOnly;
        this.tokenExchangeByPermittedClientsOnly = tokenExchangeByPermittedClientsOnly;
        this.tokenExchangeEncryptedJwtRejected = tokenExchangeEncryptedJwtRejected;
        this.tokenExchangeUnsignedJwtRejected = tokenExchangeUnsignedJwtRejected;
        this.jwtGrantByIdentifiableClientsOnly = jwtGrantByIdentifiableClientsOnly;
        this.jwtGrantEncryptedJwtRejected = jwtGrantEncryptedJwtRejected;
        this.jwtGrantUnsignedJwtRejected = jwtGrantUnsignedJwtRejected;
        this.dcrDuplicateSoftwareIdBlocked = dcrDuplicateSoftwareIdBlocked;
        this.trustAnchors = trustAnchors;
        this.openidDroppedOnRefreshWithoutOfflineAccess = openidDroppedOnRefreshWithoutOfflineAccess;
        this.supportedDocumentsCheckMethods = supportedDocumentsCheckMethods;
        this.rsResponseSigned = rsResponseSigned;
        this.cnonceDuration = cnonceDuration;
        this.dpopNonceRequired = dpopNonceRequired;
        this.verifiableCredentialsEnabled = verifiableCredentialsEnabled;
        this.credentialJwksUri = credentialJwksUri;
        this.credentialOfferDuration = credentialOfferDuration;
        this.dpopNonceDuration = dpopNonceDuration;
        this.preAuthorizedGrantAnonymousAccessSupported = preAuthorizedGrantAnonymousAccessSupported;
        this.credentialTransactionDuration = credentialTransactionDuration;
        this.introspectionSignatureKeyId = introspectionSignatureKeyId;
        this.resourceSignatureKeyId = resourceSignatureKeyId;
        this.userPinLength = userPinLength;
        this.supportedPromptValues = supportedPromptValues;
        this.idTokenReissuable = idTokenReissuable;
        this.credentialJwks = credentialJwks;
        this.fapiModes = fapiModes;
        this.credentialDuration = credentialDuration;
        this.credentialIssuerMetadata = credentialIssuerMetadata;
        this.idTokenAudType = idTokenAudType;
    }
    
    public ServiceUpdateApiRequestBody() {
        this(null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null);
    }

    /**
     * The name of this service.
     */
    public Optional<String> serviceName() {
        return Optional.ofNullable(this.serviceName);
    }

    /**
     * The issuer identifier of the service.
     * 
     * <p>A URL that starts with  https:// and has no query or fragment component.
     * 
     * <p>The value of this property is used as `iss` claim in an [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)
     * and `issuer` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<String> issuer() {
        return Optional.ofNullable(this.issuer);
    }

    /**
     * The description about the service.
     */
    public Optional<String> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Deprecated. Always `true`.
     */
    public Optional<Boolean> clientIdAliasEnabled() {
        return Optional.ofNullable(this.clientIdAliasEnabled);
    }

    /**
     * The `metadata` of the service. The content of the returned array depends on contexts.
     * The predefined service metadata is listed in the following table.
     * 
     * <p>  | Key | Description |
     *   | --- | --- |
     *   | `clientCount` | The number of client applications which belong to this service.  |
     */
    public Optional<List<ServiceUpdateApiMetadatumRequest>> metadata() {
        return Optional.ofNullable(this.metadata);
    }

    /**
     * A Web API endpoint for user authentication which is to be prepared on the service side.
     * 
     * <p>The endpoint must be implemented if you do not implement the UI at the authorization endpoint
     * but use the one provided by Authlete.
     * 
     * <p>The user authentication at the authorization endpoint provided by Authlete is performed by making
     * a `POST` request to this endpoint.
     */
    public Optional<String> authenticationCallbackEndpoint() {
        return Optional.ofNullable(this.authenticationCallbackEndpoint);
    }

    /**
     * API key for basic authentication at the authentication callback endpoint.
     * 
     * <p>If the value is not empty, Authlete generates Authorization header for Basic authentication when
     * making a request to the authentication callback endpoint.
     */
    public Optional<String> authenticationCallbackApiKey() {
        return Optional.ofNullable(this.authenticationCallbackApiKey);
    }

    /**
     * API secret for `basic` authentication at the authentication callback endpoint.
     */
    public Optional<String> authenticationCallbackApiSecret() {
        return Optional.ofNullable(this.authenticationCallbackApiSecret);
    }

    /**
     * Values of `grant_type` request parameter that the service supports.
     * 
     * <p>The value of this property is used as `grant_types_supported property` in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<List<ServiceUpdateApiSupportedGrantTypeRequest>> supportedGrantTypes() {
        return Optional.ofNullable(this.supportedGrantTypes);
    }

    /**
     * Values of `response_type` request parameter that
     * the service supports. Valid values are listed in Response Type.
     * 
     * <p>The value of this property is used as `response_types_supported` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<List<ServiceUpdateApiSupportedResponseTypeRequest>> supportedResponseTypes() {
        return Optional.ofNullable(this.supportedResponseTypes);
    }

    /**
     * The supported data types that can be used as values of the type field in `authorization_details`.
     * 
     * <p>This property corresponds to the `authorization_details_types_supported` metadata. See "OAuth 2.0
     * Rich Authorization Requests" (RAR) for details.
     */
    public Optional<List<String>> supportedAuthorizationDetailsTypes() {
        return Optional.ofNullable(this.supportedAuthorizationDetailsTypes);
    }

    /**
     * The profiles that this service supports.
     */
    public Optional<List<ServiceUpdateApiSupportedServiceProfileRequest>> supportedServiceProfiles() {
        return Optional.ofNullable(this.supportedServiceProfiles);
    }

    /**
     * The flag to indicate whether the `error_description` response parameter is omitted.
     * 
     * <p>According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include
     * the `error_description` response parameter in error responses.
     * 
     * <p>If `true`, Authlete does not embed the `error_description` response parameter in error responses.
     */
    public Optional<Boolean> errorDescriptionOmitted() {
        return Optional.ofNullable(this.errorDescriptionOmitted);
    }

    /**
     * The flag to indicate whether the `error_uri` response parameter is omitted.
     * 
     * <p>According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include the `error_uri` response parameter in error responses.
     * 
     * <p>If `true`, Authlete does not embed the
     * `error_uri` response parameter in error responses.
     */
    public Optional<Boolean> errorUriOmitted() {
        return Optional.ofNullable(this.errorUriOmitted);
    }

    /**
     * The authorization endpoint of the service.
     * 
     * <p>A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/authorization`.
     * 
     * <p>The value of this property is used as `authorization_endpoint` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<String> authorizationEndpoint() {
        return Optional.ofNullable(this.authorizationEndpoint);
    }

    /**
     * The flag to indicate whether the direct authorization endpoint is enabled or not.
     * 
     * <p>The path of the endpoint is `/api/auth/authorization/direct/service-api-key`.
     */
    public Optional<Boolean> directAuthorizationEndpointEnabled() {
        return Optional.ofNullable(this.directAuthorizationEndpointEnabled);
    }

    /**
     * UI locales that the service supports.
     * 
     * <p>Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646). For example, `en-US` and `ja-JP`.
     * 
     * <p>The value of this property is used as `ui_locales_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<List<String>> supportedUiLocales() {
        return Optional.ofNullable(this.supportedUiLocales);
    }

    /**
     * Values of `display` request parameter that service supports.
     * 
     * <p>The value of this property is used as `display_values_supported` property in the Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<List<ServiceUpdateApiSupportedDisplayRequest>> supportedDisplays() {
        return Optional.ofNullable(this.supportedDisplays);
    }

    /**
     * The flag to indicate whether the use of Proof Key for Code Exchange (PKCE) is always required for authorization requests by Authorization Code Flow.
     * 
     * <p>If `true`, `code_challenge` request parameter is always required for authorization requests using Authorization Code Flow.
     * 
     * <p>See [RFC 7636](https://tools.ietf.org/html/rfc7636) (Proof Key for Code Exchange by OAuth Public Clients) for details about `code_challenge` request parameter.
     */
    public Optional<Boolean> pkceRequired() {
        return Optional.ofNullable(this.pkceRequired);
    }

    /**
     * The flag to indicate whether `S256` is always required as the code challenge method whenever [PKCE (RFC 7636)](https://tools.ietf.org/html/rfc7636) is used.
     * 
     * <p>If this flag is set to `true`, `code_challenge_method=S256` must be included in the authorization request
     * whenever it includes the `code_challenge` request parameter.
     * Neither omission of the `code_challenge_method` request parameter nor use of plain (`code_challenge_method=plain`) is allowed.
     */
    public Optional<Boolean> pkceS256Required() {
        return Optional.ofNullable(this.pkceS256Required);
    }

    /**
     * The duration of authorization response JWTs in seconds.
     * 
     * <p>[Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
     * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
     * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
     * from the authorization endpoint will be packed into a JWT. This property is used to compute the
     * value of the `exp` claim of the JWT.
     */
    public Optional<Long> authorizationResponseDuration() {
        return Optional.ofNullable(this.authorizationResponseDuration);
    }

    /**
     * The [token endpoint](https://tools.ietf.org/html/rfc6749#section-3.2) of the service.
     * 
     * <p>A URL that starts with `https://` and has not fragment component. For example, `https://example.com/auth/token`.
     * 
     * <p>The value of this property is used as `token_endpoint` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<String> tokenEndpoint() {
        return Optional.ofNullable(this.tokenEndpoint);
    }

    /**
     * The flag to indicate whether the direct token endpoint is enabled or not. The path of the endpoint
     * is `/api/auth/token/direct/service-api-key`.
     */
    public Optional<Boolean> directTokenEndpointEnabled() {
        return Optional.ofNullable(this.directTokenEndpointEnabled);
    }

    /**
     * Client authentication methods supported by the token endpoint of the service.
     * 
     * <p>The value of this property is used as `token_endpoint_auth_methods_supports` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<List<ServiceUpdateApiSupportedTokenAuthMethodRequest>> supportedTokenAuthMethods() {
        return Optional.ofNullable(this.supportedTokenAuthMethods);
    }

    /**
     * The flag to indicate token requests from public clients without the `client_id` request parameter are allowed when the client can be guessed from `authorization_code` or `refresh_token`.
     * 
     * <p>This flag should not be set unless you have special reasons.
     */
    public Optional<Boolean> missingClientIdAllowed() {
        return Optional.ofNullable(this.missingClientIdAllowed);
    }

    /**
     * The [revocation endpoint](https://tools.ietf.org/html/rfc7009) of the service.
     * 
     * <p>A URL that starts with `https://`. For example, `https://example.com/auth/revocation`.
     */
    public Optional<String> revocationEndpoint() {
        return Optional.ofNullable(this.revocationEndpoint);
    }

    /**
     * The flag to indicate whether the direct revocation endpoint is enabled or not. The URL of the endpoint is `/api/auth/revocation/direct/service-api-key`.
     */
    public Optional<Boolean> directRevocationEndpointEnabled() {
        return Optional.ofNullable(this.directRevocationEndpointEnabled);
    }

    /**
     * Client authentication methods supported at the revocation endpoint.
     */
    public Optional<List<ServiceUpdateApiSupportedRevocationAuthMethodRequest>> supportedRevocationAuthMethods() {
        return Optional.ofNullable(this.supportedRevocationAuthMethods);
    }

    /**
     * The URI of the introspection endpoint.
     */
    public Optional<String> introspectionEndpoint() {
        return Optional.ofNullable(this.introspectionEndpoint);
    }

    /**
     * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path of the endpoint is `/api/auth/userinfo/direct/{serviceApiKey}`.
     */
    public Optional<Boolean> directIntrospectionEndpointEnabled() {
        return Optional.ofNullable(this.directIntrospectionEndpointEnabled);
    }

    /**
     * Client authentication methods supported at the introspection endpoint.
     */
    public Optional<List<ServiceUpdateApiSupportedIntrospectionAuthMethodRequest>> supportedIntrospectionAuthMethods() {
        return Optional.ofNullable(this.supportedIntrospectionAuthMethods);
    }

    /**
     * The URI of the pushed authorization request endpoint.
     * 
     * <p>This property corresponds to the `pushed_authorization_request_endpoint` metadata defined in "[5. Authorization Server Metadata](https://tools.ietf.org/html/draft-lodderstedt-oauth-par#section-5)" of OAuth 2.0 Pushed Authorization Requests.
     */
    public Optional<String> pushedAuthReqEndpoint() {
        return Optional.ofNullable(this.pushedAuthReqEndpoint);
    }

    /**
     * The duration of pushed authorization requests in seconds.
     * 
     * <p>[OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par)
     * defines an endpoint (called "pushed authorization request endpoint") which client applications
     * can register authorization requests into and get corresponding URIs (called "request URIs") from.
     * The issued URIs represent the registered authorization requests. The client applications can use
     * the URIs as the value of the `request_uri` request parameter in an authorization request.
     * 
     * <p>The property represents the duration of registered authorization requests and is used as the value
     * of the `expires_in` parameter in responses from the pushed authorization request endpoint.
     */
    public Optional<Long> pushedAuthReqDuration() {
        return Optional.ofNullable(this.pushedAuthReqDuration);
    }

    /**
     * The flag to indicate whether this service requires that clients use the pushed authorization
     * request endpoint.
     * 
     * <p>This property corresponds to the `require_pushed_authorization_requests` server metadata defined
     * in [OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par).
     */
    public Optional<Boolean> parRequired() {
        return Optional.ofNullable(this.parRequired);
    }

    /**
     * The flag to indicate whether this service requires that authorization requests always utilize
     * a request object by using either request or `request_uri` request parameter.
     * 
     * <p>If this flag is set to `true` and the value of `traditionalRequestObjectProcessingApplied` is
     * `false`, the value of `require_signed_request_object` server metadata of this service is reported
     * as `true` in the discovery document. The metadata is defined in JAR (JWT Secured Authorization Request).
     * That `require_signed_request_object` is `true` means that authorization requests which don't
     * conform to the JAR specification are rejected.
     */
    public Optional<Boolean> requestObjectRequired() {
        return Optional.ofNullable(this.requestObjectRequired);
    }

    /**
     * The flag to indicate whether a request object is processed based on rules defined in
     * [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) or JAR (JWT
     * Secured Authorization Request).
     * 
     * <p>Differences between rules in OpenID Connect Core 1.0 and ones in JAR are as follows.
     *   - JAR requires that a request object be always -signed.
     *   - JAR does not allow request parameters outside a request object to be referred to.
     *   - OIDC Core 1.0 requires that response_type request parameter exist outside a request object even if the request object includes the request parameter.
     *   - OIDC Core 1.0 requires that scope request parameter exist outside a request object if the authorization request is an
     *   - OIDC request even if the request object includes the request parameter.
     * 
     * <p>If this flag is set to `false` and the value of `requestObjectRequired` is `true`, the value of
     * `require_signed_request_object` server metadata of this service
     * is reported as `true` in the discovery document. The metadata is defined in JAR (JWT Secured
     * Authorization Request). That `require_signed_request_object` is `true` means that authorization
     * requests which don't conform to the JAR specification are rejected.
     */
    public Optional<Boolean> traditionalRequestObjectProcessingApplied() {
        return Optional.ofNullable(this.traditionalRequestObjectProcessingApplied);
    }

    /**
     * The flag to indicate whether this service validates certificate chains during PKI-based client mutual TLS authentication.
     */
    public Optional<Boolean> mutualTlsValidatePkiCertChain() {
        return Optional.ofNullable(this.mutualTlsValidatePkiCertChain);
    }

    /**
     * The list of root certificates trusted by this service for PKI-based client mutual TLS authentication.
     */
    public Optional<List<String>> trustedRootCertificates() {
        return Optional.ofNullable(this.trustedRootCertificates);
    }

    /**
     * The MTLS endpoint aliases.
     * 
     * <p>This property corresponds to the mtls_endpoint_aliases metadata defined in "5. Metadata for Mutual TLS Endpoint Aliases" of [OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens](https://datatracker.ietf.org/doc/rfc8705/).
     * 
     * <p>The aliases will be embedded in the response from the discovery endpoint like the following.
     * 
     * <p>```json
     * {
     *   ......,
     *   "mtls_endpoint_aliases": {
     *     "token_endpoint":         "https://mtls.example.com/token",
     *     "revocation_endpoint":    "https://mtls.example.com/revo",
     *     "introspection_endpoint": "https://mtls.example.com/introspect"
     *   }
     * }
     * ```
     */
    public Optional<List<ServiceUpdateApiMtlsEndpointAliasRequest>> mtlsEndpointAliases() {
        return Optional.ofNullable(this.mtlsEndpointAliases);
    }

    /**
     * The access token type.
     * 
     * <p>This value is used as the value of `token_type` property in access token responses. If this service
     * complies with [RFC 6750](https://tools.ietf.org/html/rfc6750), the value of this property should
     * be `Bearer`.
     * 
     * <p>See [RFC 6749 (OAuth 2.0), 7.1. Access Token Types](https://tools.ietf.org/html/rfc6749#section-7.1) for details.
     */
    public Optional<String> accessTokenType() {
        return Optional.ofNullable(this.accessTokenType);
    }

    /**
     * The flag to indicate whether this service supports issuing TLS client certificate bound access tokens.
     */
    public Optional<Boolean> tlsClientCertificateBoundAccessTokens() {
        return Optional.ofNullable(this.tlsClientCertificateBoundAccessTokens);
    }

    /**
     * The duration of access tokens in seconds. This value is used as the value of `expires_in` property
     * in access token responses. `expires_in` is defined [RFC 6749, 5.1. Successful Response](https://tools.ietf.org/html/rfc6749#section-5.1).
     */
    public Optional<Long> accessTokenDuration() {
        return Optional.ofNullable(this.accessTokenDuration);
    }

    /**
     * The flag to indicate whether the number of access tokens per subject (and per client) is at most one or can be more.
     * 
     * <p>If `true`, an attempt to issue a new access token invalidates existing access tokens that are associated with the same subject and the same client.
     * 
     * <p>Note that, however, attempts by [Client Credentials Flow](https://tools.ietf.org/html/rfc6749#section-4.4) do not invalidate existing access tokens because access tokens issued by Client Credentials Flow are not associated with any end-user's subject. Also note that an attempt by [Refresh Token Flow](https://tools.ietf.org/html/rfc6749#section-6) invalidates the coupled access token only and this invalidation is always performed regardless of whether the value of this setting item is `true` or `false`.
     */
    public Optional<Boolean> singleAccessTokenPerSubject() {
        return Optional.ofNullable(this.singleAccessTokenPerSubject);
    }

    /**
     * The signature algorithm for JWT. This value is represented on 'alg' attribute
     * of the header of JWT.
     * 
     * <p>it's semantics depends upon where is this defined, for instance:
     *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
     *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
     *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
     */
    public Optional<ServiceUpdateApiAccessTokenSignAlgRequest> accessTokenSignAlg() {
        return Optional.ofNullable(this.accessTokenSignAlg);
    }

    /**
     * The key ID to identify a JWK used for signing access tokens.
     * 
     * <p>A JWK Set can be registered as a property of a service. A JWK Set can contain 0 or more JWKs.
     * Authlete Server has to pick up one JWK for signing from the JWK Set when it generates a JWT-based
     * access token. Authlete Server searches the registered JWK Set for a JWK which satisfies conditions
     * for access token signature. If the number of JWK candidates which satisfy the conditions is 1,
     * there is no problem. On the other hand, if there exist multiple candidates, a Key ID is needed
     * to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
     */
    public Optional<String> accessTokenSignatureKeyId() {
        return Optional.ofNullable(this.accessTokenSignatureKeyId);
    }

    /**
     * The duration of refresh tokens in seconds. The related specifications have no requirements on refresh token duration, but Authlete sets expiration for refresh tokens.
     */
    public Optional<Long> refreshTokenDuration() {
        return Optional.ofNullable(this.refreshTokenDuration);
    }

    /**
     * The flag to indicate whether the remaining duration of the used refresh token is taken over to
     * the newly issued refresh token.
     */
    public Optional<Boolean> refreshTokenDurationKept() {
        return Optional.ofNullable(this.refreshTokenDurationKept);
    }

    /**
     * The flag which indicates whether duration of refresh tokens are reset when they are used even
     * if the `refreshTokenKept` property of this service set to is `true` (= even if "Refresh Token
     * Continuous Use" is "Kept").
     * 
     * <p>This flag has no effect when the `refreshTokenKept` property is set to `false`. In other words,
     * if this service issues a new refresh token on every refresh token request, the refresh token
     * will have fresh duration (unless `refreshTokenDurationKept` is set to `true`) and this
     * `refreshTokenDurationReset` property is not referenced.
     */
    public Optional<Boolean> refreshTokenDurationReset() {
        return Optional.ofNullable(this.refreshTokenDurationReset);
    }

    /**
     * The flag to indicate whether a refresh token remains unchanged or gets renewed after its use.
     * 
     * <p>If `true`, a refresh token used to get a new access token remains valid after its use. Otherwise, if `false`, a refresh token is invalidated after its use and a new refresh token is issued.
     * 
     * <p>See [RFC 6749 6. Refreshing an Access Token](https://tools.ietf.org/html/rfc6749#section-6), as to how to get a new access token using a refresh token.
     */
    public Optional<Boolean> refreshTokenKept() {
        return Optional.ofNullable(this.refreshTokenKept);
    }

    /**
     * Scopes supported by the service.
     * 
     * <p>Authlete strongly recommends that the service register at least the following scopes.
     * 
     * <p>| Name | Description |
     * | --- | --- |
     * | openid | A permission to get an ID token of an end-user. The `openid` scope appears in [OpenID Connect Core 1.0, 3.1.2.1. Authentication Request, scope](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest). Without this scope, Authlete does not allow `response_type` request parameter to have values other than code and token. |
     * | profile | A permission to get information about `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale` and `updated_at` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
     * | email | A permission to get information about `email` and `email_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
     * | address | A permission to get information about address from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) and [5.1.1. Address Claim](https://openid.net/specs/openid-connect-core-1_0.html#AddressClaim) for details. |
     * | phone | A permission to get information about `phone_number` and `phone_number_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
     * | offline_access | A permission to get information from the user info endpoint even when the end-user is not present. See [OpenID Connect Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess) for details. |
     * 
     * <p>The value of this property is used as `scopes_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<List<ServiceUpdateApiSupportedScopeRequest>> supportedScopes() {
        return Optional.ofNullable(this.supportedScopes);
    }

    /**
     * The flag to indicate whether requests that request no scope are rejected or not.
     * 
     * <p>When a request has no explicit `scope` parameter and the service's pre-defined default scope set is empty,
     * the authorization server regards the request requests no scope. When this flag is set to `true`,
     * requests that request no scope are rejected.
     * 
     * <p>The requirement below excerpted from [RFC 6749 Section 3.3](https://tools.ietf.org/html/rfc6749#section-3.3)
     * does not explicitly mention the case where the default scope set is empty.
     * 
     * <p>&gt; If the client omits the scope parameter when requesting authorization, the authorization server
     * MUST either process the request using a pre-defined default value or fail the request indicating an invalid scope.
     * 
     * <p>However, if you interpret *"the default scope set exists but is empty"* as *"the default scope set does not exist"*
     * and want to strictly conform to the requirement above, this flag has to be `true`.
     */
    public Optional<Boolean> scopeRequired() {
        return Optional.ofNullable(this.scopeRequired);
    }

    /**
     * 'The duration of [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)s
     * in seconds. This value is used to calculate the value of `exp` claim in an ID token.'
     */
    public Optional<Long> idTokenDuration() {
        return Optional.ofNullable(this.idTokenDuration);
    }

    /**
     * The allowable clock skew between the server and clients in seconds.
     * 
     * <p>The clock skew is taken into consideration when time-related claims in a JWT (e.g. `exp`, `iat`, `nbf`) are verified.
     */
    public Optional<Integer> allowableClockSkew() {
        return Optional.ofNullable(this.allowableClockSkew);
    }

    /**
     * Claim types supported by the service. Valid values are listed in Claim Type. Note that Authlete
     * currently doesn't provide any API to help implementations for `AGGREGATED` and `DISTRIBUTED`.
     * 
     * <p>The value of this property is used as `claim_types_supported` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<List<ServiceUpdateApiSupportedClaimTypeRequest>> supportedClaimTypes() {
        return Optional.ofNullable(this.supportedClaimTypes);
    }

    /**
     * Claim locales that the service supports. Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646).
     * For example, `en-US` and `ja-JP`. See [OpenID Connect Core 1.0, 5.2. Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
     * for details.
     * 
     * <p>The value of this property is used as `claims_locales_supported` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<List<String>> supportedClaimLocales() {
        return Optional.ofNullable(this.supportedClaimLocales);
    }

    /**
     * Claim names that the service supports. The standard claim names listed in [OpenID Connect Core 1.0,
     * 5.1. Standard Claim](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) should
     * be supported. The following is the list of standard claims.
     * 
     * <p>- `sub`
     * - `name`
     * - `given_name`
     * - `family_name`
     * - `middle_name`
     * - `nickname`
     * - `preferred_username`
     * - `profile`
     * - `picture`
     * - `website`
     * - `email`
     * - `email_verified`
     * - `gender`
     * - `birthdate`
     * - `zoneinfo`
     * - `locale`
     * - `phone_number`
     * - `phone_number_verified`
     * - `address`
     * - `updated_at`
     * 
     * <p>The value of this property is used as `claims_supported` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     * 
     * <p>The service may support its original claim names. See [OpenID Connect Core 1.0, 5.1.2. Additional
     * Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims).
     */
    public Optional<List<String>> supportedClaims() {
        return Optional.ofNullable(this.supportedClaims);
    }

    /**
     * The flag indicating whether claims specified by shortcut scopes (e.g. `profile`) are included
     * in the issued ID token only when no access token is issued.
     * 
     * <p>To strictly conform to the description below excerpted from [OpenID Connect Core 1.0 Section
     * 5.4](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims), this flag has to be `true`.
     * 
     * <p>&gt; The Claims requested by the profile, email, address, and phone scope values are returned from
     * the UserInfo Endpoint, as described in Section 5.3.2, when a response_type value is used that
     * results in an Access Token being issued. However, when no Access Token is issued (which is the
     * case for the response_type value id_token), the resulting Claims are returned in the ID Token.
     */
    public Optional<Boolean> claimShortcutRestrictive() {
        return Optional.ofNullable(this.claimShortcutRestrictive);
    }

    /**
     * The URL of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document. For
     * example, `http://example.com/auth/jwks`.
     * 
     * <p>Client applications accesses this URL (1) to get the public key of the service to validate the
     * signature of an ID token issued by the service and (2) to get the public key of the service to
     * encrypt an request object of the client application. See [OpenID Connect Core 1.0, 10. Signatures
     * and Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
     * 
     * <p>The value of this property is used as `jwks_uri` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<String> jwksUri() {
        return Optional.ofNullable(this.jwksUri);
    }

    /**
     * 'The flag to indicate whether the direct jwks endpoint is enabled or not. The path of the endpoint
     * is `/api/service/jwks/get/direct/service-api-key`. '
     */
    public Optional<Boolean> directJwksEndpointEnabled() {
        return Optional.ofNullable(this.directJwksEndpointEnabled);
    }

    /**
     * The content of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document.
     * 
     * <p>If this property is not `null` in a `/service/create` request or a `/service/update` request,
     * Authlete hosts the content in the database. This property must not be `null` and must contain
     * pairs of public/private keys if the service wants to support asymmetric signatures for ID tokens
     * and asymmetric encryption for request objects. See [OpenID Connect Core 1.0, 10. Signatures and
     * Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
     */
    public Optional<String> jwks() {
        return Optional.ofNullable(this.jwks);
    }

    /**
     * The key ID to identify a JWK used for ID token signature using an asymmetric key.
     * 
     * <p>A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
     * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
     * to pick up one JWK for signature from the JWK Set when it generates an ID token and signature
     * using an asymmetric key is required. Authlete Server searches the registered JWK Set for a JWK
     * which satisfies conditions for ID token signature. If the number of JWK candidates which satisfy
     * the conditions is 1, there is no problem. On the other hand, if there exist multiple candidates,
     * a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5) is needed to be specified so that
     * Authlete Server can pick up one JWK from among the JWK candidates.
     * 
     * <p>This `idTokenSignatureKeyId` property exists for the purpose described above. For key rotation
     * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
     * this mechanism is needed.
     */
    public Optional<String> idTokenSignatureKeyId() {
        return Optional.ofNullable(this.idTokenSignatureKeyId);
    }

    /**
     * The key ID to identify a JWK used for user info signature using an asymmetric key.
     * 
     * <p>A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
     * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
     * to pick up one JWK for signature from the JWK Set when it is required to sign user info (which
     * is returned from [userinfo endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo))
     * using an asymmetric key. Authlete Server searches the registered JWK Set for a JWK which satisfies
     * conditions for user info signature. If the number of JWK candidates which satisfy the conditions
     * is 1, there is no problem. On the other hand, if there exist multiple candidates, a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5)
     * is needed to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
     * 
     * <p>This `userInfoSignatureKeyId` property exists for the purpose described above. For key rotation
     * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
     * this mechanism is needed.
     */
    public Optional<String> userInfoSignatureKeyId() {
        return Optional.ofNullable(this.userInfoSignatureKeyId);
    }

    /**
     * The key ID to identify a JWK used for signing authorization responses using an asymmetric key.
     * 
     * <p>[Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
     * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
     * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
     * from the authorization endpoint will be packed into a JWT. This property is used to compute the
     * value of the `exp` claim of the JWT.
     * 
     * <p>Authlete Server searches the JWK Set for a JWK which satisfies conditions for authorization response
     * signature. If the number of JWK candidates which satisfy the conditions is 1, there is no problem.
     * On the other hand, if there exist multiple candidates, a Key ID is needed to be specified so that
     * Authlete Server can pick up one JWK from among the JWK candidates. This property exists to specify
     * the key ID.
     */
    public Optional<String> authorizationSignatureKeyId() {
        return Optional.ofNullable(this.authorizationSignatureKeyId);
    }

    /**
     * The [user info endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo) of the
     * service. A URL that starts with `https://`. For example, `https://example.com/auth/userinfo`.
     * 
     * <p>The value of this property is used as `userinfo_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<String> userInfoEndpoint() {
        return Optional.ofNullable(this.userInfoEndpoint);
    }

    /**
     * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path
     * of the endpoint is `/api/auth/userinfo/direct/service-api-key`.
     */
    public Optional<Boolean> directUserInfoEndpointEnabled() {
        return Optional.ofNullable(this.directUserInfoEndpointEnabled);
    }

    /**
     * The boolean flag which indicates whether the [OAuth 2.0 Dynamic Client Registration Protocol](https://tools.ietf.org/html/rfc7591)
     * is supported.
     */
    public Optional<Boolean> dynamicRegistrationSupported() {
        return Optional.ofNullable(this.dynamicRegistrationSupported);
    }

    /**
     * The [registration endpoint](http://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration)
     * of the service. A URL that starts with `https://`. For example, `https://example.com/auth/registration`.
     * 
     * <p>The value of this property is used as `registration_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<String> registrationEndpoint() {
        return Optional.ofNullable(this.registrationEndpoint);
    }

    /**
     * The URI of the registration management endpoint. If dynamic client registration is supported,
     * and this is set, this URI will be used as the basis of the client's management endpoint by appending
     * `/clientid}/` to it as a path element. If this is unset, the value of `registrationEndpoint` will
     * be used as the URI base instead.
     */
    public Optional<String> registrationManagementEndpoint() {
        return Optional.ofNullable(this.registrationManagementEndpoint);
    }

    /**
     * The URL of the "Policy" of the service.
     * 
     * <p>The value of this property is used as `op_policy_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<String> policyUri() {
        return Optional.ofNullable(this.policyUri);
    }

    /**
     * The URL of the "Terms Of Service" of the service.
     * 
     * <p>The value of this property is used as `op_tos_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<String> tosUri() {
        return Optional.ofNullable(this.tosUri);
    }

    /**
     * The URL of a page where documents for developers can be found.
     * 
     * <p>The value of this property is used as `service_documentation` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<String> serviceDocumentation() {
        return Optional.ofNullable(this.serviceDocumentation);
    }

    /**
     * The URI of backchannel authentication endpoint, which is defined in the specification of [CIBA
     * (Client Initiated Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
     */
    public Optional<String> backchannelAuthenticationEndpoint() {
        return Optional.ofNullable(this.backchannelAuthenticationEndpoint);
    }

    /**
     * The supported backchannel token delivery modes. This property corresponds to the `backchannel_token_delivery_modes_supported`
     * metadata.
     * 
     * <p>Backchannel token delivery modes are defined in the specification of [CIBA (Client Initiated
     * Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
     */
    public Optional<List<ServiceUpdateApiSupportedBackchannelTokenDeliveryModeRequest>> supportedBackchannelTokenDeliveryModes() {
        return Optional.ofNullable(this.supportedBackchannelTokenDeliveryModes);
    }

    /**
     * The duration of backchannel authentication request IDs issued from the backchannel authentication
     * endpoint in seconds. This is used as the value of the `expires_in` property in responses from
     * the backchannel authentication endpoint.
     */
    public Optional<Integer> backchannelAuthReqIdDuration() {
        return Optional.ofNullable(this.backchannelAuthReqIdDuration);
    }

    /**
     * The minimum interval between polling requests to the token endpoint from client applications in
     * seconds. This is used as the value of the `interval` property in responses from the backchannel
     * authentication endpoint.
     */
    public Optional<Integer> backchannelPollingInterval() {
        return Optional.ofNullable(this.backchannelPollingInterval);
    }

    /**
     * The boolean flag which indicates whether the `user_code` request parameter is supported at the
     * backchannel authentication endpoint. This property corresponds to the `backchannel_user_code_parameter_supported`
     * metadata.
     */
    public Optional<Boolean> backchannelUserCodeParameterSupported() {
        return Optional.ofNullable(this.backchannelUserCodeParameterSupported);
    }

    /**
     * The flag to indicate whether the `binding_message` request parameter is always required whenever
     * a backchannel authentication request is judged as a request for Financial-grade API.
     * 
     * <p>The FAPI-CIBA profile requires that the authorization server _"shall ensure unique authorization
     * context exists in the authorization request or require a `binding_message` in the authorization
     * request"_ (FAPI-CIBA, 5.2.2, 2). The simplest way to fulfill this requirement is to set this property
     * to `true`.
     * 
     * <p>If this property is set to `false`, the `binding_message` request parameter remains optional
     * even in FAPI context, but in exchange, your authorization server must implement a custom mechanism
     * that ensures each backchannel authentication request has unique context.
     */
    public Optional<Boolean> backchannelBindingMessageRequiredInFapi() {
        return Optional.ofNullable(this.backchannelBindingMessageRequiredInFapi);
    }

    /**
     * The URI of the device authorization endpoint.
     * 
     * <p>Device authorization endpoint is defined in the specification of OAuth 2.0 Device Authorization Grant.
     */
    public Optional<String> deviceAuthorizationEndpoint() {
        return Optional.ofNullable(this.deviceAuthorizationEndpoint);
    }

    /**
     * The verification URI for the device flow. This URI is used as the value of the `verification_uri`
     * parameter in responses from the device authorization endpoint.
     */
    public Optional<String> deviceVerificationUri() {
        return Optional.ofNullable(this.deviceVerificationUri);
    }

    /**
     * The verification URI for the device flow with a placeholder for a user code. This URI is used
     * to build the value of the `verification_uri_complete` parameter in responses from the device
     * authorization endpoint.
     * 
     * <p>It is expected that the URI contains a fixed string `USER_CODE` somewhere as a placeholder for
     * a user code. For example, like the following.
     * 
     * <p>`https://example.com/device?user\_code=USER\_CODE`
     * 
     * <p>The fixed string is replaced with an actual user code when Authlete builds a verification URI
     * with a user code for the `verification_uri_complete` parameter.
     * 
     * <p>If this URI is not set, the `verification_uri_complete` parameter won't appear in device authorization
     * responses.
     */
    public Optional<String> deviceVerificationUriComplete() {
        return Optional.ofNullable(this.deviceVerificationUriComplete);
    }

    /**
     * The duration of device verification codes and end-user verification codes issued from the device
     * authorization endpoint in seconds. This is used as the value of the `expires_in` property in responses
     * from the device authorization endpoint.
     */
    public Optional<Integer> deviceFlowCodeDuration() {
        return Optional.ofNullable(this.deviceFlowCodeDuration);
    }

    /**
     * The minimum interval between polling requests to the token endpoint from client applications in
     * seconds in device flow. This is used as the value of the `interval` property in responses from
     * the device authorization endpoint.
     */
    public Optional<Integer> deviceFlowPollingInterval() {
        return Optional.ofNullable(this.deviceFlowPollingInterval);
    }

    /**
     * The character set for end-user verification codes (`user_code`) for Device Flow.
     */
    public Optional<ServiceUpdateApiUserCodeCharsetRequest> userCodeCharset() {
        return Optional.ofNullable(this.userCodeCharset);
    }

    /**
     * The length of end-user verification codes (`user_code`) for Device Flow.
     */
    public Optional<Integer> userCodeLength() {
        return Optional.ofNullable(this.userCodeLength);
    }

    /**
     * Trust frameworks supported by this service. This corresponds to the `trust_frameworks_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    public Optional<List<String>> supportedTrustFrameworks() {
        return Optional.ofNullable(this.supportedTrustFrameworks);
    }

    /**
     * Evidence supported by this service. This corresponds to the `evidence_supported` [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    public Optional<List<String>> supportedEvidence() {
        return Optional.ofNullable(this.supportedEvidence);
    }

    /**
     * Identity documents supported by this service. This corresponds to the `id_documents_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    public Optional<List<String>> supportedIdentityDocuments() {
        return Optional.ofNullable(this.supportedIdentityDocuments);
    }

    /**
     * Verification methods supported by this service. This corresponds to the `id_documents_verification_methods_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    public Optional<List<String>> supportedVerificationMethods() {
        return Optional.ofNullable(this.supportedVerificationMethods);
    }

    /**
     * Verified claims supported by this service. This corresponds to the `claims_in_verified_claims_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    public Optional<List<String>> supportedVerifiedClaims() {
        return Optional.ofNullable(this.supportedVerifiedClaims);
    }

    /**
     * OIDC4IDA / verifiedClaimsValidationSchemaSet
     */
    public Optional<ServiceUpdateApiVerifiedClaimsValidationSchemaSetRequest> verifiedClaimsValidationSchemaSet() {
        return Optional.ofNullable(this.verifiedClaimsValidationSchemaSet);
    }

    /**
     * The attributes of this service.
     */
    public Optional<List<ServiceUpdateApiAttributeRequest>> attributes() {
        return Optional.ofNullable(this.attributes);
    }

    /**
     * The flag indicating whether the nbf claim in the request object is optional even when the authorization
     * request is regarded as a FAPI-Part2 request.
     * 
     * <p>The final version of Financial-grade API was approved in January, 2021. The Part 2 of the final
     * version has new requirements on lifetime of request objects. They require that request objects
     * contain an `nbf` claim and the lifetime computed by `exp` - `nbf` be no longer than 60 minutes.
     * 
     * <p>Therefore, when an authorization request is regarded as a FAPI-Part2 request, the request object
     * used in the authorization request must contain an nbf claim. Otherwise, the authorization server
     * rejects the authorization request.
     * 
     * <p>When this flag is `true`, the `nbf` claim is treated as an optional claim even when the authorization
     * request is regarded as a FAPI-Part2 request. That is, the authorization server does not perform
     * the validation on lifetime of the request object.
     * 
     * <p>Skipping the validation is a violation of the FAPI specification. The reason why this flag has
     * been prepared nevertheless is that the new requirements (which do not exist in the Implementer's
     * Draft 2 released in October, 2018) have big impacts on deployed implementations of client
     * applications and Authlete thinks there should be a mechanism whereby to make the migration
     * from ID2 to Final smooth without breaking live systems.
     */
    public Optional<Boolean> nbfOptional() {
        return Optional.ofNullable(this.nbfOptional);
    }

    /**
     * The flag indicating whether generation of the iss response parameter is suppressed.
     * 
     * <p>"OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response" has defined a new
     * authorization response parameter, `iss`, as a countermeasure for a certain type of mix-up attacks.
     * 
     * <p>The specification requires that the `iss` response parameter always be included in authorization
     * responses unless JARM (JWT Secured Authorization Response Mode) is used.
     * 
     * <p>When this flag is `true`, the authorization server does not include the `iss` response parameter
     * in authorization responses. By turning this flag on and off, developers of client applications
     * can experiment the mix-up attack and the effect of the `iss` response parameter.
     * 
     * <p>Note that this flag should not be `true` in production environment unless there are special
     * reasons for it.
     */
    public Optional<Boolean> issSuppressed() {
        return Optional.ofNullable(this.issSuppressed);
    }

    /**
     * custom client metadata supported by this service.
     * 
     * <p>Standard specifications define client metadata as necessary. The following are such examples.
     * 
     * <p>* [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
     * * [RFC 7591 OAuth 2.0 Dynamic Client Registration Protocol](https://www.rfc-editor.org/rfc/rfc7591.html)
     * * [RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens](https://www.rfc-editor.org/rfc/rfc8705.html)
     * * [OpenID Connect Client-Initiated Backchannel Authentication Flow - Core 1.0](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html)
     * * [The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-jwsreq/)
     * * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
     * * [OAuth 2.0 Pushed Authorization Requests (PAR)](https://datatracker.ietf.org/doc/rfc9126/)
     * * [OAuth 2.0 Rich Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/)
     * 
     * <p>Standard client metadata included in Client Registration Request and Client Update Request (cf.
     * [OIDC DynReg](https://openid.net/specs/openid-connect-registration-1_0.html), [RFC 7591](https://www.rfc-editor.org/rfc/rfc7591.html)
     * and [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)) are, if supported by Authlete, stored
     * into Authlete database. On the other hand, unrecognized client metadata are discarded.
     * 
     * <p>By listing up custom client metadata in advance by using this property (`supportedCustomClientMetadata`),
     * Authlete can recognize them and stores their values into the database. The stored custom client
     * metadata values can be referenced by `customMetadata`.
     */
    public Optional<List<String>> supportedCustomClientMetadata() {
        return Optional.ofNullable(this.supportedCustomClientMetadata);
    }

    /**
     * The flag indicating whether the expiration date of an access token never exceeds that of the
     * corresponding refresh token.
     * 
     * <p>When a new access token is issued by a refresh token request (= a token request with `grant_type=refresh_token`),
     * the expiration date of the access token may exceed the expiration date of the corresponding
     * refresh token. This behavior itself is not wrong and may happen when `refreshTokenKept` is
     * `true` and/or when `refreshTokenDurationKept` is `true`.
     * 
     * <p>When this flag is `true`, the expiration date of an access token never exceeds that of the corresponding
     * refresh token regardless of the calculated duration based on other settings such as `accessTokenDuration`,
     * `accessTokenDuration` in `extension` and `access_token.duration` scope attribute.
     * 
     * <p>It is technically possible to set a value which is bigger than the duration of refresh tokens
     * as the duration of access tokens although it is strange. In the case, the duration of an access
     * token becomes longer than the duration of the refresh token which is issued together with the
     * access token. Even if the duration values are configured so, if this flag is `true`, the expiration
     * date of the access token does not exceed that of the refresh token. That is, the duration of
     * the access token will be shortened, and as a result, the access token and the refresh token
     * will have the same expiration date.
     */
    public Optional<Boolean> tokenExpirationLinked() {
        return Optional.ofNullable(this.tokenExpirationLinked);
    }

    /**
     * The flag indicating whether encryption of request object is required when the request object
     * is passed through the front channel.
     * 
     * <p>This flag does not affect the processing of request objects at the Pushed Authorization Request
     * Endpoint, which is defined in [OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/).
     * Unecrypted request objects are accepted at the endpoint even if this flag is `true`.
     * 
     * <p>This flag does not indicate whether a request object is always required. There is a different
     * flag, `requestObjectRequired`, for the purpose. See the description of `requestObjectRequired`
     * for details.
     * 
     * <p>Even if this flag is `false`, encryption of request object is required if the `frontChannelRequestObjectEncryptionRequired`
     * flag of the client is `true`.
     */
    public Optional<Boolean> frontChannelRequestObjectEncryptionRequired() {
        return Optional.ofNullable(this.frontChannelRequestObjectEncryptionRequired);
    }

    /**
     * The flag indicating whether the JWE alg of encrypted request object must match the `request_object_encryption_alg`
     * client metadata of the client that has sent the request object.
     * 
     * <p>The request_object_encryption_alg client metadata itself is defined in [OpenID Connect Dynamic
     * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
     * 
     * <p>&gt; request_object_encryption_alg
     * &gt;
     * &gt; OPTIONAL. JWE [JWE] alg algorithm [JWA] the RP is declaring that it may use for encrypting
     * Request Objects sent to the OP. This parameter SHOULD be included when symmetric encryption
     * will be used, since this signals to the OP that a client_secret value needs to be returned
     * from which the symmetric key will be derived, that might not otherwise be returned. The RP
     * MAY still use other supported encryption algorithms or send unencrypted Request Objects, even
     * when this parameter is present. If both signing and encryption are requested, the Request Object
     * will be signed then encrypted, with the result being a Nested JWT, as defined in [JWT]. The
     * default, if omitted, is that the RP is not declaring whether it might encrypt any Request Objects.
     * 
     * <p>The point here is "The RP MAY still use other supported encryption algorithms or send unencrypted
     * Request Objects, even when this parameter is present."
     * 
     * <p>The Client's property that represents the client metadata is `requestEncryptionAlg`. See the
     * description of `requestEncryptionAlg` for details.
     * 
     * <p>Even if this flag is `false`, the match is required if the `requestObjectEncryptionAlgMatchRequired`
     * flag of the client is `true`.
     */
    public Optional<Boolean> requestObjectEncryptionAlgMatchRequired() {
        return Optional.ofNullable(this.requestObjectEncryptionAlgMatchRequired);
    }

    /**
     * The flag indicating whether the JWE `enc` of encrypted request object must match the `request_object_encryption_enc`
     * client metadata of the client that has sent the request object.
     * 
     * <p>The `request_object_encryption_enc` client metadata itself is defined in [OpenID Connect Dynamic
     * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
     * 
     * <p>&gt; request_object_encryption_enc
     * &gt;
     * &gt; OPTIONAL. JWE enc algorithm [JWA] the RP is declaring that it may use for encrypting Request
     * Objects sent to the OP. If request_object_encryption_alg is specified, the default for this
     * value is A128CBC-HS256. When request_object_encryption_enc is included, request_object_encryption_alg
     * MUST also be provided.
     * 
     * <p>The Client's property that represents the client metadata is `requestEncryptionEnc`. See the
     * description of `requestEncryptionEnc` for details.
     * 
     * <p>Even if this flag is false, the match is required if the `requestObjectEncryptionEncMatchRequired`
     * flag is `true`.
     */
    public Optional<Boolean> requestObjectEncryptionEncMatchRequired() {
        return Optional.ofNullable(this.requestObjectEncryptionEncMatchRequired);
    }

    /**
     * The flag indicating whether HSM (Hardware Security Module) support is enabled for this service.
     * 
     * <p>When this flag is `false`, keys managed in HSMs are not used even if they exist. In addition,
     * `/api/hsk/*` APIs reject all requests.
     * 
     * <p>Even if this flag is `true`, HSM-related features do not work if the configuration of the Authlete
     * server you are using does not support HSM.
     */
    public Optional<Boolean> hsmEnabled() {
        return Optional.ofNullable(this.hsmEnabled);
    }

    /**
     * The information about keys managed on HSMs (Hardware Security Modules).
     * 
     * <p>This `hsks` property is output only, meaning that `hsks` in requests to `/api/service/create`
     * API and `/api/service/update` API do not have any effect. The contents of this property is controlled
     * only by `/api/hsk/*` APIs.
     */
    public Optional<List<ServiceUpdateApiHskRequest>> hsks() {
        return Optional.ofNullable(this.hsks);
    }

    /**
     * The URL of the grant management endpoint.
     */
    public Optional<String> grantManagementEndpoint() {
        return Optional.ofNullable(this.grantManagementEndpoint);
    }

    /**
     * The flag indicating whether every authorization request (and any request serving as an authorization
     * request such as CIBA backchannel authentication request and device authorization request) must
     * include the `grant_management_action` request parameter.
     * 
     * <p>This property corresponds to the `grant_management_action_required` server metadata defined
     * in [Grant Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html).
     * 
     * <p>Note that setting true to this property will result in blocking all public clients because
     * the specification requires that grant management be usable only by confidential clients for
     * security reasons.
     */
    public Optional<Boolean> grantManagementActionRequired() {
        return Optional.ofNullable(this.grantManagementActionRequired);
    }

    /**
     * The flag indicating whether Authlete's `/api/client/registration` API uses `UNAUTHORIZED` as
     * a value of the `action` response parameter when appropriate.
     * 
     * <p>The `UNAUTHORIZED` enum value was initially not defined as a possible value of the `action`
     * parameter in an `/api/client/registration` API response. This means that implementations of
     * client `configuration` endpoint were not able to conform to [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)
     * strictly.
     * 
     * <p>For backward compatibility (to avoid breaking running systems), Authlete's `/api/client/registration`
     * API does not return the `UNAUTHORIZED` enum value if this flag is not turned on.
     * 
     * <p>The steps an existing implementation of client configuration endpoint has to do in order to
     * conform to the requirement related to "401 Unauthorized" are as follows.
     * 
     * <p>1. Update the Authlete library (e.g. authlete-java-common) your system is using.
     * 2. Update your implementation of client configuration endpoint so that it can handle the
     * `UNAUTHORIZED` action.
     * 3. Turn on this `unauthorizedOnClientConfigSupported` flag.
     */
    public Optional<Boolean> unauthorizedOnClientConfigSupported() {
        return Optional.ofNullable(this.unauthorizedOnClientConfigSupported);
    }

    /**
     * The flag indicating whether the `scope` request parameter in dynamic client registration and
     * update requests (RFC 7591 and RFC 7592) is used as scopes that the client can request.
     * 
     * <p>Limiting the range of scopes that a client can request is achieved by listing scopes in the
     * `client.extension.requestableScopes` property and setting the `client.extension.requestableScopesEnabled`
     * property to `true`. This feature is called "requestable scopes".
     * 
     * <p>This property affects behaviors of `/api/client/registration` and other family APIs.
     */
    public Optional<Boolean> dcrScopeUsedAsRequestable() {
        return Optional.ofNullable(this.dcrScopeUsedAsRequestable);
    }

    /**
     * The endpoint for clients ending the sessions.
     * 
     * <p>A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/endSession`.
     * 
     * <p>The value of this property is used as `end_session_endpoint` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public Optional<String> endSessionEndpoint() {
        return Optional.ofNullable(this.endSessionEndpoint);
    }

    /**
     * The flag indicating whether the port number component of redirection URIs can be variable when
     * the host component indicates loopback.
     * 
     * <p>When this flag is `true`, if the host component of a redirection URI specified in an authorization
     * request indicates loopback (to be precise, when the host component is localhost, `127.0.0.1`
     * or `::1`), the port number component is ignored when the specified redirection URI is compared
     * to pre-registered ones. This behavior is described in [7.3. Loopback Interface Redirection](
     * https://www.rfc-editor.org/rfc/rfc8252.html#section-7.3) of [RFC 8252 OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8252.html)
     * for Native Apps.
     * 
     * <p>[3.1.2.3. Dynamic Configuration](https://www.rfc-editor.org/rfc/rfc6749.html#section-3.1.2.3)
     * of [RFC 6749](https://www.rfc-editor.org/rfc/rfc6749.html) states _"If the client registration
     * included the full redirection URI, the authorization server MUST compare the two URIs using
     * simple string comparison as defined in [RFC3986] Section 6.2.1."_ Also, the description of
     * `redirect_uri` in [3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest)
     * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) states
     * _"This URI MUST exactly match one of the Redirection URI values for the Client pre-registered
     * at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [RFC3986]
     * (**Simple String Comparison**)."_ These "Simple String Comparison" requirements are preceded
     * by this flag. That is, even when the conditions described in RFC 6749 and OpenID Connect Core 1.0
     * are satisfied, the port number component of loopback redirection URIs can be variable when this
     * flag is `true`.
     * 
     * <p>[8.3. Loopback Redirect Considerations](https://www.rfc-editor.org/rfc/rfc8252.html#section-8.3)
     * of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) states as follows.
     * 
     * <p>&gt; While redirect URIs using localhost (i.e., `"http://localhost:{port}/{path}"`) function
     * similarly to loopback IP redirects described in Section 7.3, the use of localhost is NOT RECOMMENDED.
     * Specifying a redirect URI with the loopback IP literal rather than localhost avoids inadvertently
     * listening on network interfaces other than the loopback interface. It is also less susceptible
     * to client-side firewalls and misconfigured host name resolution on the user's device.
     * 
     * <p>However, Authlete allows the port number component to be variable in the case of `localhost`,
     * too. It is left to client applications whether they use `localhost` or a literal loopback IP
     * address (`127.0.0.1` for IPv4 or `::1` for IPv6).
     * 
     * <p>Section 7.3 and Section 8.3 of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) state
     * that loopback redirection URIs use the `"http"` scheme, but Authlete allows the port number
     * component to be variable in other cases (e.g. in the case of the `"https"` scheme), too.
     */
    public Optional<Boolean> loopbackRedirectionUriVariable() {
        return Optional.ofNullable(this.loopbackRedirectionUriVariable);
    }

    /**
     * The flag indicating whether Authlete checks whether the `aud` claim of request objects matches
     * the issuer identifier of this service.
     * 
     * <p>[Section 6.1. Passing a Request Object by Value](https://openid.net/specs/openid-connect-core-1_0.html#JWTRequests)
     * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) has the following
     * statement.
     * 
     * <p>&gt; The `aud` value SHOULD be or include the OP's Issuer Identifier URL.
     * 
     * <p>Likewise, [Section 4. Request Object](https://www.rfc-editor.org/rfc/rfc9101.html#section-4) of
     * [RFC 9101](https://www.rfc-editor.org/rfc/rfc9101.html) (The OAuth 2.0 Authorization Framework:
     * JWT-Secured Authorization Request (JAR)) has the following statement.
     * 
     * <p>&gt; The value of aud should be the value of the authorization server (AS) issuer, as defined in
     * [RFC 8414](https://www.rfc-editor.org/rfc/rfc8414.html).
     * 
     * <p>As excerpted above, validation on the `aud` claim of request objects is optional. However, if
     * this flag is turned on, Authlete checks whether the `aud` claim of request objects matches the issuer
     * identifier of this service and raises an error if they are different.
     */
    public Optional<Boolean> requestObjectAudienceChecked() {
        return Optional.ofNullable(this.requestObjectAudienceChecked);
    }

    /**
     * The flag indicating whether Authlete generates access tokens for
     * external attachments and embeds them in ID tokens and userinfo
     * responses.
     */
    public Optional<Boolean> accessTokenForExternalAttachmentEmbedded() {
        return Optional.ofNullable(this.accessTokenForExternalAttachmentEmbedded);
    }

    /**
     * Identifiers of entities that can issue entity statements for this
     * service. This property corresponds to the `authority_hints`
     * property that appears in a self-signed entity statement that is
     * defined in OpenID Connect Federation 1.0.
     */
    public Optional<List<String>> authorityHints() {
        return Optional.ofNullable(this.authorityHints);
    }

    /**
     * flag indicating whether this service supports OpenID Connect Federation 1
     */
    public Optional<Boolean> federationEnabled() {
        return Optional.ofNullable(this.federationEnabled);
    }

    /**
     * JWK Set document containing keys that are used to sign (1) self-signed
     * entity statement of this service and (2) the response from
     * `signed_jwks_uri`.
     */
    public Optional<String> federationJwks() {
        return Optional.ofNullable(this.federationJwks);
    }

    /**
     * A key ID to identify a JWK used to sign the entity configuration and
     * the signed JWK Set.
     */
    public Optional<String> federationSignatureKeyId() {
        return Optional.ofNullable(this.federationSignatureKeyId);
    }

    /**
     * The duration of the entity configuration in seconds.
     */
    public Optional<Long> federationConfigurationDuration() {
        return Optional.ofNullable(this.federationConfigurationDuration);
    }

    /**
     * The URI of the federation registration endpoint. This property corresponds
     * to the `federation_registration_endpoint` server metadata that is
     * defined in OpenID Connect Federation 1.0.
     */
    public Optional<String> federationRegistrationEndpoint() {
        return Optional.ofNullable(this.federationRegistrationEndpoint);
    }

    /**
     * The human-readable name representing the organization that operates
     * this service. This property corresponds to the `organization_name`
     * server metadata that is defined in OpenID Connect Federation 1.0.
     */
    public Optional<String> organizationName() {
        return Optional.ofNullable(this.organizationName);
    }

    /**
     * The transformed claims predefined by this service in JSON format.
     * This property corresponds to the `transformed_claims_predefined`
     * server metadata.
     */
    public Optional<String> predefinedTransformedClaims() {
        return Optional.ofNullable(this.predefinedTransformedClaims);
    }

    /**
     * flag indicating whether refresh token requests with the same
     * refresh token can be made multiple times in quick succession and
     * they can obtain the same renewed refresh token within the short
     * period.
     */
    public Optional<Boolean> refreshTokenIdempotent() {
        return Optional.ofNullable(this.refreshTokenIdempotent);
    }

    /**
     * The URI of the endpoint that returns this service's JWK Set document in
     * the JWT format. This property corresponds to the `signed_jwks_uri`
     * server metadata defined in OpenID Connect Federation 1.0.
     */
    public Optional<String> signedJwksUri() {
        return Optional.ofNullable(this.signedJwksUri);
    }

    /**
     * Supported attachment types. This property corresponds to the {@code
     * attachments_supported} server metadata which was added by the third
     * implementer's draft of OpenID Connect for Identity Assurance 1.0.
     */
    public Optional<List<ServiceUpdateApiSupportedAttachmentRequest>> supportedAttachments() {
        return Optional.ofNullable(this.supportedAttachments);
    }

    /**
     * Supported algorithms used to compute digest values of external
     * attachments. This property corresponds to the
     * `digest_algorithms_supported` server metadata which was added
     * by the third implementer's draft of OpenID Connect for Identity
     * Assurance 1.0.
     */
    public Optional<List<String>> supportedDigestAlgorithms() {
        return Optional.ofNullable(this.supportedDigestAlgorithms);
    }

    /**
     * Document types supported by this service. This property corresponds
     * to the `documents_supported` server metadata.
     */
    public Optional<List<String>> supportedDocuments() {
        return Optional.ofNullable(this.supportedDocuments);
    }

    /**
     * validation and verification processes supported by this service.
     * This property corresponds to the `documents_methods_supported`
     * server metadata.
     * 
     * <p>The third implementer's draft of [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     * renamed the
     * `id_documents_verification_methods_supported` server metadata to
     * `documents_methods_supported`.
     */
    public Optional<List<String>> supportedDocumentsMethods() {
        return Optional.ofNullable(this.supportedDocumentsMethods);
    }

    /**
     * Document validation methods supported by this service. This property
     * corresponds to the `documents_validation_methods_supported` server
     * metadata which was added by the third implementer's draft of &lt;a href=
     * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     */
    public Optional<List<String>> supportedDocumentsValidationMethods() {
        return Optional.ofNullable(this.supportedDocumentsValidationMethods);
    }

    /**
     * Document verification methods supported by this service. This property
     * corresponds to the `documents_verification_methods_supported` server
     * metadata which was added by the third implementer's draft of
     * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     */
    public Optional<List<String>> supportedDocumentsVerificationMethods() {
        return Optional.ofNullable(this.supportedDocumentsVerificationMethods);
    }

    /**
     * Electronic record types supported by this service. This property
     * corresponds to the `electronic_records_supported` server metadata
     * which was added by the third implementer's draft of
     * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     */
    public Optional<List<String>> supportedElectronicRecords() {
        return Optional.ofNullable(this.supportedElectronicRecords);
    }

    public Optional<List<ServiceUpdateApiSupportedClientRegistrationTypeRequest>> supportedClientRegistrationTypes() {
        return Optional.ofNullable(this.supportedClientRegistrationTypes);
    }

    /**
     * The flag indicating whether to prohibit unidentifiable clients from
     * making token exchange requests.
     */
    public Optional<Boolean> tokenExchangeByIdentifiableClientsOnly() {
        return Optional.ofNullable(this.tokenExchangeByIdentifiableClientsOnly);
    }

    /**
     * The flag indicating whether to prohibit public clients from making
     * token exchange requests.
     */
    public Optional<Boolean> tokenExchangeByConfidentialClientsOnly() {
        return Optional.ofNullable(this.tokenExchangeByConfidentialClientsOnly);
    }

    /**
     * The flag indicating whether to prohibit clients that have no explicit
     * permission from making token exchange requests.
     */
    public Optional<Boolean> tokenExchangeByPermittedClientsOnly() {
        return Optional.ofNullable(this.tokenExchangeByPermittedClientsOnly);
    }

    /**
     * The flag indicating whether to reject token exchange requests which
     * use encrypted JWTs as input tokens.
     */
    public Optional<Boolean> tokenExchangeEncryptedJwtRejected() {
        return Optional.ofNullable(this.tokenExchangeEncryptedJwtRejected);
    }

    /**
     * The flag indicating whether to reject token exchange requests which
     * use unsigned JWTs as input tokens.
     */
    public Optional<Boolean> tokenExchangeUnsignedJwtRejected() {
        return Optional.ofNullable(this.tokenExchangeUnsignedJwtRejected);
    }

    /**
     * The flag indicating whether to prohibit unidentifiable clients from
     * using the grant type "urn:ietf:params:oauth:grant-type:jwt-bearer".
     */
    public Optional<Boolean> jwtGrantByIdentifiableClientsOnly() {
        return Optional.ofNullable(this.jwtGrantByIdentifiableClientsOnly);
    }

    /**
     * The flag indicating whether to reject token requests that use an
     * encrypted JWT as an authorization grant with the grant type
     * "urn:ietf:params:oauth:grant-type:jwt-bearer".
     */
    public Optional<Boolean> jwtGrantEncryptedJwtRejected() {
        return Optional.ofNullable(this.jwtGrantEncryptedJwtRejected);
    }

    /**
     * The flag indicating whether to reject token requests that use an
     * unsigned JWT as an authorization grant with the grant type
     * "urn:ietf:params:oauth:grant-type:jwt-bearer".
     */
    public Optional<Boolean> jwtGrantUnsignedJwtRejected() {
        return Optional.ofNullable(this.jwtGrantUnsignedJwtRejected);
    }

    /**
     * The flag indicating whether to block DCR (Dynamic Client Registration)
     * requests whose "software_id" has already been used previously.
     */
    public Optional<Boolean> dcrDuplicateSoftwareIdBlocked() {
        return Optional.ofNullable(this.dcrDuplicateSoftwareIdBlocked);
    }

    /**
     * The trust anchors that are referenced when this service resolves
     * trust chains of relying parties.
     * 
     * <p>If this property is empty, client registration fails regardless of
     * whether its type is `automatic` or `explicit`. It means
     * that OpenID Connect Federation 1.0 does not work.
     */
    public Optional<List<ServiceUpdateApiTrustAnchorRequest>> trustAnchors() {
        return Optional.ofNullable(this.trustAnchors);
    }

    /**
     * The flag indicating whether the openid scope should be dropped from
     * scopes list assigned to access token issued when a refresh token grant
     * is used.
     */
    public Optional<Boolean> openidDroppedOnRefreshWithoutOfflineAccess() {
        return Optional.ofNullable(this.openidDroppedOnRefreshWithoutOfflineAccess);
    }

    /**
     * Supported document check methods. This property corresponds to the `documents_check_methods_supported`
     * server metadata which was added by the fourth implementer's draft of OpenID Connect for Identity
     * Assurance 1.0.
     */
    public Optional<List<String>> supportedDocumentsCheckMethods() {
        return Optional.ofNullable(this.supportedDocumentsCheckMethods);
    }

    /**
     * The flag indicating whether this service signs responses from the resource server.
     */
    public Optional<Boolean> rsResponseSigned() {
        return Optional.ofNullable(this.rsResponseSigned);
    }

    /**
     * The duration of `c_nonce`.
     */
    public Optional<Long> cnonceDuration() {
        return Optional.ofNullable(this.cnonceDuration);
    }

    /**
     * Whether to require DPoP proof JWTs to include the `nonce` claim
     * whenever they are presented.
     */
    public Optional<Boolean> dpopNonceRequired() {
        return Optional.ofNullable(this.dpopNonceRequired);
    }

    /**
     * Get the flag indicating whether the feature of Verifiable Credentials
     * for this service is enabled or not.
     */
    public Optional<Boolean> verifiableCredentialsEnabled() {
        return Optional.ofNullable(this.verifiableCredentialsEnabled);
    }

    /**
     * The URL at which the JWK Set document of the credential issuer is
     * exposed.
     */
    public Optional<String> credentialJwksUri() {
        return Optional.ofNullable(this.credentialJwksUri);
    }

    /**
     * The default duration of credential offers in seconds.
     */
    public Optional<Long> credentialOfferDuration() {
        return Optional.ofNullable(this.credentialOfferDuration);
    }

    /**
     * The duration of nonce values for DPoP proof JWTs in seconds.
     */
    public Optional<Long> dpopNonceDuration() {
        return Optional.ofNullable(this.dpopNonceDuration);
    }

    /**
     * The flag indicating whether token requests using the pre-authorized
     * code grant flow by unidentifiable clients are allowed.
     */
    public Optional<Boolean> preAuthorizedGrantAnonymousAccessSupported() {
        return Optional.ofNullable(this.preAuthorizedGrantAnonymousAccessSupported);
    }

    /**
     * The duration of transaction ID in seconds that may be issued as a
     * result of a credential request or a batch credential request.
     */
    public Optional<Long> credentialTransactionDuration() {
        return Optional.ofNullable(this.credentialTransactionDuration);
    }

    /**
     * The key ID of the key for signing introspection responses.
     */
    public Optional<String> introspectionSignatureKeyId() {
        return Optional.ofNullable(this.introspectionSignatureKeyId);
    }

    /**
     * The key ID of the key for signing introspection responses.
     */
    public Optional<String> resourceSignatureKeyId() {
        return Optional.ofNullable(this.resourceSignatureKeyId);
    }

    /**
     * The default length of user PINs.
     */
    public Optional<Integer> userPinLength() {
        return Optional.ofNullable(this.userPinLength);
    }

    /**
     * The supported `prompt` values.
     */
    public Optional<List<ServiceUpdateApiSupportedPromptValueRequest>> supportedPromptValues() {
        return Optional.ofNullable(this.supportedPromptValues);
    }

    /**
     * The flag indicating whether to enable the feature of ID token
     * reissuance in the refresh token flow.
     */
    public Optional<Boolean> idTokenReissuable() {
        return Optional.ofNullable(this.idTokenReissuable);
    }

    /**
     * The JWK Set document containing private keys that are used to sign
     * verifiable credentials.
     */
    public Optional<String> credentialJwks() {
        return Optional.ofNullable(this.credentialJwks);
    }

    /**
     * FAPI modes for this service.
     * 
     * <p>When the value of this property is not `null`, Authlete always processes requests to this service based
     * on the specified FAPI modes if the FAPI feature is enabled in Authlete and the FAPI profile is supported
     * by this service.
     * 
     * <p>For instance, when this property is set to an array containing `FAPI1_ADVANCED` only, Authlete always
     * processes requests to this service based on "Financial-grade API Security Profile 1.0 - Part 2:
     * Advanced" if the FAPI feature is enabled in Authlete and the FAPI profile is supported by this service.
     */
    public Optional<List<ServiceUpdateApiFapiModeRequest>> fapiModes() {
        return Optional.ofNullable(this.fapiModes);
    }

    /**
     * The default duration of verifiable credentials in seconds.
     */
    public Optional<Long> credentialDuration() {
        return Optional.ofNullable(this.credentialDuration);
    }

    public Optional<ServiceUpdateApiCredentialIssuerMetadataRequest> credentialIssuerMetadata() {
        return Optional.ofNullable(this.credentialIssuerMetadata);
    }

    /**
     * The type of the `aud` claim in ID tokens.
     */
    public Optional<String> idTokenAudType() {
        return Optional.ofNullable(this.idTokenAudType);
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The name of this service.
     */
    public ServiceUpdateApiRequestBody withServiceName(@Nullable String serviceName) {
        this.serviceName = serviceName;
        return this;
    }


    /**
     * The issuer identifier of the service.
     * 
     * <p>A URL that starts with  https:// and has no query or fragment component.
     * 
     * <p>The value of this property is used as `iss` claim in an [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)
     * and `issuer` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withIssuer(@Nullable String issuer) {
        this.issuer = issuer;
        return this;
    }


    /**
     * The description about the service.
     */
    public ServiceUpdateApiRequestBody withDescription(@Nullable String description) {
        this.description = description;
        return this;
    }


    /**
     * Deprecated. Always `true`.
     */
    public ServiceUpdateApiRequestBody withClientIdAliasEnabled(@Nullable Boolean clientIdAliasEnabled) {
        this.clientIdAliasEnabled = clientIdAliasEnabled;
        return this;
    }


    /**
     * The `metadata` of the service. The content of the returned array depends on contexts.
     * The predefined service metadata is listed in the following table.
     * 
     * <p>  | Key | Description |
     *   | --- | --- |
     *   | `clientCount` | The number of client applications which belong to this service.  |
     */
    public ServiceUpdateApiRequestBody withMetadata(@Nullable List<ServiceUpdateApiMetadatumRequest> metadata) {
        this.metadata = metadata;
        return this;
    }


    /**
     * A Web API endpoint for user authentication which is to be prepared on the service side.
     * 
     * <p>The endpoint must be implemented if you do not implement the UI at the authorization endpoint
     * but use the one provided by Authlete.
     * 
     * <p>The user authentication at the authorization endpoint provided by Authlete is performed by making
     * a `POST` request to this endpoint.
     */
    public ServiceUpdateApiRequestBody withAuthenticationCallbackEndpoint(@Nullable String authenticationCallbackEndpoint) {
        this.authenticationCallbackEndpoint = authenticationCallbackEndpoint;
        return this;
    }


    /**
     * API key for basic authentication at the authentication callback endpoint.
     * 
     * <p>If the value is not empty, Authlete generates Authorization header for Basic authentication when
     * making a request to the authentication callback endpoint.
     */
    public ServiceUpdateApiRequestBody withAuthenticationCallbackApiKey(@Nullable String authenticationCallbackApiKey) {
        this.authenticationCallbackApiKey = authenticationCallbackApiKey;
        return this;
    }


    /**
     * API secret for `basic` authentication at the authentication callback endpoint.
     */
    public ServiceUpdateApiRequestBody withAuthenticationCallbackApiSecret(@Nullable String authenticationCallbackApiSecret) {
        this.authenticationCallbackApiSecret = authenticationCallbackApiSecret;
        return this;
    }


    /**
     * Values of `grant_type` request parameter that the service supports.
     * 
     * <p>The value of this property is used as `grant_types_supported property` in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withSupportedGrantTypes(@Nullable List<ServiceUpdateApiSupportedGrantTypeRequest> supportedGrantTypes) {
        this.supportedGrantTypes = supportedGrantTypes;
        return this;
    }


    /**
     * Values of `response_type` request parameter that
     * the service supports. Valid values are listed in Response Type.
     * 
     * <p>The value of this property is used as `response_types_supported` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withSupportedResponseTypes(@Nullable List<ServiceUpdateApiSupportedResponseTypeRequest> supportedResponseTypes) {
        this.supportedResponseTypes = supportedResponseTypes;
        return this;
    }


    /**
     * The supported data types that can be used as values of the type field in `authorization_details`.
     * 
     * <p>This property corresponds to the `authorization_details_types_supported` metadata. See "OAuth 2.0
     * Rich Authorization Requests" (RAR) for details.
     */
    public ServiceUpdateApiRequestBody withSupportedAuthorizationDetailsTypes(@Nullable List<String> supportedAuthorizationDetailsTypes) {
        this.supportedAuthorizationDetailsTypes = supportedAuthorizationDetailsTypes;
        return this;
    }


    /**
     * The profiles that this service supports.
     */
    public ServiceUpdateApiRequestBody withSupportedServiceProfiles(@Nullable List<ServiceUpdateApiSupportedServiceProfileRequest> supportedServiceProfiles) {
        this.supportedServiceProfiles = supportedServiceProfiles;
        return this;
    }


    /**
     * The flag to indicate whether the `error_description` response parameter is omitted.
     * 
     * <p>According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include
     * the `error_description` response parameter in error responses.
     * 
     * <p>If `true`, Authlete does not embed the `error_description` response parameter in error responses.
     */
    public ServiceUpdateApiRequestBody withErrorDescriptionOmitted(@Nullable Boolean errorDescriptionOmitted) {
        this.errorDescriptionOmitted = errorDescriptionOmitted;
        return this;
    }


    /**
     * The flag to indicate whether the `error_uri` response parameter is omitted.
     * 
     * <p>According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include the `error_uri` response parameter in error responses.
     * 
     * <p>If `true`, Authlete does not embed the
     * `error_uri` response parameter in error responses.
     */
    public ServiceUpdateApiRequestBody withErrorUriOmitted(@Nullable Boolean errorUriOmitted) {
        this.errorUriOmitted = errorUriOmitted;
        return this;
    }


    /**
     * The authorization endpoint of the service.
     * 
     * <p>A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/authorization`.
     * 
     * <p>The value of this property is used as `authorization_endpoint` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withAuthorizationEndpoint(@Nullable String authorizationEndpoint) {
        this.authorizationEndpoint = authorizationEndpoint;
        return this;
    }


    /**
     * The flag to indicate whether the direct authorization endpoint is enabled or not.
     * 
     * <p>The path of the endpoint is `/api/auth/authorization/direct/service-api-key`.
     */
    public ServiceUpdateApiRequestBody withDirectAuthorizationEndpointEnabled(@Nullable Boolean directAuthorizationEndpointEnabled) {
        this.directAuthorizationEndpointEnabled = directAuthorizationEndpointEnabled;
        return this;
    }


    /**
     * UI locales that the service supports.
     * 
     * <p>Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646). For example, `en-US` and `ja-JP`.
     * 
     * <p>The value of this property is used as `ui_locales_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withSupportedUiLocales(@Nullable List<String> supportedUiLocales) {
        this.supportedUiLocales = supportedUiLocales;
        return this;
    }


    /**
     * Values of `display` request parameter that service supports.
     * 
     * <p>The value of this property is used as `display_values_supported` property in the Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withSupportedDisplays(@Nullable List<ServiceUpdateApiSupportedDisplayRequest> supportedDisplays) {
        this.supportedDisplays = supportedDisplays;
        return this;
    }


    /**
     * The flag to indicate whether the use of Proof Key for Code Exchange (PKCE) is always required for authorization requests by Authorization Code Flow.
     * 
     * <p>If `true`, `code_challenge` request parameter is always required for authorization requests using Authorization Code Flow.
     * 
     * <p>See [RFC 7636](https://tools.ietf.org/html/rfc7636) (Proof Key for Code Exchange by OAuth Public Clients) for details about `code_challenge` request parameter.
     */
    public ServiceUpdateApiRequestBody withPkceRequired(@Nullable Boolean pkceRequired) {
        this.pkceRequired = pkceRequired;
        return this;
    }


    /**
     * The flag to indicate whether `S256` is always required as the code challenge method whenever [PKCE (RFC 7636)](https://tools.ietf.org/html/rfc7636) is used.
     * 
     * <p>If this flag is set to `true`, `code_challenge_method=S256` must be included in the authorization request
     * whenever it includes the `code_challenge` request parameter.
     * Neither omission of the `code_challenge_method` request parameter nor use of plain (`code_challenge_method=plain`) is allowed.
     */
    public ServiceUpdateApiRequestBody withPkceS256Required(@Nullable Boolean pkceS256Required) {
        this.pkceS256Required = pkceS256Required;
        return this;
    }


    /**
     * The duration of authorization response JWTs in seconds.
     * 
     * <p>[Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
     * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
     * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
     * from the authorization endpoint will be packed into a JWT. This property is used to compute the
     * value of the `exp` claim of the JWT.
     */
    public ServiceUpdateApiRequestBody withAuthorizationResponseDuration(@Nullable Long authorizationResponseDuration) {
        this.authorizationResponseDuration = authorizationResponseDuration;
        return this;
    }


    /**
     * The [token endpoint](https://tools.ietf.org/html/rfc6749#section-3.2) of the service.
     * 
     * <p>A URL that starts with `https://` and has not fragment component. For example, `https://example.com/auth/token`.
     * 
     * <p>The value of this property is used as `token_endpoint` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withTokenEndpoint(@Nullable String tokenEndpoint) {
        this.tokenEndpoint = tokenEndpoint;
        return this;
    }


    /**
     * The flag to indicate whether the direct token endpoint is enabled or not. The path of the endpoint
     * is `/api/auth/token/direct/service-api-key`.
     */
    public ServiceUpdateApiRequestBody withDirectTokenEndpointEnabled(@Nullable Boolean directTokenEndpointEnabled) {
        this.directTokenEndpointEnabled = directTokenEndpointEnabled;
        return this;
    }


    /**
     * Client authentication methods supported by the token endpoint of the service.
     * 
     * <p>The value of this property is used as `token_endpoint_auth_methods_supports` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withSupportedTokenAuthMethods(@Nullable List<ServiceUpdateApiSupportedTokenAuthMethodRequest> supportedTokenAuthMethods) {
        this.supportedTokenAuthMethods = supportedTokenAuthMethods;
        return this;
    }


    /**
     * The flag to indicate token requests from public clients without the `client_id` request parameter are allowed when the client can be guessed from `authorization_code` or `refresh_token`.
     * 
     * <p>This flag should not be set unless you have special reasons.
     */
    public ServiceUpdateApiRequestBody withMissingClientIdAllowed(@Nullable Boolean missingClientIdAllowed) {
        this.missingClientIdAllowed = missingClientIdAllowed;
        return this;
    }


    /**
     * The [revocation endpoint](https://tools.ietf.org/html/rfc7009) of the service.
     * 
     * <p>A URL that starts with `https://`. For example, `https://example.com/auth/revocation`.
     */
    public ServiceUpdateApiRequestBody withRevocationEndpoint(@Nullable String revocationEndpoint) {
        this.revocationEndpoint = revocationEndpoint;
        return this;
    }


    /**
     * The flag to indicate whether the direct revocation endpoint is enabled or not. The URL of the endpoint is `/api/auth/revocation/direct/service-api-key`.
     */
    public ServiceUpdateApiRequestBody withDirectRevocationEndpointEnabled(@Nullable Boolean directRevocationEndpointEnabled) {
        this.directRevocationEndpointEnabled = directRevocationEndpointEnabled;
        return this;
    }


    /**
     * Client authentication methods supported at the revocation endpoint.
     */
    public ServiceUpdateApiRequestBody withSupportedRevocationAuthMethods(@Nullable List<ServiceUpdateApiSupportedRevocationAuthMethodRequest> supportedRevocationAuthMethods) {
        this.supportedRevocationAuthMethods = supportedRevocationAuthMethods;
        return this;
    }


    /**
     * The URI of the introspection endpoint.
     */
    public ServiceUpdateApiRequestBody withIntrospectionEndpoint(@Nullable String introspectionEndpoint) {
        this.introspectionEndpoint = introspectionEndpoint;
        return this;
    }


    /**
     * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path of the endpoint is `/api/auth/userinfo/direct/{serviceApiKey}`.
     */
    public ServiceUpdateApiRequestBody withDirectIntrospectionEndpointEnabled(@Nullable Boolean directIntrospectionEndpointEnabled) {
        this.directIntrospectionEndpointEnabled = directIntrospectionEndpointEnabled;
        return this;
    }


    /**
     * Client authentication methods supported at the introspection endpoint.
     */
    public ServiceUpdateApiRequestBody withSupportedIntrospectionAuthMethods(@Nullable List<ServiceUpdateApiSupportedIntrospectionAuthMethodRequest> supportedIntrospectionAuthMethods) {
        this.supportedIntrospectionAuthMethods = supportedIntrospectionAuthMethods;
        return this;
    }


    /**
     * The URI of the pushed authorization request endpoint.
     * 
     * <p>This property corresponds to the `pushed_authorization_request_endpoint` metadata defined in "[5. Authorization Server Metadata](https://tools.ietf.org/html/draft-lodderstedt-oauth-par#section-5)" of OAuth 2.0 Pushed Authorization Requests.
     */
    public ServiceUpdateApiRequestBody withPushedAuthReqEndpoint(@Nullable String pushedAuthReqEndpoint) {
        this.pushedAuthReqEndpoint = pushedAuthReqEndpoint;
        return this;
    }


    /**
     * The duration of pushed authorization requests in seconds.
     * 
     * <p>[OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par)
     * defines an endpoint (called "pushed authorization request endpoint") which client applications
     * can register authorization requests into and get corresponding URIs (called "request URIs") from.
     * The issued URIs represent the registered authorization requests. The client applications can use
     * the URIs as the value of the `request_uri` request parameter in an authorization request.
     * 
     * <p>The property represents the duration of registered authorization requests and is used as the value
     * of the `expires_in` parameter in responses from the pushed authorization request endpoint.
     */
    public ServiceUpdateApiRequestBody withPushedAuthReqDuration(@Nullable Long pushedAuthReqDuration) {
        this.pushedAuthReqDuration = pushedAuthReqDuration;
        return this;
    }


    /**
     * The flag to indicate whether this service requires that clients use the pushed authorization
     * request endpoint.
     * 
     * <p>This property corresponds to the `require_pushed_authorization_requests` server metadata defined
     * in [OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par).
     */
    public ServiceUpdateApiRequestBody withParRequired(@Nullable Boolean parRequired) {
        this.parRequired = parRequired;
        return this;
    }


    /**
     * The flag to indicate whether this service requires that authorization requests always utilize
     * a request object by using either request or `request_uri` request parameter.
     * 
     * <p>If this flag is set to `true` and the value of `traditionalRequestObjectProcessingApplied` is
     * `false`, the value of `require_signed_request_object` server metadata of this service is reported
     * as `true` in the discovery document. The metadata is defined in JAR (JWT Secured Authorization Request).
     * That `require_signed_request_object` is `true` means that authorization requests which don't
     * conform to the JAR specification are rejected.
     */
    public ServiceUpdateApiRequestBody withRequestObjectRequired(@Nullable Boolean requestObjectRequired) {
        this.requestObjectRequired = requestObjectRequired;
        return this;
    }


    /**
     * The flag to indicate whether a request object is processed based on rules defined in
     * [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) or JAR (JWT
     * Secured Authorization Request).
     * 
     * <p>Differences between rules in OpenID Connect Core 1.0 and ones in JAR are as follows.
     *   - JAR requires that a request object be always -signed.
     *   - JAR does not allow request parameters outside a request object to be referred to.
     *   - OIDC Core 1.0 requires that response_type request parameter exist outside a request object even if the request object includes the request parameter.
     *   - OIDC Core 1.0 requires that scope request parameter exist outside a request object if the authorization request is an
     *   - OIDC request even if the request object includes the request parameter.
     * 
     * <p>If this flag is set to `false` and the value of `requestObjectRequired` is `true`, the value of
     * `require_signed_request_object` server metadata of this service
     * is reported as `true` in the discovery document. The metadata is defined in JAR (JWT Secured
     * Authorization Request). That `require_signed_request_object` is `true` means that authorization
     * requests which don't conform to the JAR specification are rejected.
     */
    public ServiceUpdateApiRequestBody withTraditionalRequestObjectProcessingApplied(@Nullable Boolean traditionalRequestObjectProcessingApplied) {
        this.traditionalRequestObjectProcessingApplied = traditionalRequestObjectProcessingApplied;
        return this;
    }


    /**
     * The flag to indicate whether this service validates certificate chains during PKI-based client mutual TLS authentication.
     */
    public ServiceUpdateApiRequestBody withMutualTlsValidatePkiCertChain(@Nullable Boolean mutualTlsValidatePkiCertChain) {
        this.mutualTlsValidatePkiCertChain = mutualTlsValidatePkiCertChain;
        return this;
    }


    /**
     * The list of root certificates trusted by this service for PKI-based client mutual TLS authentication.
     */
    public ServiceUpdateApiRequestBody withTrustedRootCertificates(@Nullable List<String> trustedRootCertificates) {
        this.trustedRootCertificates = trustedRootCertificates;
        return this;
    }


    /**
     * The MTLS endpoint aliases.
     * 
     * <p>This property corresponds to the mtls_endpoint_aliases metadata defined in "5. Metadata for Mutual TLS Endpoint Aliases" of [OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens](https://datatracker.ietf.org/doc/rfc8705/).
     * 
     * <p>The aliases will be embedded in the response from the discovery endpoint like the following.
     * 
     * <p>```json
     * {
     *   ......,
     *   "mtls_endpoint_aliases": {
     *     "token_endpoint":         "https://mtls.example.com/token",
     *     "revocation_endpoint":    "https://mtls.example.com/revo",
     *     "introspection_endpoint": "https://mtls.example.com/introspect"
     *   }
     * }
     * ```
     */
    public ServiceUpdateApiRequestBody withMtlsEndpointAliases(@Nullable List<ServiceUpdateApiMtlsEndpointAliasRequest> mtlsEndpointAliases) {
        this.mtlsEndpointAliases = mtlsEndpointAliases;
        return this;
    }


    /**
     * The access token type.
     * 
     * <p>This value is used as the value of `token_type` property in access token responses. If this service
     * complies with [RFC 6750](https://tools.ietf.org/html/rfc6750), the value of this property should
     * be `Bearer`.
     * 
     * <p>See [RFC 6749 (OAuth 2.0), 7.1. Access Token Types](https://tools.ietf.org/html/rfc6749#section-7.1) for details.
     */
    public ServiceUpdateApiRequestBody withAccessTokenType(@Nullable String accessTokenType) {
        this.accessTokenType = accessTokenType;
        return this;
    }


    /**
     * The flag to indicate whether this service supports issuing TLS client certificate bound access tokens.
     */
    public ServiceUpdateApiRequestBody withTlsClientCertificateBoundAccessTokens(@Nullable Boolean tlsClientCertificateBoundAccessTokens) {
        this.tlsClientCertificateBoundAccessTokens = tlsClientCertificateBoundAccessTokens;
        return this;
    }


    /**
     * The duration of access tokens in seconds. This value is used as the value of `expires_in` property
     * in access token responses. `expires_in` is defined [RFC 6749, 5.1. Successful Response](https://tools.ietf.org/html/rfc6749#section-5.1).
     */
    public ServiceUpdateApiRequestBody withAccessTokenDuration(@Nullable Long accessTokenDuration) {
        this.accessTokenDuration = accessTokenDuration;
        return this;
    }


    /**
     * The flag to indicate whether the number of access tokens per subject (and per client) is at most one or can be more.
     * 
     * <p>If `true`, an attempt to issue a new access token invalidates existing access tokens that are associated with the same subject and the same client.
     * 
     * <p>Note that, however, attempts by [Client Credentials Flow](https://tools.ietf.org/html/rfc6749#section-4.4) do not invalidate existing access tokens because access tokens issued by Client Credentials Flow are not associated with any end-user's subject. Also note that an attempt by [Refresh Token Flow](https://tools.ietf.org/html/rfc6749#section-6) invalidates the coupled access token only and this invalidation is always performed regardless of whether the value of this setting item is `true` or `false`.
     */
    public ServiceUpdateApiRequestBody withSingleAccessTokenPerSubject(@Nullable Boolean singleAccessTokenPerSubject) {
        this.singleAccessTokenPerSubject = singleAccessTokenPerSubject;
        return this;
    }


    /**
     * The signature algorithm for JWT. This value is represented on 'alg' attribute
     * of the header of JWT.
     * 
     * <p>it's semantics depends upon where is this defined, for instance:
     *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
     *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
     *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
     */
    public ServiceUpdateApiRequestBody withAccessTokenSignAlg(@Nullable ServiceUpdateApiAccessTokenSignAlgRequest accessTokenSignAlg) {
        this.accessTokenSignAlg = accessTokenSignAlg;
        return this;
    }


    /**
     * The key ID to identify a JWK used for signing access tokens.
     * 
     * <p>A JWK Set can be registered as a property of a service. A JWK Set can contain 0 or more JWKs.
     * Authlete Server has to pick up one JWK for signing from the JWK Set when it generates a JWT-based
     * access token. Authlete Server searches the registered JWK Set for a JWK which satisfies conditions
     * for access token signature. If the number of JWK candidates which satisfy the conditions is 1,
     * there is no problem. On the other hand, if there exist multiple candidates, a Key ID is needed
     * to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
     */
    public ServiceUpdateApiRequestBody withAccessTokenSignatureKeyId(@Nullable String accessTokenSignatureKeyId) {
        this.accessTokenSignatureKeyId = accessTokenSignatureKeyId;
        return this;
    }


    /**
     * The duration of refresh tokens in seconds. The related specifications have no requirements on refresh token duration, but Authlete sets expiration for refresh tokens.
     */
    public ServiceUpdateApiRequestBody withRefreshTokenDuration(@Nullable Long refreshTokenDuration) {
        this.refreshTokenDuration = refreshTokenDuration;
        return this;
    }


    /**
     * The flag to indicate whether the remaining duration of the used refresh token is taken over to
     * the newly issued refresh token.
     */
    public ServiceUpdateApiRequestBody withRefreshTokenDurationKept(@Nullable Boolean refreshTokenDurationKept) {
        this.refreshTokenDurationKept = refreshTokenDurationKept;
        return this;
    }


    /**
     * The flag which indicates whether duration of refresh tokens are reset when they are used even
     * if the `refreshTokenKept` property of this service set to is `true` (= even if "Refresh Token
     * Continuous Use" is "Kept").
     * 
     * <p>This flag has no effect when the `refreshTokenKept` property is set to `false`. In other words,
     * if this service issues a new refresh token on every refresh token request, the refresh token
     * will have fresh duration (unless `refreshTokenDurationKept` is set to `true`) and this
     * `refreshTokenDurationReset` property is not referenced.
     */
    public ServiceUpdateApiRequestBody withRefreshTokenDurationReset(@Nullable Boolean refreshTokenDurationReset) {
        this.refreshTokenDurationReset = refreshTokenDurationReset;
        return this;
    }


    /**
     * The flag to indicate whether a refresh token remains unchanged or gets renewed after its use.
     * 
     * <p>If `true`, a refresh token used to get a new access token remains valid after its use. Otherwise, if `false`, a refresh token is invalidated after its use and a new refresh token is issued.
     * 
     * <p>See [RFC 6749 6. Refreshing an Access Token](https://tools.ietf.org/html/rfc6749#section-6), as to how to get a new access token using a refresh token.
     */
    public ServiceUpdateApiRequestBody withRefreshTokenKept(@Nullable Boolean refreshTokenKept) {
        this.refreshTokenKept = refreshTokenKept;
        return this;
    }


    /**
     * Scopes supported by the service.
     * 
     * <p>Authlete strongly recommends that the service register at least the following scopes.
     * 
     * <p>| Name | Description |
     * | --- | --- |
     * | openid | A permission to get an ID token of an end-user. The `openid` scope appears in [OpenID Connect Core 1.0, 3.1.2.1. Authentication Request, scope](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest). Without this scope, Authlete does not allow `response_type` request parameter to have values other than code and token. |
     * | profile | A permission to get information about `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale` and `updated_at` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
     * | email | A permission to get information about `email` and `email_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
     * | address | A permission to get information about address from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) and [5.1.1. Address Claim](https://openid.net/specs/openid-connect-core-1_0.html#AddressClaim) for details. |
     * | phone | A permission to get information about `phone_number` and `phone_number_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
     * | offline_access | A permission to get information from the user info endpoint even when the end-user is not present. See [OpenID Connect Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess) for details. |
     * 
     * <p>The value of this property is used as `scopes_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withSupportedScopes(@Nullable List<ServiceUpdateApiSupportedScopeRequest> supportedScopes) {
        this.supportedScopes = supportedScopes;
        return this;
    }


    /**
     * The flag to indicate whether requests that request no scope are rejected or not.
     * 
     * <p>When a request has no explicit `scope` parameter and the service's pre-defined default scope set is empty,
     * the authorization server regards the request requests no scope. When this flag is set to `true`,
     * requests that request no scope are rejected.
     * 
     * <p>The requirement below excerpted from [RFC 6749 Section 3.3](https://tools.ietf.org/html/rfc6749#section-3.3)
     * does not explicitly mention the case where the default scope set is empty.
     * 
     * <p>&gt; If the client omits the scope parameter when requesting authorization, the authorization server
     * MUST either process the request using a pre-defined default value or fail the request indicating an invalid scope.
     * 
     * <p>However, if you interpret *"the default scope set exists but is empty"* as *"the default scope set does not exist"*
     * and want to strictly conform to the requirement above, this flag has to be `true`.
     */
    public ServiceUpdateApiRequestBody withScopeRequired(@Nullable Boolean scopeRequired) {
        this.scopeRequired = scopeRequired;
        return this;
    }


    /**
     * 'The duration of [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)s
     * in seconds. This value is used to calculate the value of `exp` claim in an ID token.'
     */
    public ServiceUpdateApiRequestBody withIdTokenDuration(@Nullable Long idTokenDuration) {
        this.idTokenDuration = idTokenDuration;
        return this;
    }


    /**
     * The allowable clock skew between the server and clients in seconds.
     * 
     * <p>The clock skew is taken into consideration when time-related claims in a JWT (e.g. `exp`, `iat`, `nbf`) are verified.
     */
    public ServiceUpdateApiRequestBody withAllowableClockSkew(@Nullable Integer allowableClockSkew) {
        this.allowableClockSkew = allowableClockSkew;
        return this;
    }


    /**
     * Claim types supported by the service. Valid values are listed in Claim Type. Note that Authlete
     * currently doesn't provide any API to help implementations for `AGGREGATED` and `DISTRIBUTED`.
     * 
     * <p>The value of this property is used as `claim_types_supported` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withSupportedClaimTypes(@Nullable List<ServiceUpdateApiSupportedClaimTypeRequest> supportedClaimTypes) {
        this.supportedClaimTypes = supportedClaimTypes;
        return this;
    }


    /**
     * Claim locales that the service supports. Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646).
     * For example, `en-US` and `ja-JP`. See [OpenID Connect Core 1.0, 5.2. Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
     * for details.
     * 
     * <p>The value of this property is used as `claims_locales_supported` property in the
     * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withSupportedClaimLocales(@Nullable List<String> supportedClaimLocales) {
        this.supportedClaimLocales = supportedClaimLocales;
        return this;
    }


    /**
     * Claim names that the service supports. The standard claim names listed in [OpenID Connect Core 1.0,
     * 5.1. Standard Claim](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) should
     * be supported. The following is the list of standard claims.
     * 
     * <p>- `sub`
     * - `name`
     * - `given_name`
     * - `family_name`
     * - `middle_name`
     * - `nickname`
     * - `preferred_username`
     * - `profile`
     * - `picture`
     * - `website`
     * - `email`
     * - `email_verified`
     * - `gender`
     * - `birthdate`
     * - `zoneinfo`
     * - `locale`
     * - `phone_number`
     * - `phone_number_verified`
     * - `address`
     * - `updated_at`
     * 
     * <p>The value of this property is used as `claims_supported` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     * 
     * <p>The service may support its original claim names. See [OpenID Connect Core 1.0, 5.1.2. Additional
     * Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims).
     */
    public ServiceUpdateApiRequestBody withSupportedClaims(@Nullable List<String> supportedClaims) {
        this.supportedClaims = supportedClaims;
        return this;
    }


    /**
     * The flag indicating whether claims specified by shortcut scopes (e.g. `profile`) are included
     * in the issued ID token only when no access token is issued.
     * 
     * <p>To strictly conform to the description below excerpted from [OpenID Connect Core 1.0 Section
     * 5.4](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims), this flag has to be `true`.
     * 
     * <p>&gt; The Claims requested by the profile, email, address, and phone scope values are returned from
     * the UserInfo Endpoint, as described in Section 5.3.2, when a response_type value is used that
     * results in an Access Token being issued. However, when no Access Token is issued (which is the
     * case for the response_type value id_token), the resulting Claims are returned in the ID Token.
     */
    public ServiceUpdateApiRequestBody withClaimShortcutRestrictive(@Nullable Boolean claimShortcutRestrictive) {
        this.claimShortcutRestrictive = claimShortcutRestrictive;
        return this;
    }


    /**
     * The URL of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document. For
     * example, `http://example.com/auth/jwks`.
     * 
     * <p>Client applications accesses this URL (1) to get the public key of the service to validate the
     * signature of an ID token issued by the service and (2) to get the public key of the service to
     * encrypt an request object of the client application. See [OpenID Connect Core 1.0, 10. Signatures
     * and Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
     * 
     * <p>The value of this property is used as `jwks_uri` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withJwksUri(@Nullable String jwksUri) {
        this.jwksUri = jwksUri;
        return this;
    }


    /**
     * 'The flag to indicate whether the direct jwks endpoint is enabled or not. The path of the endpoint
     * is `/api/service/jwks/get/direct/service-api-key`. '
     */
    public ServiceUpdateApiRequestBody withDirectJwksEndpointEnabled(@Nullable Boolean directJwksEndpointEnabled) {
        this.directJwksEndpointEnabled = directJwksEndpointEnabled;
        return this;
    }


    /**
     * The content of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document.
     * 
     * <p>If this property is not `null` in a `/service/create` request or a `/service/update` request,
     * Authlete hosts the content in the database. This property must not be `null` and must contain
     * pairs of public/private keys if the service wants to support asymmetric signatures for ID tokens
     * and asymmetric encryption for request objects. See [OpenID Connect Core 1.0, 10. Signatures and
     * Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
     */
    public ServiceUpdateApiRequestBody withJwks(@Nullable String jwks) {
        this.jwks = jwks;
        return this;
    }


    /**
     * The key ID to identify a JWK used for ID token signature using an asymmetric key.
     * 
     * <p>A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
     * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
     * to pick up one JWK for signature from the JWK Set when it generates an ID token and signature
     * using an asymmetric key is required. Authlete Server searches the registered JWK Set for a JWK
     * which satisfies conditions for ID token signature. If the number of JWK candidates which satisfy
     * the conditions is 1, there is no problem. On the other hand, if there exist multiple candidates,
     * a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5) is needed to be specified so that
     * Authlete Server can pick up one JWK from among the JWK candidates.
     * 
     * <p>This `idTokenSignatureKeyId` property exists for the purpose described above. For key rotation
     * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
     * this mechanism is needed.
     */
    public ServiceUpdateApiRequestBody withIdTokenSignatureKeyId(@Nullable String idTokenSignatureKeyId) {
        this.idTokenSignatureKeyId = idTokenSignatureKeyId;
        return this;
    }


    /**
     * The key ID to identify a JWK used for user info signature using an asymmetric key.
     * 
     * <p>A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
     * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
     * to pick up one JWK for signature from the JWK Set when it is required to sign user info (which
     * is returned from [userinfo endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo))
     * using an asymmetric key. Authlete Server searches the registered JWK Set for a JWK which satisfies
     * conditions for user info signature. If the number of JWK candidates which satisfy the conditions
     * is 1, there is no problem. On the other hand, if there exist multiple candidates, a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5)
     * is needed to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
     * 
     * <p>This `userInfoSignatureKeyId` property exists for the purpose described above. For key rotation
     * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
     * this mechanism is needed.
     */
    public ServiceUpdateApiRequestBody withUserInfoSignatureKeyId(@Nullable String userInfoSignatureKeyId) {
        this.userInfoSignatureKeyId = userInfoSignatureKeyId;
        return this;
    }


    /**
     * The key ID to identify a JWK used for signing authorization responses using an asymmetric key.
     * 
     * <p>[Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
     * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
     * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
     * from the authorization endpoint will be packed into a JWT. This property is used to compute the
     * value of the `exp` claim of the JWT.
     * 
     * <p>Authlete Server searches the JWK Set for a JWK which satisfies conditions for authorization response
     * signature. If the number of JWK candidates which satisfy the conditions is 1, there is no problem.
     * On the other hand, if there exist multiple candidates, a Key ID is needed to be specified so that
     * Authlete Server can pick up one JWK from among the JWK candidates. This property exists to specify
     * the key ID.
     */
    public ServiceUpdateApiRequestBody withAuthorizationSignatureKeyId(@Nullable String authorizationSignatureKeyId) {
        this.authorizationSignatureKeyId = authorizationSignatureKeyId;
        return this;
    }


    /**
     * The [user info endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo) of the
     * service. A URL that starts with `https://`. For example, `https://example.com/auth/userinfo`.
     * 
     * <p>The value of this property is used as `userinfo_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withUserInfoEndpoint(@Nullable String userInfoEndpoint) {
        this.userInfoEndpoint = userInfoEndpoint;
        return this;
    }


    /**
     * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path
     * of the endpoint is `/api/auth/userinfo/direct/service-api-key`.
     */
    public ServiceUpdateApiRequestBody withDirectUserInfoEndpointEnabled(@Nullable Boolean directUserInfoEndpointEnabled) {
        this.directUserInfoEndpointEnabled = directUserInfoEndpointEnabled;
        return this;
    }


    /**
     * The boolean flag which indicates whether the [OAuth 2.0 Dynamic Client Registration Protocol](https://tools.ietf.org/html/rfc7591)
     * is supported.
     */
    public ServiceUpdateApiRequestBody withDynamicRegistrationSupported(@Nullable Boolean dynamicRegistrationSupported) {
        this.dynamicRegistrationSupported = dynamicRegistrationSupported;
        return this;
    }


    /**
     * The [registration endpoint](http://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration)
     * of the service. A URL that starts with `https://`. For example, `https://example.com/auth/registration`.
     * 
     * <p>The value of this property is used as `registration_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withRegistrationEndpoint(@Nullable String registrationEndpoint) {
        this.registrationEndpoint = registrationEndpoint;
        return this;
    }


    /**
     * The URI of the registration management endpoint. If dynamic client registration is supported,
     * and this is set, this URI will be used as the basis of the client's management endpoint by appending
     * `/clientid}/` to it as a path element. If this is unset, the value of `registrationEndpoint` will
     * be used as the URI base instead.
     */
    public ServiceUpdateApiRequestBody withRegistrationManagementEndpoint(@Nullable String registrationManagementEndpoint) {
        this.registrationManagementEndpoint = registrationManagementEndpoint;
        return this;
    }


    /**
     * The URL of the "Policy" of the service.
     * 
     * <p>The value of this property is used as `op_policy_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withPolicyUri(@Nullable String policyUri) {
        this.policyUri = policyUri;
        return this;
    }


    /**
     * The URL of the "Terms Of Service" of the service.
     * 
     * <p>The value of this property is used as `op_tos_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withTosUri(@Nullable String tosUri) {
        this.tosUri = tosUri;
        return this;
    }


    /**
     * The URL of a page where documents for developers can be found.
     * 
     * <p>The value of this property is used as `service_documentation` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withServiceDocumentation(@Nullable String serviceDocumentation) {
        this.serviceDocumentation = serviceDocumentation;
        return this;
    }


    /**
     * The URI of backchannel authentication endpoint, which is defined in the specification of [CIBA
     * (Client Initiated Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
     */
    public ServiceUpdateApiRequestBody withBackchannelAuthenticationEndpoint(@Nullable String backchannelAuthenticationEndpoint) {
        this.backchannelAuthenticationEndpoint = backchannelAuthenticationEndpoint;
        return this;
    }


    /**
     * The supported backchannel token delivery modes. This property corresponds to the `backchannel_token_delivery_modes_supported`
     * metadata.
     * 
     * <p>Backchannel token delivery modes are defined in the specification of [CIBA (Client Initiated
     * Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
     */
    public ServiceUpdateApiRequestBody withSupportedBackchannelTokenDeliveryModes(@Nullable List<ServiceUpdateApiSupportedBackchannelTokenDeliveryModeRequest> supportedBackchannelTokenDeliveryModes) {
        this.supportedBackchannelTokenDeliveryModes = supportedBackchannelTokenDeliveryModes;
        return this;
    }


    /**
     * The duration of backchannel authentication request IDs issued from the backchannel authentication
     * endpoint in seconds. This is used as the value of the `expires_in` property in responses from
     * the backchannel authentication endpoint.
     */
    public ServiceUpdateApiRequestBody withBackchannelAuthReqIdDuration(@Nullable Integer backchannelAuthReqIdDuration) {
        this.backchannelAuthReqIdDuration = backchannelAuthReqIdDuration;
        return this;
    }


    /**
     * The minimum interval between polling requests to the token endpoint from client applications in
     * seconds. This is used as the value of the `interval` property in responses from the backchannel
     * authentication endpoint.
     */
    public ServiceUpdateApiRequestBody withBackchannelPollingInterval(@Nullable Integer backchannelPollingInterval) {
        this.backchannelPollingInterval = backchannelPollingInterval;
        return this;
    }


    /**
     * The boolean flag which indicates whether the `user_code` request parameter is supported at the
     * backchannel authentication endpoint. This property corresponds to the `backchannel_user_code_parameter_supported`
     * metadata.
     */
    public ServiceUpdateApiRequestBody withBackchannelUserCodeParameterSupported(@Nullable Boolean backchannelUserCodeParameterSupported) {
        this.backchannelUserCodeParameterSupported = backchannelUserCodeParameterSupported;
        return this;
    }


    /**
     * The flag to indicate whether the `binding_message` request parameter is always required whenever
     * a backchannel authentication request is judged as a request for Financial-grade API.
     * 
     * <p>The FAPI-CIBA profile requires that the authorization server _"shall ensure unique authorization
     * context exists in the authorization request or require a `binding_message` in the authorization
     * request"_ (FAPI-CIBA, 5.2.2, 2). The simplest way to fulfill this requirement is to set this property
     * to `true`.
     * 
     * <p>If this property is set to `false`, the `binding_message` request parameter remains optional
     * even in FAPI context, but in exchange, your authorization server must implement a custom mechanism
     * that ensures each backchannel authentication request has unique context.
     */
    public ServiceUpdateApiRequestBody withBackchannelBindingMessageRequiredInFapi(@Nullable Boolean backchannelBindingMessageRequiredInFapi) {
        this.backchannelBindingMessageRequiredInFapi = backchannelBindingMessageRequiredInFapi;
        return this;
    }


    /**
     * The URI of the device authorization endpoint.
     * 
     * <p>Device authorization endpoint is defined in the specification of OAuth 2.0 Device Authorization Grant.
     */
    public ServiceUpdateApiRequestBody withDeviceAuthorizationEndpoint(@Nullable String deviceAuthorizationEndpoint) {
        this.deviceAuthorizationEndpoint = deviceAuthorizationEndpoint;
        return this;
    }


    /**
     * The verification URI for the device flow. This URI is used as the value of the `verification_uri`
     * parameter in responses from the device authorization endpoint.
     */
    public ServiceUpdateApiRequestBody withDeviceVerificationUri(@Nullable String deviceVerificationUri) {
        this.deviceVerificationUri = deviceVerificationUri;
        return this;
    }


    /**
     * The verification URI for the device flow with a placeholder for a user code. This URI is used
     * to build the value of the `verification_uri_complete` parameter in responses from the device
     * authorization endpoint.
     * 
     * <p>It is expected that the URI contains a fixed string `USER_CODE` somewhere as a placeholder for
     * a user code. For example, like the following.
     * 
     * <p>`https://example.com/device?user\_code=USER\_CODE`
     * 
     * <p>The fixed string is replaced with an actual user code when Authlete builds a verification URI
     * with a user code for the `verification_uri_complete` parameter.
     * 
     * <p>If this URI is not set, the `verification_uri_complete` parameter won't appear in device authorization
     * responses.
     */
    public ServiceUpdateApiRequestBody withDeviceVerificationUriComplete(@Nullable String deviceVerificationUriComplete) {
        this.deviceVerificationUriComplete = deviceVerificationUriComplete;
        return this;
    }


    /**
     * The duration of device verification codes and end-user verification codes issued from the device
     * authorization endpoint in seconds. This is used as the value of the `expires_in` property in responses
     * from the device authorization endpoint.
     */
    public ServiceUpdateApiRequestBody withDeviceFlowCodeDuration(@Nullable Integer deviceFlowCodeDuration) {
        this.deviceFlowCodeDuration = deviceFlowCodeDuration;
        return this;
    }


    /**
     * The minimum interval between polling requests to the token endpoint from client applications in
     * seconds in device flow. This is used as the value of the `interval` property in responses from
     * the device authorization endpoint.
     */
    public ServiceUpdateApiRequestBody withDeviceFlowPollingInterval(@Nullable Integer deviceFlowPollingInterval) {
        this.deviceFlowPollingInterval = deviceFlowPollingInterval;
        return this;
    }


    /**
     * The character set for end-user verification codes (`user_code`) for Device Flow.
     */
    public ServiceUpdateApiRequestBody withUserCodeCharset(@Nullable ServiceUpdateApiUserCodeCharsetRequest userCodeCharset) {
        this.userCodeCharset = userCodeCharset;
        return this;
    }


    /**
     * The length of end-user verification codes (`user_code`) for Device Flow.
     */
    public ServiceUpdateApiRequestBody withUserCodeLength(@Nullable Integer userCodeLength) {
        this.userCodeLength = userCodeLength;
        return this;
    }


    /**
     * Trust frameworks supported by this service. This corresponds to the `trust_frameworks_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    public ServiceUpdateApiRequestBody withSupportedTrustFrameworks(@Nullable List<String> supportedTrustFrameworks) {
        this.supportedTrustFrameworks = supportedTrustFrameworks;
        return this;
    }


    /**
     * Evidence supported by this service. This corresponds to the `evidence_supported` [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    public ServiceUpdateApiRequestBody withSupportedEvidence(@Nullable List<String> supportedEvidence) {
        this.supportedEvidence = supportedEvidence;
        return this;
    }


    /**
     * Identity documents supported by this service. This corresponds to the `id_documents_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    public ServiceUpdateApiRequestBody withSupportedIdentityDocuments(@Nullable List<String> supportedIdentityDocuments) {
        this.supportedIdentityDocuments = supportedIdentityDocuments;
        return this;
    }


    /**
     * Verification methods supported by this service. This corresponds to the `id_documents_verification_methods_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    public ServiceUpdateApiRequestBody withSupportedVerificationMethods(@Nullable List<String> supportedVerificationMethods) {
        this.supportedVerificationMethods = supportedVerificationMethods;
        return this;
    }


    /**
     * Verified claims supported by this service. This corresponds to the `claims_in_verified_claims_supported`
     * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
     */
    public ServiceUpdateApiRequestBody withSupportedVerifiedClaims(@Nullable List<String> supportedVerifiedClaims) {
        this.supportedVerifiedClaims = supportedVerifiedClaims;
        return this;
    }


    /**
     * OIDC4IDA / verifiedClaimsValidationSchemaSet
     */
    public ServiceUpdateApiRequestBody withVerifiedClaimsValidationSchemaSet(@Nullable ServiceUpdateApiVerifiedClaimsValidationSchemaSetRequest verifiedClaimsValidationSchemaSet) {
        this.verifiedClaimsValidationSchemaSet = verifiedClaimsValidationSchemaSet;
        return this;
    }


    /**
     * The attributes of this service.
     */
    public ServiceUpdateApiRequestBody withAttributes(@Nullable List<ServiceUpdateApiAttributeRequest> attributes) {
        this.attributes = attributes;
        return this;
    }


    /**
     * The flag indicating whether the nbf claim in the request object is optional even when the authorization
     * request is regarded as a FAPI-Part2 request.
     * 
     * <p>The final version of Financial-grade API was approved in January, 2021. The Part 2 of the final
     * version has new requirements on lifetime of request objects. They require that request objects
     * contain an `nbf` claim and the lifetime computed by `exp` - `nbf` be no longer than 60 minutes.
     * 
     * <p>Therefore, when an authorization request is regarded as a FAPI-Part2 request, the request object
     * used in the authorization request must contain an nbf claim. Otherwise, the authorization server
     * rejects the authorization request.
     * 
     * <p>When this flag is `true`, the `nbf` claim is treated as an optional claim even when the authorization
     * request is regarded as a FAPI-Part2 request. That is, the authorization server does not perform
     * the validation on lifetime of the request object.
     * 
     * <p>Skipping the validation is a violation of the FAPI specification. The reason why this flag has
     * been prepared nevertheless is that the new requirements (which do not exist in the Implementer's
     * Draft 2 released in October, 2018) have big impacts on deployed implementations of client
     * applications and Authlete thinks there should be a mechanism whereby to make the migration
     * from ID2 to Final smooth without breaking live systems.
     */
    public ServiceUpdateApiRequestBody withNbfOptional(@Nullable Boolean nbfOptional) {
        this.nbfOptional = nbfOptional;
        return this;
    }


    /**
     * The flag indicating whether generation of the iss response parameter is suppressed.
     * 
     * <p>"OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response" has defined a new
     * authorization response parameter, `iss`, as a countermeasure for a certain type of mix-up attacks.
     * 
     * <p>The specification requires that the `iss` response parameter always be included in authorization
     * responses unless JARM (JWT Secured Authorization Response Mode) is used.
     * 
     * <p>When this flag is `true`, the authorization server does not include the `iss` response parameter
     * in authorization responses. By turning this flag on and off, developers of client applications
     * can experiment the mix-up attack and the effect of the `iss` response parameter.
     * 
     * <p>Note that this flag should not be `true` in production environment unless there are special
     * reasons for it.
     */
    public ServiceUpdateApiRequestBody withIssSuppressed(@Nullable Boolean issSuppressed) {
        this.issSuppressed = issSuppressed;
        return this;
    }


    /**
     * custom client metadata supported by this service.
     * 
     * <p>Standard specifications define client metadata as necessary. The following are such examples.
     * 
     * <p>* [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
     * * [RFC 7591 OAuth 2.0 Dynamic Client Registration Protocol](https://www.rfc-editor.org/rfc/rfc7591.html)
     * * [RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens](https://www.rfc-editor.org/rfc/rfc8705.html)
     * * [OpenID Connect Client-Initiated Backchannel Authentication Flow - Core 1.0](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html)
     * * [The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-jwsreq/)
     * * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
     * * [OAuth 2.0 Pushed Authorization Requests (PAR)](https://datatracker.ietf.org/doc/rfc9126/)
     * * [OAuth 2.0 Rich Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/)
     * 
     * <p>Standard client metadata included in Client Registration Request and Client Update Request (cf.
     * [OIDC DynReg](https://openid.net/specs/openid-connect-registration-1_0.html), [RFC 7591](https://www.rfc-editor.org/rfc/rfc7591.html)
     * and [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)) are, if supported by Authlete, stored
     * into Authlete database. On the other hand, unrecognized client metadata are discarded.
     * 
     * <p>By listing up custom client metadata in advance by using this property (`supportedCustomClientMetadata`),
     * Authlete can recognize them and stores their values into the database. The stored custom client
     * metadata values can be referenced by `customMetadata`.
     */
    public ServiceUpdateApiRequestBody withSupportedCustomClientMetadata(@Nullable List<String> supportedCustomClientMetadata) {
        this.supportedCustomClientMetadata = supportedCustomClientMetadata;
        return this;
    }


    /**
     * The flag indicating whether the expiration date of an access token never exceeds that of the
     * corresponding refresh token.
     * 
     * <p>When a new access token is issued by a refresh token request (= a token request with `grant_type=refresh_token`),
     * the expiration date of the access token may exceed the expiration date of the corresponding
     * refresh token. This behavior itself is not wrong and may happen when `refreshTokenKept` is
     * `true` and/or when `refreshTokenDurationKept` is `true`.
     * 
     * <p>When this flag is `true`, the expiration date of an access token never exceeds that of the corresponding
     * refresh token regardless of the calculated duration based on other settings such as `accessTokenDuration`,
     * `accessTokenDuration` in `extension` and `access_token.duration` scope attribute.
     * 
     * <p>It is technically possible to set a value which is bigger than the duration of refresh tokens
     * as the duration of access tokens although it is strange. In the case, the duration of an access
     * token becomes longer than the duration of the refresh token which is issued together with the
     * access token. Even if the duration values are configured so, if this flag is `true`, the expiration
     * date of the access token does not exceed that of the refresh token. That is, the duration of
     * the access token will be shortened, and as a result, the access token and the refresh token
     * will have the same expiration date.
     */
    public ServiceUpdateApiRequestBody withTokenExpirationLinked(@Nullable Boolean tokenExpirationLinked) {
        this.tokenExpirationLinked = tokenExpirationLinked;
        return this;
    }


    /**
     * The flag indicating whether encryption of request object is required when the request object
     * is passed through the front channel.
     * 
     * <p>This flag does not affect the processing of request objects at the Pushed Authorization Request
     * Endpoint, which is defined in [OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/).
     * Unecrypted request objects are accepted at the endpoint even if this flag is `true`.
     * 
     * <p>This flag does not indicate whether a request object is always required. There is a different
     * flag, `requestObjectRequired`, for the purpose. See the description of `requestObjectRequired`
     * for details.
     * 
     * <p>Even if this flag is `false`, encryption of request object is required if the `frontChannelRequestObjectEncryptionRequired`
     * flag of the client is `true`.
     */
    public ServiceUpdateApiRequestBody withFrontChannelRequestObjectEncryptionRequired(@Nullable Boolean frontChannelRequestObjectEncryptionRequired) {
        this.frontChannelRequestObjectEncryptionRequired = frontChannelRequestObjectEncryptionRequired;
        return this;
    }


    /**
     * The flag indicating whether the JWE alg of encrypted request object must match the `request_object_encryption_alg`
     * client metadata of the client that has sent the request object.
     * 
     * <p>The request_object_encryption_alg client metadata itself is defined in [OpenID Connect Dynamic
     * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
     * 
     * <p>&gt; request_object_encryption_alg
     * &gt;
     * &gt; OPTIONAL. JWE [JWE] alg algorithm [JWA] the RP is declaring that it may use for encrypting
     * Request Objects sent to the OP. This parameter SHOULD be included when symmetric encryption
     * will be used, since this signals to the OP that a client_secret value needs to be returned
     * from which the symmetric key will be derived, that might not otherwise be returned. The RP
     * MAY still use other supported encryption algorithms or send unencrypted Request Objects, even
     * when this parameter is present. If both signing and encryption are requested, the Request Object
     * will be signed then encrypted, with the result being a Nested JWT, as defined in [JWT]. The
     * default, if omitted, is that the RP is not declaring whether it might encrypt any Request Objects.
     * 
     * <p>The point here is "The RP MAY still use other supported encryption algorithms or send unencrypted
     * Request Objects, even when this parameter is present."
     * 
     * <p>The Client's property that represents the client metadata is `requestEncryptionAlg`. See the
     * description of `requestEncryptionAlg` for details.
     * 
     * <p>Even if this flag is `false`, the match is required if the `requestObjectEncryptionAlgMatchRequired`
     * flag of the client is `true`.
     */
    public ServiceUpdateApiRequestBody withRequestObjectEncryptionAlgMatchRequired(@Nullable Boolean requestObjectEncryptionAlgMatchRequired) {
        this.requestObjectEncryptionAlgMatchRequired = requestObjectEncryptionAlgMatchRequired;
        return this;
    }


    /**
     * The flag indicating whether the JWE `enc` of encrypted request object must match the `request_object_encryption_enc`
     * client metadata of the client that has sent the request object.
     * 
     * <p>The `request_object_encryption_enc` client metadata itself is defined in [OpenID Connect Dynamic
     * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
     * 
     * <p>&gt; request_object_encryption_enc
     * &gt;
     * &gt; OPTIONAL. JWE enc algorithm [JWA] the RP is declaring that it may use for encrypting Request
     * Objects sent to the OP. If request_object_encryption_alg is specified, the default for this
     * value is A128CBC-HS256. When request_object_encryption_enc is included, request_object_encryption_alg
     * MUST also be provided.
     * 
     * <p>The Client's property that represents the client metadata is `requestEncryptionEnc`. See the
     * description of `requestEncryptionEnc` for details.
     * 
     * <p>Even if this flag is false, the match is required if the `requestObjectEncryptionEncMatchRequired`
     * flag is `true`.
     */
    public ServiceUpdateApiRequestBody withRequestObjectEncryptionEncMatchRequired(@Nullable Boolean requestObjectEncryptionEncMatchRequired) {
        this.requestObjectEncryptionEncMatchRequired = requestObjectEncryptionEncMatchRequired;
        return this;
    }


    /**
     * The flag indicating whether HSM (Hardware Security Module) support is enabled for this service.
     * 
     * <p>When this flag is `false`, keys managed in HSMs are not used even if they exist. In addition,
     * `/api/hsk/*` APIs reject all requests.
     * 
     * <p>Even if this flag is `true`, HSM-related features do not work if the configuration of the Authlete
     * server you are using does not support HSM.
     */
    public ServiceUpdateApiRequestBody withHsmEnabled(@Nullable Boolean hsmEnabled) {
        this.hsmEnabled = hsmEnabled;
        return this;
    }


    /**
     * The information about keys managed on HSMs (Hardware Security Modules).
     * 
     * <p>This `hsks` property is output only, meaning that `hsks` in requests to `/api/service/create`
     * API and `/api/service/update` API do not have any effect. The contents of this property is controlled
     * only by `/api/hsk/*` APIs.
     */
    public ServiceUpdateApiRequestBody withHsks(@Nullable List<ServiceUpdateApiHskRequest> hsks) {
        this.hsks = hsks;
        return this;
    }


    /**
     * The URL of the grant management endpoint.
     */
    public ServiceUpdateApiRequestBody withGrantManagementEndpoint(@Nullable String grantManagementEndpoint) {
        this.grantManagementEndpoint = grantManagementEndpoint;
        return this;
    }


    /**
     * The flag indicating whether every authorization request (and any request serving as an authorization
     * request such as CIBA backchannel authentication request and device authorization request) must
     * include the `grant_management_action` request parameter.
     * 
     * <p>This property corresponds to the `grant_management_action_required` server metadata defined
     * in [Grant Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html).
     * 
     * <p>Note that setting true to this property will result in blocking all public clients because
     * the specification requires that grant management be usable only by confidential clients for
     * security reasons.
     */
    public ServiceUpdateApiRequestBody withGrantManagementActionRequired(@Nullable Boolean grantManagementActionRequired) {
        this.grantManagementActionRequired = grantManagementActionRequired;
        return this;
    }


    /**
     * The flag indicating whether Authlete's `/api/client/registration` API uses `UNAUTHORIZED` as
     * a value of the `action` response parameter when appropriate.
     * 
     * <p>The `UNAUTHORIZED` enum value was initially not defined as a possible value of the `action`
     * parameter in an `/api/client/registration` API response. This means that implementations of
     * client `configuration` endpoint were not able to conform to [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)
     * strictly.
     * 
     * <p>For backward compatibility (to avoid breaking running systems), Authlete's `/api/client/registration`
     * API does not return the `UNAUTHORIZED` enum value if this flag is not turned on.
     * 
     * <p>The steps an existing implementation of client configuration endpoint has to do in order to
     * conform to the requirement related to "401 Unauthorized" are as follows.
     * 
     * <p>1. Update the Authlete library (e.g. authlete-java-common) your system is using.
     * 2. Update your implementation of client configuration endpoint so that it can handle the
     * `UNAUTHORIZED` action.
     * 3. Turn on this `unauthorizedOnClientConfigSupported` flag.
     */
    public ServiceUpdateApiRequestBody withUnauthorizedOnClientConfigSupported(@Nullable Boolean unauthorizedOnClientConfigSupported) {
        this.unauthorizedOnClientConfigSupported = unauthorizedOnClientConfigSupported;
        return this;
    }


    /**
     * The flag indicating whether the `scope` request parameter in dynamic client registration and
     * update requests (RFC 7591 and RFC 7592) is used as scopes that the client can request.
     * 
     * <p>Limiting the range of scopes that a client can request is achieved by listing scopes in the
     * `client.extension.requestableScopes` property and setting the `client.extension.requestableScopesEnabled`
     * property to `true`. This feature is called "requestable scopes".
     * 
     * <p>This property affects behaviors of `/api/client/registration` and other family APIs.
     */
    public ServiceUpdateApiRequestBody withDcrScopeUsedAsRequestable(@Nullable Boolean dcrScopeUsedAsRequestable) {
        this.dcrScopeUsedAsRequestable = dcrScopeUsedAsRequestable;
        return this;
    }


    /**
     * The endpoint for clients ending the sessions.
     * 
     * <p>A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/endSession`.
     * 
     * <p>The value of this property is used as `end_session_endpoint` property in the [OpenID Provider
     * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     */
    public ServiceUpdateApiRequestBody withEndSessionEndpoint(@Nullable String endSessionEndpoint) {
        this.endSessionEndpoint = endSessionEndpoint;
        return this;
    }


    /**
     * The flag indicating whether the port number component of redirection URIs can be variable when
     * the host component indicates loopback.
     * 
     * <p>When this flag is `true`, if the host component of a redirection URI specified in an authorization
     * request indicates loopback (to be precise, when the host component is localhost, `127.0.0.1`
     * or `::1`), the port number component is ignored when the specified redirection URI is compared
     * to pre-registered ones. This behavior is described in [7.3. Loopback Interface Redirection](
     * https://www.rfc-editor.org/rfc/rfc8252.html#section-7.3) of [RFC 8252 OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8252.html)
     * for Native Apps.
     * 
     * <p>[3.1.2.3. Dynamic Configuration](https://www.rfc-editor.org/rfc/rfc6749.html#section-3.1.2.3)
     * of [RFC 6749](https://www.rfc-editor.org/rfc/rfc6749.html) states _"If the client registration
     * included the full redirection URI, the authorization server MUST compare the two URIs using
     * simple string comparison as defined in [RFC3986] Section 6.2.1."_ Also, the description of
     * `redirect_uri` in [3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest)
     * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) states
     * _"This URI MUST exactly match one of the Redirection URI values for the Client pre-registered
     * at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [RFC3986]
     * (**Simple String Comparison**)."_ These "Simple String Comparison" requirements are preceded
     * by this flag. That is, even when the conditions described in RFC 6749 and OpenID Connect Core 1.0
     * are satisfied, the port number component of loopback redirection URIs can be variable when this
     * flag is `true`.
     * 
     * <p>[8.3. Loopback Redirect Considerations](https://www.rfc-editor.org/rfc/rfc8252.html#section-8.3)
     * of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) states as follows.
     * 
     * <p>&gt; While redirect URIs using localhost (i.e., `"http://localhost:{port}/{path}"`) function
     * similarly to loopback IP redirects described in Section 7.3, the use of localhost is NOT RECOMMENDED.
     * Specifying a redirect URI with the loopback IP literal rather than localhost avoids inadvertently
     * listening on network interfaces other than the loopback interface. It is also less susceptible
     * to client-side firewalls and misconfigured host name resolution on the user's device.
     * 
     * <p>However, Authlete allows the port number component to be variable in the case of `localhost`,
     * too. It is left to client applications whether they use `localhost` or a literal loopback IP
     * address (`127.0.0.1` for IPv4 or `::1` for IPv6).
     * 
     * <p>Section 7.3 and Section 8.3 of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) state
     * that loopback redirection URIs use the `"http"` scheme, but Authlete allows the port number
     * component to be variable in other cases (e.g. in the case of the `"https"` scheme), too.
     */
    public ServiceUpdateApiRequestBody withLoopbackRedirectionUriVariable(@Nullable Boolean loopbackRedirectionUriVariable) {
        this.loopbackRedirectionUriVariable = loopbackRedirectionUriVariable;
        return this;
    }


    /**
     * The flag indicating whether Authlete checks whether the `aud` claim of request objects matches
     * the issuer identifier of this service.
     * 
     * <p>[Section 6.1. Passing a Request Object by Value](https://openid.net/specs/openid-connect-core-1_0.html#JWTRequests)
     * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) has the following
     * statement.
     * 
     * <p>&gt; The `aud` value SHOULD be or include the OP's Issuer Identifier URL.
     * 
     * <p>Likewise, [Section 4. Request Object](https://www.rfc-editor.org/rfc/rfc9101.html#section-4) of
     * [RFC 9101](https://www.rfc-editor.org/rfc/rfc9101.html) (The OAuth 2.0 Authorization Framework:
     * JWT-Secured Authorization Request (JAR)) has the following statement.
     * 
     * <p>&gt; The value of aud should be the value of the authorization server (AS) issuer, as defined in
     * [RFC 8414](https://www.rfc-editor.org/rfc/rfc8414.html).
     * 
     * <p>As excerpted above, validation on the `aud` claim of request objects is optional. However, if
     * this flag is turned on, Authlete checks whether the `aud` claim of request objects matches the issuer
     * identifier of this service and raises an error if they are different.
     */
    public ServiceUpdateApiRequestBody withRequestObjectAudienceChecked(@Nullable Boolean requestObjectAudienceChecked) {
        this.requestObjectAudienceChecked = requestObjectAudienceChecked;
        return this;
    }


    /**
     * The flag indicating whether Authlete generates access tokens for
     * external attachments and embeds them in ID tokens and userinfo
     * responses.
     */
    public ServiceUpdateApiRequestBody withAccessTokenForExternalAttachmentEmbedded(@Nullable Boolean accessTokenForExternalAttachmentEmbedded) {
        this.accessTokenForExternalAttachmentEmbedded = accessTokenForExternalAttachmentEmbedded;
        return this;
    }


    /**
     * Identifiers of entities that can issue entity statements for this
     * service. This property corresponds to the `authority_hints`
     * property that appears in a self-signed entity statement that is
     * defined in OpenID Connect Federation 1.0.
     */
    public ServiceUpdateApiRequestBody withAuthorityHints(@Nullable List<String> authorityHints) {
        this.authorityHints = authorityHints;
        return this;
    }


    /**
     * flag indicating whether this service supports OpenID Connect Federation 1
     */
    public ServiceUpdateApiRequestBody withFederationEnabled(@Nullable Boolean federationEnabled) {
        this.federationEnabled = federationEnabled;
        return this;
    }


    /**
     * JWK Set document containing keys that are used to sign (1) self-signed
     * entity statement of this service and (2) the response from
     * `signed_jwks_uri`.
     */
    public ServiceUpdateApiRequestBody withFederationJwks(@Nullable String federationJwks) {
        this.federationJwks = federationJwks;
        return this;
    }


    /**
     * A key ID to identify a JWK used to sign the entity configuration and
     * the signed JWK Set.
     */
    public ServiceUpdateApiRequestBody withFederationSignatureKeyId(@Nullable String federationSignatureKeyId) {
        this.federationSignatureKeyId = federationSignatureKeyId;
        return this;
    }


    /**
     * The duration of the entity configuration in seconds.
     */
    public ServiceUpdateApiRequestBody withFederationConfigurationDuration(@Nullable Long federationConfigurationDuration) {
        this.federationConfigurationDuration = federationConfigurationDuration;
        return this;
    }


    /**
     * The URI of the federation registration endpoint. This property corresponds
     * to the `federation_registration_endpoint` server metadata that is
     * defined in OpenID Connect Federation 1.0.
     */
    public ServiceUpdateApiRequestBody withFederationRegistrationEndpoint(@Nullable String federationRegistrationEndpoint) {
        this.federationRegistrationEndpoint = federationRegistrationEndpoint;
        return this;
    }


    /**
     * The human-readable name representing the organization that operates
     * this service. This property corresponds to the `organization_name`
     * server metadata that is defined in OpenID Connect Federation 1.0.
     */
    public ServiceUpdateApiRequestBody withOrganizationName(@Nullable String organizationName) {
        this.organizationName = organizationName;
        return this;
    }


    /**
     * The transformed claims predefined by this service in JSON format.
     * This property corresponds to the `transformed_claims_predefined`
     * server metadata.
     */
    public ServiceUpdateApiRequestBody withPredefinedTransformedClaims(@Nullable String predefinedTransformedClaims) {
        this.predefinedTransformedClaims = predefinedTransformedClaims;
        return this;
    }


    /**
     * flag indicating whether refresh token requests with the same
     * refresh token can be made multiple times in quick succession and
     * they can obtain the same renewed refresh token within the short
     * period.
     */
    public ServiceUpdateApiRequestBody withRefreshTokenIdempotent(@Nullable Boolean refreshTokenIdempotent) {
        this.refreshTokenIdempotent = refreshTokenIdempotent;
        return this;
    }


    /**
     * The URI of the endpoint that returns this service's JWK Set document in
     * the JWT format. This property corresponds to the `signed_jwks_uri`
     * server metadata defined in OpenID Connect Federation 1.0.
     */
    public ServiceUpdateApiRequestBody withSignedJwksUri(@Nullable String signedJwksUri) {
        this.signedJwksUri = signedJwksUri;
        return this;
    }


    /**
     * Supported attachment types. This property corresponds to the {@code
     * attachments_supported} server metadata which was added by the third
     * implementer's draft of OpenID Connect for Identity Assurance 1.0.
     */
    public ServiceUpdateApiRequestBody withSupportedAttachments(@Nullable List<ServiceUpdateApiSupportedAttachmentRequest> supportedAttachments) {
        this.supportedAttachments = supportedAttachments;
        return this;
    }


    /**
     * Supported algorithms used to compute digest values of external
     * attachments. This property corresponds to the
     * `digest_algorithms_supported` server metadata which was added
     * by the third implementer's draft of OpenID Connect for Identity
     * Assurance 1.0.
     */
    public ServiceUpdateApiRequestBody withSupportedDigestAlgorithms(@Nullable List<String> supportedDigestAlgorithms) {
        this.supportedDigestAlgorithms = supportedDigestAlgorithms;
        return this;
    }


    /**
     * Document types supported by this service. This property corresponds
     * to the `documents_supported` server metadata.
     */
    public ServiceUpdateApiRequestBody withSupportedDocuments(@Nullable List<String> supportedDocuments) {
        this.supportedDocuments = supportedDocuments;
        return this;
    }


    /**
     * validation and verification processes supported by this service.
     * This property corresponds to the `documents_methods_supported`
     * server metadata.
     * 
     * <p>The third implementer's draft of [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     * renamed the
     * `id_documents_verification_methods_supported` server metadata to
     * `documents_methods_supported`.
     */
    public ServiceUpdateApiRequestBody withSupportedDocumentsMethods(@Nullable List<String> supportedDocumentsMethods) {
        this.supportedDocumentsMethods = supportedDocumentsMethods;
        return this;
    }


    /**
     * Document validation methods supported by this service. This property
     * corresponds to the `documents_validation_methods_supported` server
     * metadata which was added by the third implementer's draft of &lt;a href=
     * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     */
    public ServiceUpdateApiRequestBody withSupportedDocumentsValidationMethods(@Nullable List<String> supportedDocumentsValidationMethods) {
        this.supportedDocumentsValidationMethods = supportedDocumentsValidationMethods;
        return this;
    }


    /**
     * Document verification methods supported by this service. This property
     * corresponds to the `documents_verification_methods_supported` server
     * metadata which was added by the third implementer's draft of
     * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     */
    public ServiceUpdateApiRequestBody withSupportedDocumentsVerificationMethods(@Nullable List<String> supportedDocumentsVerificationMethods) {
        this.supportedDocumentsVerificationMethods = supportedDocumentsVerificationMethods;
        return this;
    }


    /**
     * Electronic record types supported by this service. This property
     * corresponds to the `electronic_records_supported` server metadata
     * which was added by the third implementer's draft of
     * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
     */
    public ServiceUpdateApiRequestBody withSupportedElectronicRecords(@Nullable List<String> supportedElectronicRecords) {
        this.supportedElectronicRecords = supportedElectronicRecords;
        return this;
    }


    public ServiceUpdateApiRequestBody withSupportedClientRegistrationTypes(@Nullable List<ServiceUpdateApiSupportedClientRegistrationTypeRequest> supportedClientRegistrationTypes) {
        this.supportedClientRegistrationTypes = supportedClientRegistrationTypes;
        return this;
    }


    /**
     * The flag indicating whether to prohibit unidentifiable clients from
     * making token exchange requests.
     */
    public ServiceUpdateApiRequestBody withTokenExchangeByIdentifiableClientsOnly(@Nullable Boolean tokenExchangeByIdentifiableClientsOnly) {
        this.tokenExchangeByIdentifiableClientsOnly = tokenExchangeByIdentifiableClientsOnly;
        return this;
    }


    /**
     * The flag indicating whether to prohibit public clients from making
     * token exchange requests.
     */
    public ServiceUpdateApiRequestBody withTokenExchangeByConfidentialClientsOnly(@Nullable Boolean tokenExchangeByConfidentialClientsOnly) {
        this.tokenExchangeByConfidentialClientsOnly = tokenExchangeByConfidentialClientsOnly;
        return this;
    }


    /**
     * The flag indicating whether to prohibit clients that have no explicit
     * permission from making token exchange requests.
     */
    public ServiceUpdateApiRequestBody withTokenExchangeByPermittedClientsOnly(@Nullable Boolean tokenExchangeByPermittedClientsOnly) {
        this.tokenExchangeByPermittedClientsOnly = tokenExchangeByPermittedClientsOnly;
        return this;
    }


    /**
     * The flag indicating whether to reject token exchange requests which
     * use encrypted JWTs as input tokens.
     */
    public ServiceUpdateApiRequestBody withTokenExchangeEncryptedJwtRejected(@Nullable Boolean tokenExchangeEncryptedJwtRejected) {
        this.tokenExchangeEncryptedJwtRejected = tokenExchangeEncryptedJwtRejected;
        return this;
    }


    /**
     * The flag indicating whether to reject token exchange requests which
     * use unsigned JWTs as input tokens.
     */
    public ServiceUpdateApiRequestBody withTokenExchangeUnsignedJwtRejected(@Nullable Boolean tokenExchangeUnsignedJwtRejected) {
        this.tokenExchangeUnsignedJwtRejected = tokenExchangeUnsignedJwtRejected;
        return this;
    }


    /**
     * The flag indicating whether to prohibit unidentifiable clients from
     * using the grant type "urn:ietf:params:oauth:grant-type:jwt-bearer".
     */
    public ServiceUpdateApiRequestBody withJwtGrantByIdentifiableClientsOnly(@Nullable Boolean jwtGrantByIdentifiableClientsOnly) {
        this.jwtGrantByIdentifiableClientsOnly = jwtGrantByIdentifiableClientsOnly;
        return this;
    }


    /**
     * The flag indicating whether to reject token requests that use an
     * encrypted JWT as an authorization grant with the grant type
     * "urn:ietf:params:oauth:grant-type:jwt-bearer".
     */
    public ServiceUpdateApiRequestBody withJwtGrantEncryptedJwtRejected(@Nullable Boolean jwtGrantEncryptedJwtRejected) {
        this.jwtGrantEncryptedJwtRejected = jwtGrantEncryptedJwtRejected;
        return this;
    }


    /**
     * The flag indicating whether to reject token requests that use an
     * unsigned JWT as an authorization grant with the grant type
     * "urn:ietf:params:oauth:grant-type:jwt-bearer".
     */
    public ServiceUpdateApiRequestBody withJwtGrantUnsignedJwtRejected(@Nullable Boolean jwtGrantUnsignedJwtRejected) {
        this.jwtGrantUnsignedJwtRejected = jwtGrantUnsignedJwtRejected;
        return this;
    }


    /**
     * The flag indicating whether to block DCR (Dynamic Client Registration)
     * requests whose "software_id" has already been used previously.
     */
    public ServiceUpdateApiRequestBody withDcrDuplicateSoftwareIdBlocked(@Nullable Boolean dcrDuplicateSoftwareIdBlocked) {
        this.dcrDuplicateSoftwareIdBlocked = dcrDuplicateSoftwareIdBlocked;
        return this;
    }


    /**
     * The trust anchors that are referenced when this service resolves
     * trust chains of relying parties.
     * 
     * <p>If this property is empty, client registration fails regardless of
     * whether its type is `automatic` or `explicit`. It means
     * that OpenID Connect Federation 1.0 does not work.
     */
    public ServiceUpdateApiRequestBody withTrustAnchors(@Nullable List<ServiceUpdateApiTrustAnchorRequest> trustAnchors) {
        this.trustAnchors = trustAnchors;
        return this;
    }


    /**
     * The flag indicating whether the openid scope should be dropped from
     * scopes list assigned to access token issued when a refresh token grant
     * is used.
     */
    public ServiceUpdateApiRequestBody withOpenidDroppedOnRefreshWithoutOfflineAccess(@Nullable Boolean openidDroppedOnRefreshWithoutOfflineAccess) {
        this.openidDroppedOnRefreshWithoutOfflineAccess = openidDroppedOnRefreshWithoutOfflineAccess;
        return this;
    }


    /**
     * Supported document check methods. This property corresponds to the `documents_check_methods_supported`
     * server metadata which was added by the fourth implementer's draft of OpenID Connect for Identity
     * Assurance 1.0.
     */
    public ServiceUpdateApiRequestBody withSupportedDocumentsCheckMethods(@Nullable List<String> supportedDocumentsCheckMethods) {
        this.supportedDocumentsCheckMethods = supportedDocumentsCheckMethods;
        return this;
    }


    /**
     * The flag indicating whether this service signs responses from the resource server.
     */
    public ServiceUpdateApiRequestBody withRsResponseSigned(@Nullable Boolean rsResponseSigned) {
        this.rsResponseSigned = rsResponseSigned;
        return this;
    }


    /**
     * The duration of `c_nonce`.
     */
    public ServiceUpdateApiRequestBody withCnonceDuration(@Nullable Long cnonceDuration) {
        this.cnonceDuration = cnonceDuration;
        return this;
    }


    /**
     * Whether to require DPoP proof JWTs to include the `nonce` claim
     * whenever they are presented.
     */
    public ServiceUpdateApiRequestBody withDpopNonceRequired(@Nullable Boolean dpopNonceRequired) {
        this.dpopNonceRequired = dpopNonceRequired;
        return this;
    }


    /**
     * Get the flag indicating whether the feature of Verifiable Credentials
     * for this service is enabled or not.
     */
    public ServiceUpdateApiRequestBody withVerifiableCredentialsEnabled(@Nullable Boolean verifiableCredentialsEnabled) {
        this.verifiableCredentialsEnabled = verifiableCredentialsEnabled;
        return this;
    }


    /**
     * The URL at which the JWK Set document of the credential issuer is
     * exposed.
     */
    public ServiceUpdateApiRequestBody withCredentialJwksUri(@Nullable String credentialJwksUri) {
        this.credentialJwksUri = credentialJwksUri;
        return this;
    }


    /**
     * The default duration of credential offers in seconds.
     */
    public ServiceUpdateApiRequestBody withCredentialOfferDuration(@Nullable Long credentialOfferDuration) {
        this.credentialOfferDuration = credentialOfferDuration;
        return this;
    }


    /**
     * The duration of nonce values for DPoP proof JWTs in seconds.
     */
    public ServiceUpdateApiRequestBody withDpopNonceDuration(@Nullable Long dpopNonceDuration) {
        this.dpopNonceDuration = dpopNonceDuration;
        return this;
    }


    /**
     * The flag indicating whether token requests using the pre-authorized
     * code grant flow by unidentifiable clients are allowed.
     */
    public ServiceUpdateApiRequestBody withPreAuthorizedGrantAnonymousAccessSupported(@Nullable Boolean preAuthorizedGrantAnonymousAccessSupported) {
        this.preAuthorizedGrantAnonymousAccessSupported = preAuthorizedGrantAnonymousAccessSupported;
        return this;
    }


    /**
     * The duration of transaction ID in seconds that may be issued as a
     * result of a credential request or a batch credential request.
     */
    public ServiceUpdateApiRequestBody withCredentialTransactionDuration(@Nullable Long credentialTransactionDuration) {
        this.credentialTransactionDuration = credentialTransactionDuration;
        return this;
    }


    /**
     * The key ID of the key for signing introspection responses.
     */
    public ServiceUpdateApiRequestBody withIntrospectionSignatureKeyId(@Nullable String introspectionSignatureKeyId) {
        this.introspectionSignatureKeyId = introspectionSignatureKeyId;
        return this;
    }


    /**
     * The key ID of the key for signing introspection responses.
     */
    public ServiceUpdateApiRequestBody withResourceSignatureKeyId(@Nullable String resourceSignatureKeyId) {
        this.resourceSignatureKeyId = resourceSignatureKeyId;
        return this;
    }


    /**
     * The default length of user PINs.
     */
    public ServiceUpdateApiRequestBody withUserPinLength(@Nullable Integer userPinLength) {
        this.userPinLength = userPinLength;
        return this;
    }


    /**
     * The supported `prompt` values.
     */
    public ServiceUpdateApiRequestBody withSupportedPromptValues(@Nullable List<ServiceUpdateApiSupportedPromptValueRequest> supportedPromptValues) {
        this.supportedPromptValues = supportedPromptValues;
        return this;
    }


    /**
     * The flag indicating whether to enable the feature of ID token
     * reissuance in the refresh token flow.
     */
    public ServiceUpdateApiRequestBody withIdTokenReissuable(@Nullable Boolean idTokenReissuable) {
        this.idTokenReissuable = idTokenReissuable;
        return this;
    }


    /**
     * The JWK Set document containing private keys that are used to sign
     * verifiable credentials.
     */
    public ServiceUpdateApiRequestBody withCredentialJwks(@Nullable String credentialJwks) {
        this.credentialJwks = credentialJwks;
        return this;
    }


    /**
     * FAPI modes for this service.
     * 
     * <p>When the value of this property is not `null`, Authlete always processes requests to this service based
     * on the specified FAPI modes if the FAPI feature is enabled in Authlete and the FAPI profile is supported
     * by this service.
     * 
     * <p>For instance, when this property is set to an array containing `FAPI1_ADVANCED` only, Authlete always
     * processes requests to this service based on "Financial-grade API Security Profile 1.0 - Part 2:
     * Advanced" if the FAPI feature is enabled in Authlete and the FAPI profile is supported by this service.
     */
    public ServiceUpdateApiRequestBody withFapiModes(@Nullable List<ServiceUpdateApiFapiModeRequest> fapiModes) {
        this.fapiModes = fapiModes;
        return this;
    }


    /**
     * The default duration of verifiable credentials in seconds.
     */
    public ServiceUpdateApiRequestBody withCredentialDuration(@Nullable Long credentialDuration) {
        this.credentialDuration = credentialDuration;
        return this;
    }


    public ServiceUpdateApiRequestBody withCredentialIssuerMetadata(@Nullable ServiceUpdateApiCredentialIssuerMetadataRequest credentialIssuerMetadata) {
        this.credentialIssuerMetadata = credentialIssuerMetadata;
        return this;
    }


    /**
     * The type of the `aud` claim in ID tokens.
     */
    public ServiceUpdateApiRequestBody withIdTokenAudType(@Nullable String idTokenAudType) {
        this.idTokenAudType = idTokenAudType;
        return this;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ServiceUpdateApiRequestBody other = (ServiceUpdateApiRequestBody) o;
        return 
            Utils.enhancedDeepEquals(this.serviceName, other.serviceName) &&
            Utils.enhancedDeepEquals(this.issuer, other.issuer) &&
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.clientIdAliasEnabled, other.clientIdAliasEnabled) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.authenticationCallbackEndpoint, other.authenticationCallbackEndpoint) &&
            Utils.enhancedDeepEquals(this.authenticationCallbackApiKey, other.authenticationCallbackApiKey) &&
            Utils.enhancedDeepEquals(this.authenticationCallbackApiSecret, other.authenticationCallbackApiSecret) &&
            Utils.enhancedDeepEquals(this.supportedGrantTypes, other.supportedGrantTypes) &&
            Utils.enhancedDeepEquals(this.supportedResponseTypes, other.supportedResponseTypes) &&
            Utils.enhancedDeepEquals(this.supportedAuthorizationDetailsTypes, other.supportedAuthorizationDetailsTypes) &&
            Utils.enhancedDeepEquals(this.supportedServiceProfiles, other.supportedServiceProfiles) &&
            Utils.enhancedDeepEquals(this.errorDescriptionOmitted, other.errorDescriptionOmitted) &&
            Utils.enhancedDeepEquals(this.errorUriOmitted, other.errorUriOmitted) &&
            Utils.enhancedDeepEquals(this.authorizationEndpoint, other.authorizationEndpoint) &&
            Utils.enhancedDeepEquals(this.directAuthorizationEndpointEnabled, other.directAuthorizationEndpointEnabled) &&
            Utils.enhancedDeepEquals(this.supportedUiLocales, other.supportedUiLocales) &&
            Utils.enhancedDeepEquals(this.supportedDisplays, other.supportedDisplays) &&
            Utils.enhancedDeepEquals(this.pkceRequired, other.pkceRequired) &&
            Utils.enhancedDeepEquals(this.pkceS256Required, other.pkceS256Required) &&
            Utils.enhancedDeepEquals(this.authorizationResponseDuration, other.authorizationResponseDuration) &&
            Utils.enhancedDeepEquals(this.tokenEndpoint, other.tokenEndpoint) &&
            Utils.enhancedDeepEquals(this.directTokenEndpointEnabled, other.directTokenEndpointEnabled) &&
            Utils.enhancedDeepEquals(this.supportedTokenAuthMethods, other.supportedTokenAuthMethods) &&
            Utils.enhancedDeepEquals(this.missingClientIdAllowed, other.missingClientIdAllowed) &&
            Utils.enhancedDeepEquals(this.revocationEndpoint, other.revocationEndpoint) &&
            Utils.enhancedDeepEquals(this.directRevocationEndpointEnabled, other.directRevocationEndpointEnabled) &&
            Utils.enhancedDeepEquals(this.supportedRevocationAuthMethods, other.supportedRevocationAuthMethods) &&
            Utils.enhancedDeepEquals(this.introspectionEndpoint, other.introspectionEndpoint) &&
            Utils.enhancedDeepEquals(this.directIntrospectionEndpointEnabled, other.directIntrospectionEndpointEnabled) &&
            Utils.enhancedDeepEquals(this.supportedIntrospectionAuthMethods, other.supportedIntrospectionAuthMethods) &&
            Utils.enhancedDeepEquals(this.pushedAuthReqEndpoint, other.pushedAuthReqEndpoint) &&
            Utils.enhancedDeepEquals(this.pushedAuthReqDuration, other.pushedAuthReqDuration) &&
            Utils.enhancedDeepEquals(this.parRequired, other.parRequired) &&
            Utils.enhancedDeepEquals(this.requestObjectRequired, other.requestObjectRequired) &&
            Utils.enhancedDeepEquals(this.traditionalRequestObjectProcessingApplied, other.traditionalRequestObjectProcessingApplied) &&
            Utils.enhancedDeepEquals(this.mutualTlsValidatePkiCertChain, other.mutualTlsValidatePkiCertChain) &&
            Utils.enhancedDeepEquals(this.trustedRootCertificates, other.trustedRootCertificates) &&
            Utils.enhancedDeepEquals(this.mtlsEndpointAliases, other.mtlsEndpointAliases) &&
            Utils.enhancedDeepEquals(this.accessTokenType, other.accessTokenType) &&
            Utils.enhancedDeepEquals(this.tlsClientCertificateBoundAccessTokens, other.tlsClientCertificateBoundAccessTokens) &&
            Utils.enhancedDeepEquals(this.accessTokenDuration, other.accessTokenDuration) &&
            Utils.enhancedDeepEquals(this.singleAccessTokenPerSubject, other.singleAccessTokenPerSubject) &&
            Utils.enhancedDeepEquals(this.accessTokenSignAlg, other.accessTokenSignAlg) &&
            Utils.enhancedDeepEquals(this.accessTokenSignatureKeyId, other.accessTokenSignatureKeyId) &&
            Utils.enhancedDeepEquals(this.refreshTokenDuration, other.refreshTokenDuration) &&
            Utils.enhancedDeepEquals(this.refreshTokenDurationKept, other.refreshTokenDurationKept) &&
            Utils.enhancedDeepEquals(this.refreshTokenDurationReset, other.refreshTokenDurationReset) &&
            Utils.enhancedDeepEquals(this.refreshTokenKept, other.refreshTokenKept) &&
            Utils.enhancedDeepEquals(this.supportedScopes, other.supportedScopes) &&
            Utils.enhancedDeepEquals(this.scopeRequired, other.scopeRequired) &&
            Utils.enhancedDeepEquals(this.idTokenDuration, other.idTokenDuration) &&
            Utils.enhancedDeepEquals(this.allowableClockSkew, other.allowableClockSkew) &&
            Utils.enhancedDeepEquals(this.supportedClaimTypes, other.supportedClaimTypes) &&
            Utils.enhancedDeepEquals(this.supportedClaimLocales, other.supportedClaimLocales) &&
            Utils.enhancedDeepEquals(this.supportedClaims, other.supportedClaims) &&
            Utils.enhancedDeepEquals(this.claimShortcutRestrictive, other.claimShortcutRestrictive) &&
            Utils.enhancedDeepEquals(this.jwksUri, other.jwksUri) &&
            Utils.enhancedDeepEquals(this.directJwksEndpointEnabled, other.directJwksEndpointEnabled) &&
            Utils.enhancedDeepEquals(this.jwks, other.jwks) &&
            Utils.enhancedDeepEquals(this.idTokenSignatureKeyId, other.idTokenSignatureKeyId) &&
            Utils.enhancedDeepEquals(this.userInfoSignatureKeyId, other.userInfoSignatureKeyId) &&
            Utils.enhancedDeepEquals(this.authorizationSignatureKeyId, other.authorizationSignatureKeyId) &&
            Utils.enhancedDeepEquals(this.userInfoEndpoint, other.userInfoEndpoint) &&
            Utils.enhancedDeepEquals(this.directUserInfoEndpointEnabled, other.directUserInfoEndpointEnabled) &&
            Utils.enhancedDeepEquals(this.dynamicRegistrationSupported, other.dynamicRegistrationSupported) &&
            Utils.enhancedDeepEquals(this.registrationEndpoint, other.registrationEndpoint) &&
            Utils.enhancedDeepEquals(this.registrationManagementEndpoint, other.registrationManagementEndpoint) &&
            Utils.enhancedDeepEquals(this.policyUri, other.policyUri) &&
            Utils.enhancedDeepEquals(this.tosUri, other.tosUri) &&
            Utils.enhancedDeepEquals(this.serviceDocumentation, other.serviceDocumentation) &&
            Utils.enhancedDeepEquals(this.backchannelAuthenticationEndpoint, other.backchannelAuthenticationEndpoint) &&
            Utils.enhancedDeepEquals(this.supportedBackchannelTokenDeliveryModes, other.supportedBackchannelTokenDeliveryModes) &&
            Utils.enhancedDeepEquals(this.backchannelAuthReqIdDuration, other.backchannelAuthReqIdDuration) &&
            Utils.enhancedDeepEquals(this.backchannelPollingInterval, other.backchannelPollingInterval) &&
            Utils.enhancedDeepEquals(this.backchannelUserCodeParameterSupported, other.backchannelUserCodeParameterSupported) &&
            Utils.enhancedDeepEquals(this.backchannelBindingMessageRequiredInFapi, other.backchannelBindingMessageRequiredInFapi) &&
            Utils.enhancedDeepEquals(this.deviceAuthorizationEndpoint, other.deviceAuthorizationEndpoint) &&
            Utils.enhancedDeepEquals(this.deviceVerificationUri, other.deviceVerificationUri) &&
            Utils.enhancedDeepEquals(this.deviceVerificationUriComplete, other.deviceVerificationUriComplete) &&
            Utils.enhancedDeepEquals(this.deviceFlowCodeDuration, other.deviceFlowCodeDuration) &&
            Utils.enhancedDeepEquals(this.deviceFlowPollingInterval, other.deviceFlowPollingInterval) &&
            Utils.enhancedDeepEquals(this.userCodeCharset, other.userCodeCharset) &&
            Utils.enhancedDeepEquals(this.userCodeLength, other.userCodeLength) &&
            Utils.enhancedDeepEquals(this.supportedTrustFrameworks, other.supportedTrustFrameworks) &&
            Utils.enhancedDeepEquals(this.supportedEvidence, other.supportedEvidence) &&
            Utils.enhancedDeepEquals(this.supportedIdentityDocuments, other.supportedIdentityDocuments) &&
            Utils.enhancedDeepEquals(this.supportedVerificationMethods, other.supportedVerificationMethods) &&
            Utils.enhancedDeepEquals(this.supportedVerifiedClaims, other.supportedVerifiedClaims) &&
            Utils.enhancedDeepEquals(this.verifiedClaimsValidationSchemaSet, other.verifiedClaimsValidationSchemaSet) &&
            Utils.enhancedDeepEquals(this.attributes, other.attributes) &&
            Utils.enhancedDeepEquals(this.nbfOptional, other.nbfOptional) &&
            Utils.enhancedDeepEquals(this.issSuppressed, other.issSuppressed) &&
            Utils.enhancedDeepEquals(this.supportedCustomClientMetadata, other.supportedCustomClientMetadata) &&
            Utils.enhancedDeepEquals(this.tokenExpirationLinked, other.tokenExpirationLinked) &&
            Utils.enhancedDeepEquals(this.frontChannelRequestObjectEncryptionRequired, other.frontChannelRequestObjectEncryptionRequired) &&
            Utils.enhancedDeepEquals(this.requestObjectEncryptionAlgMatchRequired, other.requestObjectEncryptionAlgMatchRequired) &&
            Utils.enhancedDeepEquals(this.requestObjectEncryptionEncMatchRequired, other.requestObjectEncryptionEncMatchRequired) &&
            Utils.enhancedDeepEquals(this.hsmEnabled, other.hsmEnabled) &&
            Utils.enhancedDeepEquals(this.hsks, other.hsks) &&
            Utils.enhancedDeepEquals(this.grantManagementEndpoint, other.grantManagementEndpoint) &&
            Utils.enhancedDeepEquals(this.grantManagementActionRequired, other.grantManagementActionRequired) &&
            Utils.enhancedDeepEquals(this.unauthorizedOnClientConfigSupported, other.unauthorizedOnClientConfigSupported) &&
            Utils.enhancedDeepEquals(this.dcrScopeUsedAsRequestable, other.dcrScopeUsedAsRequestable) &&
            Utils.enhancedDeepEquals(this.endSessionEndpoint, other.endSessionEndpoint) &&
            Utils.enhancedDeepEquals(this.loopbackRedirectionUriVariable, other.loopbackRedirectionUriVariable) &&
            Utils.enhancedDeepEquals(this.requestObjectAudienceChecked, other.requestObjectAudienceChecked) &&
            Utils.enhancedDeepEquals(this.accessTokenForExternalAttachmentEmbedded, other.accessTokenForExternalAttachmentEmbedded) &&
            Utils.enhancedDeepEquals(this.authorityHints, other.authorityHints) &&
            Utils.enhancedDeepEquals(this.federationEnabled, other.federationEnabled) &&
            Utils.enhancedDeepEquals(this.federationJwks, other.federationJwks) &&
            Utils.enhancedDeepEquals(this.federationSignatureKeyId, other.federationSignatureKeyId) &&
            Utils.enhancedDeepEquals(this.federationConfigurationDuration, other.federationConfigurationDuration) &&
            Utils.enhancedDeepEquals(this.federationRegistrationEndpoint, other.federationRegistrationEndpoint) &&
            Utils.enhancedDeepEquals(this.organizationName, other.organizationName) &&
            Utils.enhancedDeepEquals(this.predefinedTransformedClaims, other.predefinedTransformedClaims) &&
            Utils.enhancedDeepEquals(this.refreshTokenIdempotent, other.refreshTokenIdempotent) &&
            Utils.enhancedDeepEquals(this.signedJwksUri, other.signedJwksUri) &&
            Utils.enhancedDeepEquals(this.supportedAttachments, other.supportedAttachments) &&
            Utils.enhancedDeepEquals(this.supportedDigestAlgorithms, other.supportedDigestAlgorithms) &&
            Utils.enhancedDeepEquals(this.supportedDocuments, other.supportedDocuments) &&
            Utils.enhancedDeepEquals(this.supportedDocumentsMethods, other.supportedDocumentsMethods) &&
            Utils.enhancedDeepEquals(this.supportedDocumentsValidationMethods, other.supportedDocumentsValidationMethods) &&
            Utils.enhancedDeepEquals(this.supportedDocumentsVerificationMethods, other.supportedDocumentsVerificationMethods) &&
            Utils.enhancedDeepEquals(this.supportedElectronicRecords, other.supportedElectronicRecords) &&
            Utils.enhancedDeepEquals(this.supportedClientRegistrationTypes, other.supportedClientRegistrationTypes) &&
            Utils.enhancedDeepEquals(this.tokenExchangeByIdentifiableClientsOnly, other.tokenExchangeByIdentifiableClientsOnly) &&
            Utils.enhancedDeepEquals(this.tokenExchangeByConfidentialClientsOnly, other.tokenExchangeByConfidentialClientsOnly) &&
            Utils.enhancedDeepEquals(this.tokenExchangeByPermittedClientsOnly, other.tokenExchangeByPermittedClientsOnly) &&
            Utils.enhancedDeepEquals(this.tokenExchangeEncryptedJwtRejected, other.tokenExchangeEncryptedJwtRejected) &&
            Utils.enhancedDeepEquals(this.tokenExchangeUnsignedJwtRejected, other.tokenExchangeUnsignedJwtRejected) &&
            Utils.enhancedDeepEquals(this.jwtGrantByIdentifiableClientsOnly, other.jwtGrantByIdentifiableClientsOnly) &&
            Utils.enhancedDeepEquals(this.jwtGrantEncryptedJwtRejected, other.jwtGrantEncryptedJwtRejected) &&
            Utils.enhancedDeepEquals(this.jwtGrantUnsignedJwtRejected, other.jwtGrantUnsignedJwtRejected) &&
            Utils.enhancedDeepEquals(this.dcrDuplicateSoftwareIdBlocked, other.dcrDuplicateSoftwareIdBlocked) &&
            Utils.enhancedDeepEquals(this.trustAnchors, other.trustAnchors) &&
            Utils.enhancedDeepEquals(this.openidDroppedOnRefreshWithoutOfflineAccess, other.openidDroppedOnRefreshWithoutOfflineAccess) &&
            Utils.enhancedDeepEquals(this.supportedDocumentsCheckMethods, other.supportedDocumentsCheckMethods) &&
            Utils.enhancedDeepEquals(this.rsResponseSigned, other.rsResponseSigned) &&
            Utils.enhancedDeepEquals(this.cnonceDuration, other.cnonceDuration) &&
            Utils.enhancedDeepEquals(this.dpopNonceRequired, other.dpopNonceRequired) &&
            Utils.enhancedDeepEquals(this.verifiableCredentialsEnabled, other.verifiableCredentialsEnabled) &&
            Utils.enhancedDeepEquals(this.credentialJwksUri, other.credentialJwksUri) &&
            Utils.enhancedDeepEquals(this.credentialOfferDuration, other.credentialOfferDuration) &&
            Utils.enhancedDeepEquals(this.dpopNonceDuration, other.dpopNonceDuration) &&
            Utils.enhancedDeepEquals(this.preAuthorizedGrantAnonymousAccessSupported, other.preAuthorizedGrantAnonymousAccessSupported) &&
            Utils.enhancedDeepEquals(this.credentialTransactionDuration, other.credentialTransactionDuration) &&
            Utils.enhancedDeepEquals(this.introspectionSignatureKeyId, other.introspectionSignatureKeyId) &&
            Utils.enhancedDeepEquals(this.resourceSignatureKeyId, other.resourceSignatureKeyId) &&
            Utils.enhancedDeepEquals(this.userPinLength, other.userPinLength) &&
            Utils.enhancedDeepEquals(this.supportedPromptValues, other.supportedPromptValues) &&
            Utils.enhancedDeepEquals(this.idTokenReissuable, other.idTokenReissuable) &&
            Utils.enhancedDeepEquals(this.credentialJwks, other.credentialJwks) &&
            Utils.enhancedDeepEquals(this.fapiModes, other.fapiModes) &&
            Utils.enhancedDeepEquals(this.credentialDuration, other.credentialDuration) &&
            Utils.enhancedDeepEquals(this.credentialIssuerMetadata, other.credentialIssuerMetadata) &&
            Utils.enhancedDeepEquals(this.idTokenAudType, other.idTokenAudType);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            serviceName, issuer, description,
            clientIdAliasEnabled, metadata, authenticationCallbackEndpoint,
            authenticationCallbackApiKey, authenticationCallbackApiSecret, supportedGrantTypes,
            supportedResponseTypes, supportedAuthorizationDetailsTypes, supportedServiceProfiles,
            errorDescriptionOmitted, errorUriOmitted, authorizationEndpoint,
            directAuthorizationEndpointEnabled, supportedUiLocales, supportedDisplays,
            pkceRequired, pkceS256Required, authorizationResponseDuration,
            tokenEndpoint, directTokenEndpointEnabled, supportedTokenAuthMethods,
            missingClientIdAllowed, revocationEndpoint, directRevocationEndpointEnabled,
            supportedRevocationAuthMethods, introspectionEndpoint, directIntrospectionEndpointEnabled,
            supportedIntrospectionAuthMethods, pushedAuthReqEndpoint, pushedAuthReqDuration,
            parRequired, requestObjectRequired, traditionalRequestObjectProcessingApplied,
            mutualTlsValidatePkiCertChain, trustedRootCertificates, mtlsEndpointAliases,
            accessTokenType, tlsClientCertificateBoundAccessTokens, accessTokenDuration,
            singleAccessTokenPerSubject, accessTokenSignAlg, accessTokenSignatureKeyId,
            refreshTokenDuration, refreshTokenDurationKept, refreshTokenDurationReset,
            refreshTokenKept, supportedScopes, scopeRequired,
            idTokenDuration, allowableClockSkew, supportedClaimTypes,
            supportedClaimLocales, supportedClaims, claimShortcutRestrictive,
            jwksUri, directJwksEndpointEnabled, jwks,
            idTokenSignatureKeyId, userInfoSignatureKeyId, authorizationSignatureKeyId,
            userInfoEndpoint, directUserInfoEndpointEnabled, dynamicRegistrationSupported,
            registrationEndpoint, registrationManagementEndpoint, policyUri,
            tosUri, serviceDocumentation, backchannelAuthenticationEndpoint,
            supportedBackchannelTokenDeliveryModes, backchannelAuthReqIdDuration, backchannelPollingInterval,
            backchannelUserCodeParameterSupported, backchannelBindingMessageRequiredInFapi, deviceAuthorizationEndpoint,
            deviceVerificationUri, deviceVerificationUriComplete, deviceFlowCodeDuration,
            deviceFlowPollingInterval, userCodeCharset, userCodeLength,
            supportedTrustFrameworks, supportedEvidence, supportedIdentityDocuments,
            supportedVerificationMethods, supportedVerifiedClaims, verifiedClaimsValidationSchemaSet,
            attributes, nbfOptional, issSuppressed,
            supportedCustomClientMetadata, tokenExpirationLinked, frontChannelRequestObjectEncryptionRequired,
            requestObjectEncryptionAlgMatchRequired, requestObjectEncryptionEncMatchRequired, hsmEnabled,
            hsks, grantManagementEndpoint, grantManagementActionRequired,
            unauthorizedOnClientConfigSupported, dcrScopeUsedAsRequestable, endSessionEndpoint,
            loopbackRedirectionUriVariable, requestObjectAudienceChecked, accessTokenForExternalAttachmentEmbedded,
            authorityHints, federationEnabled, federationJwks,
            federationSignatureKeyId, federationConfigurationDuration, federationRegistrationEndpoint,
            organizationName, predefinedTransformedClaims, refreshTokenIdempotent,
            signedJwksUri, supportedAttachments, supportedDigestAlgorithms,
            supportedDocuments, supportedDocumentsMethods, supportedDocumentsValidationMethods,
            supportedDocumentsVerificationMethods, supportedElectronicRecords, supportedClientRegistrationTypes,
            tokenExchangeByIdentifiableClientsOnly, tokenExchangeByConfidentialClientsOnly, tokenExchangeByPermittedClientsOnly,
            tokenExchangeEncryptedJwtRejected, tokenExchangeUnsignedJwtRejected, jwtGrantByIdentifiableClientsOnly,
            jwtGrantEncryptedJwtRejected, jwtGrantUnsignedJwtRejected, dcrDuplicateSoftwareIdBlocked,
            trustAnchors, openidDroppedOnRefreshWithoutOfflineAccess, supportedDocumentsCheckMethods,
            rsResponseSigned, cnonceDuration, dpopNonceRequired,
            verifiableCredentialsEnabled, credentialJwksUri, credentialOfferDuration,
            dpopNonceDuration, preAuthorizedGrantAnonymousAccessSupported, credentialTransactionDuration,
            introspectionSignatureKeyId, resourceSignatureKeyId, userPinLength,
            supportedPromptValues, idTokenReissuable, credentialJwks,
            fapiModes, credentialDuration, credentialIssuerMetadata,
            idTokenAudType);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ServiceUpdateApiRequestBody.class,
                "serviceName", serviceName,
                "issuer", issuer,
                "description", description,
                "clientIdAliasEnabled", clientIdAliasEnabled,
                "metadata", metadata,
                "authenticationCallbackEndpoint", authenticationCallbackEndpoint,
                "authenticationCallbackApiKey", authenticationCallbackApiKey,
                "authenticationCallbackApiSecret", authenticationCallbackApiSecret,
                "supportedGrantTypes", supportedGrantTypes,
                "supportedResponseTypes", supportedResponseTypes,
                "supportedAuthorizationDetailsTypes", supportedAuthorizationDetailsTypes,
                "supportedServiceProfiles", supportedServiceProfiles,
                "errorDescriptionOmitted", errorDescriptionOmitted,
                "errorUriOmitted", errorUriOmitted,
                "authorizationEndpoint", authorizationEndpoint,
                "directAuthorizationEndpointEnabled", directAuthorizationEndpointEnabled,
                "supportedUiLocales", supportedUiLocales,
                "supportedDisplays", supportedDisplays,
                "pkceRequired", pkceRequired,
                "pkceS256Required", pkceS256Required,
                "authorizationResponseDuration", authorizationResponseDuration,
                "tokenEndpoint", tokenEndpoint,
                "directTokenEndpointEnabled", directTokenEndpointEnabled,
                "supportedTokenAuthMethods", supportedTokenAuthMethods,
                "missingClientIdAllowed", missingClientIdAllowed,
                "revocationEndpoint", revocationEndpoint,
                "directRevocationEndpointEnabled", directRevocationEndpointEnabled,
                "supportedRevocationAuthMethods", supportedRevocationAuthMethods,
                "introspectionEndpoint", introspectionEndpoint,
                "directIntrospectionEndpointEnabled", directIntrospectionEndpointEnabled,
                "supportedIntrospectionAuthMethods", supportedIntrospectionAuthMethods,
                "pushedAuthReqEndpoint", pushedAuthReqEndpoint,
                "pushedAuthReqDuration", pushedAuthReqDuration,
                "parRequired", parRequired,
                "requestObjectRequired", requestObjectRequired,
                "traditionalRequestObjectProcessingApplied", traditionalRequestObjectProcessingApplied,
                "mutualTlsValidatePkiCertChain", mutualTlsValidatePkiCertChain,
                "trustedRootCertificates", trustedRootCertificates,
                "mtlsEndpointAliases", mtlsEndpointAliases,
                "accessTokenType", accessTokenType,
                "tlsClientCertificateBoundAccessTokens", tlsClientCertificateBoundAccessTokens,
                "accessTokenDuration", accessTokenDuration,
                "singleAccessTokenPerSubject", singleAccessTokenPerSubject,
                "accessTokenSignAlg", accessTokenSignAlg,
                "accessTokenSignatureKeyId", accessTokenSignatureKeyId,
                "refreshTokenDuration", refreshTokenDuration,
                "refreshTokenDurationKept", refreshTokenDurationKept,
                "refreshTokenDurationReset", refreshTokenDurationReset,
                "refreshTokenKept", refreshTokenKept,
                "supportedScopes", supportedScopes,
                "scopeRequired", scopeRequired,
                "idTokenDuration", idTokenDuration,
                "allowableClockSkew", allowableClockSkew,
                "supportedClaimTypes", supportedClaimTypes,
                "supportedClaimLocales", supportedClaimLocales,
                "supportedClaims", supportedClaims,
                "claimShortcutRestrictive", claimShortcutRestrictive,
                "jwksUri", jwksUri,
                "directJwksEndpointEnabled", directJwksEndpointEnabled,
                "jwks", jwks,
                "idTokenSignatureKeyId", idTokenSignatureKeyId,
                "userInfoSignatureKeyId", userInfoSignatureKeyId,
                "authorizationSignatureKeyId", authorizationSignatureKeyId,
                "userInfoEndpoint", userInfoEndpoint,
                "directUserInfoEndpointEnabled", directUserInfoEndpointEnabled,
                "dynamicRegistrationSupported", dynamicRegistrationSupported,
                "registrationEndpoint", registrationEndpoint,
                "registrationManagementEndpoint", registrationManagementEndpoint,
                "policyUri", policyUri,
                "tosUri", tosUri,
                "serviceDocumentation", serviceDocumentation,
                "backchannelAuthenticationEndpoint", backchannelAuthenticationEndpoint,
                "supportedBackchannelTokenDeliveryModes", supportedBackchannelTokenDeliveryModes,
                "backchannelAuthReqIdDuration", backchannelAuthReqIdDuration,
                "backchannelPollingInterval", backchannelPollingInterval,
                "backchannelUserCodeParameterSupported", backchannelUserCodeParameterSupported,
                "backchannelBindingMessageRequiredInFapi", backchannelBindingMessageRequiredInFapi,
                "deviceAuthorizationEndpoint", deviceAuthorizationEndpoint,
                "deviceVerificationUri", deviceVerificationUri,
                "deviceVerificationUriComplete", deviceVerificationUriComplete,
                "deviceFlowCodeDuration", deviceFlowCodeDuration,
                "deviceFlowPollingInterval", deviceFlowPollingInterval,
                "userCodeCharset", userCodeCharset,
                "userCodeLength", userCodeLength,
                "supportedTrustFrameworks", supportedTrustFrameworks,
                "supportedEvidence", supportedEvidence,
                "supportedIdentityDocuments", supportedIdentityDocuments,
                "supportedVerificationMethods", supportedVerificationMethods,
                "supportedVerifiedClaims", supportedVerifiedClaims,
                "verifiedClaimsValidationSchemaSet", verifiedClaimsValidationSchemaSet,
                "attributes", attributes,
                "nbfOptional", nbfOptional,
                "issSuppressed", issSuppressed,
                "supportedCustomClientMetadata", supportedCustomClientMetadata,
                "tokenExpirationLinked", tokenExpirationLinked,
                "frontChannelRequestObjectEncryptionRequired", frontChannelRequestObjectEncryptionRequired,
                "requestObjectEncryptionAlgMatchRequired", requestObjectEncryptionAlgMatchRequired,
                "requestObjectEncryptionEncMatchRequired", requestObjectEncryptionEncMatchRequired,
                "hsmEnabled", hsmEnabled,
                "hsks", hsks,
                "grantManagementEndpoint", grantManagementEndpoint,
                "grantManagementActionRequired", grantManagementActionRequired,
                "unauthorizedOnClientConfigSupported", unauthorizedOnClientConfigSupported,
                "dcrScopeUsedAsRequestable", dcrScopeUsedAsRequestable,
                "endSessionEndpoint", endSessionEndpoint,
                "loopbackRedirectionUriVariable", loopbackRedirectionUriVariable,
                "requestObjectAudienceChecked", requestObjectAudienceChecked,
                "accessTokenForExternalAttachmentEmbedded", accessTokenForExternalAttachmentEmbedded,
                "authorityHints", authorityHints,
                "federationEnabled", federationEnabled,
                "federationJwks", federationJwks,
                "federationSignatureKeyId", federationSignatureKeyId,
                "federationConfigurationDuration", federationConfigurationDuration,
                "federationRegistrationEndpoint", federationRegistrationEndpoint,
                "organizationName", organizationName,
                "predefinedTransformedClaims", predefinedTransformedClaims,
                "refreshTokenIdempotent", refreshTokenIdempotent,
                "signedJwksUri", signedJwksUri,
                "supportedAttachments", supportedAttachments,
                "supportedDigestAlgorithms", supportedDigestAlgorithms,
                "supportedDocuments", supportedDocuments,
                "supportedDocumentsMethods", supportedDocumentsMethods,
                "supportedDocumentsValidationMethods", supportedDocumentsValidationMethods,
                "supportedDocumentsVerificationMethods", supportedDocumentsVerificationMethods,
                "supportedElectronicRecords", supportedElectronicRecords,
                "supportedClientRegistrationTypes", supportedClientRegistrationTypes,
                "tokenExchangeByIdentifiableClientsOnly", tokenExchangeByIdentifiableClientsOnly,
                "tokenExchangeByConfidentialClientsOnly", tokenExchangeByConfidentialClientsOnly,
                "tokenExchangeByPermittedClientsOnly", tokenExchangeByPermittedClientsOnly,
                "tokenExchangeEncryptedJwtRejected", tokenExchangeEncryptedJwtRejected,
                "tokenExchangeUnsignedJwtRejected", tokenExchangeUnsignedJwtRejected,
                "jwtGrantByIdentifiableClientsOnly", jwtGrantByIdentifiableClientsOnly,
                "jwtGrantEncryptedJwtRejected", jwtGrantEncryptedJwtRejected,
                "jwtGrantUnsignedJwtRejected", jwtGrantUnsignedJwtRejected,
                "dcrDuplicateSoftwareIdBlocked", dcrDuplicateSoftwareIdBlocked,
                "trustAnchors", trustAnchors,
                "openidDroppedOnRefreshWithoutOfflineAccess", openidDroppedOnRefreshWithoutOfflineAccess,
                "supportedDocumentsCheckMethods", supportedDocumentsCheckMethods,
                "rsResponseSigned", rsResponseSigned,
                "cnonceDuration", cnonceDuration,
                "dpopNonceRequired", dpopNonceRequired,
                "verifiableCredentialsEnabled", verifiableCredentialsEnabled,
                "credentialJwksUri", credentialJwksUri,
                "credentialOfferDuration", credentialOfferDuration,
                "dpopNonceDuration", dpopNonceDuration,
                "preAuthorizedGrantAnonymousAccessSupported", preAuthorizedGrantAnonymousAccessSupported,
                "credentialTransactionDuration", credentialTransactionDuration,
                "introspectionSignatureKeyId", introspectionSignatureKeyId,
                "resourceSignatureKeyId", resourceSignatureKeyId,
                "userPinLength", userPinLength,
                "supportedPromptValues", supportedPromptValues,
                "idTokenReissuable", idTokenReissuable,
                "credentialJwks", credentialJwks,
                "fapiModes", fapiModes,
                "credentialDuration", credentialDuration,
                "credentialIssuerMetadata", credentialIssuerMetadata,
                "idTokenAudType", idTokenAudType);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String serviceName;

        private String issuer;

        private String description;

        private Boolean clientIdAliasEnabled;

        private List<ServiceUpdateApiMetadatumRequest> metadata;

        private String authenticationCallbackEndpoint;

        private String authenticationCallbackApiKey;

        private String authenticationCallbackApiSecret;

        private List<ServiceUpdateApiSupportedGrantTypeRequest> supportedGrantTypes;

        private List<ServiceUpdateApiSupportedResponseTypeRequest> supportedResponseTypes;

        private List<String> supportedAuthorizationDetailsTypes;

        private List<ServiceUpdateApiSupportedServiceProfileRequest> supportedServiceProfiles;

        private Boolean errorDescriptionOmitted;

        private Boolean errorUriOmitted;

        private String authorizationEndpoint;

        private Boolean directAuthorizationEndpointEnabled;

        private List<String> supportedUiLocales;

        private List<ServiceUpdateApiSupportedDisplayRequest> supportedDisplays;

        private Boolean pkceRequired;

        private Boolean pkceS256Required;

        private Long authorizationResponseDuration;

        private String tokenEndpoint;

        private Boolean directTokenEndpointEnabled;

        private List<ServiceUpdateApiSupportedTokenAuthMethodRequest> supportedTokenAuthMethods;

        private Boolean missingClientIdAllowed;

        private String revocationEndpoint;

        private Boolean directRevocationEndpointEnabled;

        private List<ServiceUpdateApiSupportedRevocationAuthMethodRequest> supportedRevocationAuthMethods;

        private String introspectionEndpoint;

        private Boolean directIntrospectionEndpointEnabled;

        private List<ServiceUpdateApiSupportedIntrospectionAuthMethodRequest> supportedIntrospectionAuthMethods;

        private String pushedAuthReqEndpoint;

        private Long pushedAuthReqDuration;

        private Boolean parRequired;

        private Boolean requestObjectRequired;

        private Boolean traditionalRequestObjectProcessingApplied;

        private Boolean mutualTlsValidatePkiCertChain;

        private List<String> trustedRootCertificates;

        private List<ServiceUpdateApiMtlsEndpointAliasRequest> mtlsEndpointAliases;

        private String accessTokenType;

        private Boolean tlsClientCertificateBoundAccessTokens;

        private Long accessTokenDuration;

        private Boolean singleAccessTokenPerSubject;

        private ServiceUpdateApiAccessTokenSignAlgRequest accessTokenSignAlg;

        private String accessTokenSignatureKeyId;

        private Long refreshTokenDuration;

        private Boolean refreshTokenDurationKept;

        private Boolean refreshTokenDurationReset;

        private Boolean refreshTokenKept;

        private List<ServiceUpdateApiSupportedScopeRequest> supportedScopes;

        private Boolean scopeRequired;

        private Long idTokenDuration;

        private Integer allowableClockSkew;

        private List<ServiceUpdateApiSupportedClaimTypeRequest> supportedClaimTypes;

        private List<String> supportedClaimLocales;

        private List<String> supportedClaims;

        private Boolean claimShortcutRestrictive;

        private String jwksUri;

        private Boolean directJwksEndpointEnabled;

        private String jwks;

        private String idTokenSignatureKeyId;

        private String userInfoSignatureKeyId;

        private String authorizationSignatureKeyId;

        private String userInfoEndpoint;

        private Boolean directUserInfoEndpointEnabled;

        private Boolean dynamicRegistrationSupported;

        private String registrationEndpoint;

        private String registrationManagementEndpoint;

        private String policyUri;

        private String tosUri;

        private String serviceDocumentation;

        private String backchannelAuthenticationEndpoint;

        private List<ServiceUpdateApiSupportedBackchannelTokenDeliveryModeRequest> supportedBackchannelTokenDeliveryModes;

        private Integer backchannelAuthReqIdDuration;

        private Integer backchannelPollingInterval;

        private Boolean backchannelUserCodeParameterSupported;

        private Boolean backchannelBindingMessageRequiredInFapi;

        private String deviceAuthorizationEndpoint;

        private String deviceVerificationUri;

        private String deviceVerificationUriComplete;

        private Integer deviceFlowCodeDuration;

        private Integer deviceFlowPollingInterval;

        private ServiceUpdateApiUserCodeCharsetRequest userCodeCharset;

        private Integer userCodeLength;

        private List<String> supportedTrustFrameworks;

        private List<String> supportedEvidence;

        private List<String> supportedIdentityDocuments;

        private List<String> supportedVerificationMethods;

        private List<String> supportedVerifiedClaims;

        private ServiceUpdateApiVerifiedClaimsValidationSchemaSetRequest verifiedClaimsValidationSchemaSet;

        private List<ServiceUpdateApiAttributeRequest> attributes;

        private Boolean nbfOptional;

        private Boolean issSuppressed;

        private List<String> supportedCustomClientMetadata;

        private Boolean tokenExpirationLinked;

        private Boolean frontChannelRequestObjectEncryptionRequired;

        private Boolean requestObjectEncryptionAlgMatchRequired;

        private Boolean requestObjectEncryptionEncMatchRequired;

        private Boolean hsmEnabled;

        private List<ServiceUpdateApiHskRequest> hsks;

        private String grantManagementEndpoint;

        private Boolean grantManagementActionRequired;

        private Boolean unauthorizedOnClientConfigSupported;

        private Boolean dcrScopeUsedAsRequestable;

        private String endSessionEndpoint;

        private Boolean loopbackRedirectionUriVariable;

        private Boolean requestObjectAudienceChecked;

        private Boolean accessTokenForExternalAttachmentEmbedded;

        private List<String> authorityHints;

        private Boolean federationEnabled;

        private String federationJwks;

        private String federationSignatureKeyId;

        private Long federationConfigurationDuration;

        private String federationRegistrationEndpoint;

        private String organizationName;

        private String predefinedTransformedClaims;

        private Boolean refreshTokenIdempotent;

        private String signedJwksUri;

        private List<ServiceUpdateApiSupportedAttachmentRequest> supportedAttachments;

        private List<String> supportedDigestAlgorithms;

        private List<String> supportedDocuments;

        private List<String> supportedDocumentsMethods;

        private List<String> supportedDocumentsValidationMethods;

        private List<String> supportedDocumentsVerificationMethods;

        private List<String> supportedElectronicRecords;

        private List<ServiceUpdateApiSupportedClientRegistrationTypeRequest> supportedClientRegistrationTypes;

        private Boolean tokenExchangeByIdentifiableClientsOnly;

        private Boolean tokenExchangeByConfidentialClientsOnly;

        private Boolean tokenExchangeByPermittedClientsOnly;

        private Boolean tokenExchangeEncryptedJwtRejected;

        private Boolean tokenExchangeUnsignedJwtRejected;

        private Boolean jwtGrantByIdentifiableClientsOnly;

        private Boolean jwtGrantEncryptedJwtRejected;

        private Boolean jwtGrantUnsignedJwtRejected;

        private Boolean dcrDuplicateSoftwareIdBlocked;

        private List<ServiceUpdateApiTrustAnchorRequest> trustAnchors;

        private Boolean openidDroppedOnRefreshWithoutOfflineAccess;

        private List<String> supportedDocumentsCheckMethods;

        private Boolean rsResponseSigned;

        private Long cnonceDuration;

        private Boolean dpopNonceRequired;

        private Boolean verifiableCredentialsEnabled;

        private String credentialJwksUri;

        private Long credentialOfferDuration;

        private Long dpopNonceDuration;

        private Boolean preAuthorizedGrantAnonymousAccessSupported;

        private Long credentialTransactionDuration;

        private String introspectionSignatureKeyId;

        private String resourceSignatureKeyId;

        private Integer userPinLength;

        private List<ServiceUpdateApiSupportedPromptValueRequest> supportedPromptValues;

        private Boolean idTokenReissuable;

        private String credentialJwks;

        private List<ServiceUpdateApiFapiModeRequest> fapiModes;

        private Long credentialDuration;

        private ServiceUpdateApiCredentialIssuerMetadataRequest credentialIssuerMetadata;

        private String idTokenAudType;

        private Builder() {
          // force use of static builder() method
        }

        /**
         * The name of this service.
         */
        public Builder serviceName(@Nullable String serviceName) {
            this.serviceName = serviceName;
            return this;
        }

        /**
         * The issuer identifier of the service.
         * 
         * <p>A URL that starts with  https:// and has no query or fragment component.
         * 
         * <p>The value of this property is used as `iss` claim in an [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)
         * and `issuer` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder issuer(@Nullable String issuer) {
            this.issuer = issuer;
            return this;
        }

        /**
         * The description about the service.
         */
        public Builder description(@Nullable String description) {
            this.description = description;
            return this;
        }

        /**
         * Deprecated. Always `true`.
         */
        public Builder clientIdAliasEnabled(@Nullable Boolean clientIdAliasEnabled) {
            this.clientIdAliasEnabled = clientIdAliasEnabled;
            return this;
        }

        /**
         * The `metadata` of the service. The content of the returned array depends on contexts.
         * The predefined service metadata is listed in the following table.
         * 
         * <p>  | Key | Description |
         *   | --- | --- |
         *   | `clientCount` | The number of client applications which belong to this service.  |
         */
        public Builder metadata(@Nullable List<ServiceUpdateApiMetadatumRequest> metadata) {
            this.metadata = metadata;
            return this;
        }

        /**
         * A Web API endpoint for user authentication which is to be prepared on the service side.
         * 
         * <p>The endpoint must be implemented if you do not implement the UI at the authorization endpoint
         * but use the one provided by Authlete.
         * 
         * <p>The user authentication at the authorization endpoint provided by Authlete is performed by making
         * a `POST` request to this endpoint.
         */
        public Builder authenticationCallbackEndpoint(@Nullable String authenticationCallbackEndpoint) {
            this.authenticationCallbackEndpoint = authenticationCallbackEndpoint;
            return this;
        }

        /**
         * API key for basic authentication at the authentication callback endpoint.
         * 
         * <p>If the value is not empty, Authlete generates Authorization header for Basic authentication when
         * making a request to the authentication callback endpoint.
         */
        public Builder authenticationCallbackApiKey(@Nullable String authenticationCallbackApiKey) {
            this.authenticationCallbackApiKey = authenticationCallbackApiKey;
            return this;
        }

        /**
         * API secret for `basic` authentication at the authentication callback endpoint.
         */
        public Builder authenticationCallbackApiSecret(@Nullable String authenticationCallbackApiSecret) {
            this.authenticationCallbackApiSecret = authenticationCallbackApiSecret;
            return this;
        }

        /**
         * Values of `grant_type` request parameter that the service supports.
         * 
         * <p>The value of this property is used as `grant_types_supported property` in the
         * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder supportedGrantTypes(@Nullable List<ServiceUpdateApiSupportedGrantTypeRequest> supportedGrantTypes) {
            this.supportedGrantTypes = supportedGrantTypes;
            return this;
        }

        /**
         * Values of `response_type` request parameter that
         * the service supports. Valid values are listed in Response Type.
         * 
         * <p>The value of this property is used as `response_types_supported` property in the
         * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder supportedResponseTypes(@Nullable List<ServiceUpdateApiSupportedResponseTypeRequest> supportedResponseTypes) {
            this.supportedResponseTypes = supportedResponseTypes;
            return this;
        }

        /**
         * The supported data types that can be used as values of the type field in `authorization_details`.
         * 
         * <p>This property corresponds to the `authorization_details_types_supported` metadata. See "OAuth 2.0
         * Rich Authorization Requests" (RAR) for details.
         */
        public Builder supportedAuthorizationDetailsTypes(@Nullable List<String> supportedAuthorizationDetailsTypes) {
            this.supportedAuthorizationDetailsTypes = supportedAuthorizationDetailsTypes;
            return this;
        }

        /**
         * The profiles that this service supports.
         */
        public Builder supportedServiceProfiles(@Nullable List<ServiceUpdateApiSupportedServiceProfileRequest> supportedServiceProfiles) {
            this.supportedServiceProfiles = supportedServiceProfiles;
            return this;
        }

        /**
         * The flag to indicate whether the `error_description` response parameter is omitted.
         * 
         * <p>According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include
         * the `error_description` response parameter in error responses.
         * 
         * <p>If `true`, Authlete does not embed the `error_description` response parameter in error responses.
         */
        public Builder errorDescriptionOmitted(@Nullable Boolean errorDescriptionOmitted) {
            this.errorDescriptionOmitted = errorDescriptionOmitted;
            return this;
        }

        /**
         * The flag to indicate whether the `error_uri` response parameter is omitted.
         * 
         * <p>According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include the `error_uri` response parameter in error responses.
         * 
         * <p>If `true`, Authlete does not embed the
         * `error_uri` response parameter in error responses.
         */
        public Builder errorUriOmitted(@Nullable Boolean errorUriOmitted) {
            this.errorUriOmitted = errorUriOmitted;
            return this;
        }

        /**
         * The authorization endpoint of the service.
         * 
         * <p>A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/authorization`.
         * 
         * <p>The value of this property is used as `authorization_endpoint` property in the [OpenID Provider
         * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder authorizationEndpoint(@Nullable String authorizationEndpoint) {
            this.authorizationEndpoint = authorizationEndpoint;
            return this;
        }

        /**
         * The flag to indicate whether the direct authorization endpoint is enabled or not.
         * 
         * <p>The path of the endpoint is `/api/auth/authorization/direct/service-api-key`.
         */
        public Builder directAuthorizationEndpointEnabled(@Nullable Boolean directAuthorizationEndpointEnabled) {
            this.directAuthorizationEndpointEnabled = directAuthorizationEndpointEnabled;
            return this;
        }

        /**
         * UI locales that the service supports.
         * 
         * <p>Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646). For example, `en-US` and `ja-JP`.
         * 
         * <p>The value of this property is used as `ui_locales_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder supportedUiLocales(@Nullable List<String> supportedUiLocales) {
            this.supportedUiLocales = supportedUiLocales;
            return this;
        }

        /**
         * Values of `display` request parameter that service supports.
         * 
         * <p>The value of this property is used as `display_values_supported` property in the Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder supportedDisplays(@Nullable List<ServiceUpdateApiSupportedDisplayRequest> supportedDisplays) {
            this.supportedDisplays = supportedDisplays;
            return this;
        }

        /**
         * The flag to indicate whether the use of Proof Key for Code Exchange (PKCE) is always required for authorization requests by Authorization Code Flow.
         * 
         * <p>If `true`, `code_challenge` request parameter is always required for authorization requests using Authorization Code Flow.
         * 
         * <p>See [RFC 7636](https://tools.ietf.org/html/rfc7636) (Proof Key for Code Exchange by OAuth Public Clients) for details about `code_challenge` request parameter.
         */
        public Builder pkceRequired(@Nullable Boolean pkceRequired) {
            this.pkceRequired = pkceRequired;
            return this;
        }

        /**
         * The flag to indicate whether `S256` is always required as the code challenge method whenever [PKCE (RFC 7636)](https://tools.ietf.org/html/rfc7636) is used.
         * 
         * <p>If this flag is set to `true`, `code_challenge_method=S256` must be included in the authorization request
         * whenever it includes the `code_challenge` request parameter.
         * Neither omission of the `code_challenge_method` request parameter nor use of plain (`code_challenge_method=plain`) is allowed.
         */
        public Builder pkceS256Required(@Nullable Boolean pkceS256Required) {
            this.pkceS256Required = pkceS256Required;
            return this;
        }

        /**
         * The duration of authorization response JWTs in seconds.
         * 
         * <p>[Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
         * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
         * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
         * from the authorization endpoint will be packed into a JWT. This property is used to compute the
         * value of the `exp` claim of the JWT.
         */
        public Builder authorizationResponseDuration(@Nullable Long authorizationResponseDuration) {
            this.authorizationResponseDuration = authorizationResponseDuration;
            return this;
        }

        /**
         * The [token endpoint](https://tools.ietf.org/html/rfc6749#section-3.2) of the service.
         * 
         * <p>A URL that starts with `https://` and has not fragment component. For example, `https://example.com/auth/token`.
         * 
         * <p>The value of this property is used as `token_endpoint` property in the
         * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder tokenEndpoint(@Nullable String tokenEndpoint) {
            this.tokenEndpoint = tokenEndpoint;
            return this;
        }

        /**
         * The flag to indicate whether the direct token endpoint is enabled or not. The path of the endpoint
         * is `/api/auth/token/direct/service-api-key`.
         */
        public Builder directTokenEndpointEnabled(@Nullable Boolean directTokenEndpointEnabled) {
            this.directTokenEndpointEnabled = directTokenEndpointEnabled;
            return this;
        }

        /**
         * Client authentication methods supported by the token endpoint of the service.
         * 
         * <p>The value of this property is used as `token_endpoint_auth_methods_supports` property in the
         * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder supportedTokenAuthMethods(@Nullable List<ServiceUpdateApiSupportedTokenAuthMethodRequest> supportedTokenAuthMethods) {
            this.supportedTokenAuthMethods = supportedTokenAuthMethods;
            return this;
        }

        /**
         * The flag to indicate token requests from public clients without the `client_id` request parameter are allowed when the client can be guessed from `authorization_code` or `refresh_token`.
         * 
         * <p>This flag should not be set unless you have special reasons.
         */
        public Builder missingClientIdAllowed(@Nullable Boolean missingClientIdAllowed) {
            this.missingClientIdAllowed = missingClientIdAllowed;
            return this;
        }

        /**
         * The [revocation endpoint](https://tools.ietf.org/html/rfc7009) of the service.
         * 
         * <p>A URL that starts with `https://`. For example, `https://example.com/auth/revocation`.
         */
        public Builder revocationEndpoint(@Nullable String revocationEndpoint) {
            this.revocationEndpoint = revocationEndpoint;
            return this;
        }

        /**
         * The flag to indicate whether the direct revocation endpoint is enabled or not. The URL of the endpoint is `/api/auth/revocation/direct/service-api-key`.
         */
        public Builder directRevocationEndpointEnabled(@Nullable Boolean directRevocationEndpointEnabled) {
            this.directRevocationEndpointEnabled = directRevocationEndpointEnabled;
            return this;
        }

        /**
         * Client authentication methods supported at the revocation endpoint.
         */
        public Builder supportedRevocationAuthMethods(@Nullable List<ServiceUpdateApiSupportedRevocationAuthMethodRequest> supportedRevocationAuthMethods) {
            this.supportedRevocationAuthMethods = supportedRevocationAuthMethods;
            return this;
        }

        /**
         * The URI of the introspection endpoint.
         */
        public Builder introspectionEndpoint(@Nullable String introspectionEndpoint) {
            this.introspectionEndpoint = introspectionEndpoint;
            return this;
        }

        /**
         * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path of the endpoint is `/api/auth/userinfo/direct/{serviceApiKey}`.
         */
        public Builder directIntrospectionEndpointEnabled(@Nullable Boolean directIntrospectionEndpointEnabled) {
            this.directIntrospectionEndpointEnabled = directIntrospectionEndpointEnabled;
            return this;
        }

        /**
         * Client authentication methods supported at the introspection endpoint.
         */
        public Builder supportedIntrospectionAuthMethods(@Nullable List<ServiceUpdateApiSupportedIntrospectionAuthMethodRequest> supportedIntrospectionAuthMethods) {
            this.supportedIntrospectionAuthMethods = supportedIntrospectionAuthMethods;
            return this;
        }

        /**
         * The URI of the pushed authorization request endpoint.
         * 
         * <p>This property corresponds to the `pushed_authorization_request_endpoint` metadata defined in "[5. Authorization Server Metadata](https://tools.ietf.org/html/draft-lodderstedt-oauth-par#section-5)" of OAuth 2.0 Pushed Authorization Requests.
         */
        public Builder pushedAuthReqEndpoint(@Nullable String pushedAuthReqEndpoint) {
            this.pushedAuthReqEndpoint = pushedAuthReqEndpoint;
            return this;
        }

        /**
         * The duration of pushed authorization requests in seconds.
         * 
         * <p>[OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par)
         * defines an endpoint (called "pushed authorization request endpoint") which client applications
         * can register authorization requests into and get corresponding URIs (called "request URIs") from.
         * The issued URIs represent the registered authorization requests. The client applications can use
         * the URIs as the value of the `request_uri` request parameter in an authorization request.
         * 
         * <p>The property represents the duration of registered authorization requests and is used as the value
         * of the `expires_in` parameter in responses from the pushed authorization request endpoint.
         */
        public Builder pushedAuthReqDuration(@Nullable Long pushedAuthReqDuration) {
            this.pushedAuthReqDuration = pushedAuthReqDuration;
            return this;
        }

        /**
         * The flag to indicate whether this service requires that clients use the pushed authorization
         * request endpoint.
         * 
         * <p>This property corresponds to the `require_pushed_authorization_requests` server metadata defined
         * in [OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par).
         */
        public Builder parRequired(@Nullable Boolean parRequired) {
            this.parRequired = parRequired;
            return this;
        }

        /**
         * The flag to indicate whether this service requires that authorization requests always utilize
         * a request object by using either request or `request_uri` request parameter.
         * 
         * <p>If this flag is set to `true` and the value of `traditionalRequestObjectProcessingApplied` is
         * `false`, the value of `require_signed_request_object` server metadata of this service is reported
         * as `true` in the discovery document. The metadata is defined in JAR (JWT Secured Authorization Request).
         * That `require_signed_request_object` is `true` means that authorization requests which don't
         * conform to the JAR specification are rejected.
         */
        public Builder requestObjectRequired(@Nullable Boolean requestObjectRequired) {
            this.requestObjectRequired = requestObjectRequired;
            return this;
        }

        /**
         * The flag to indicate whether a request object is processed based on rules defined in
         * [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) or JAR (JWT
         * Secured Authorization Request).
         * 
         * <p>Differences between rules in OpenID Connect Core 1.0 and ones in JAR are as follows.
         *   - JAR requires that a request object be always -signed.
         *   - JAR does not allow request parameters outside a request object to be referred to.
         *   - OIDC Core 1.0 requires that response_type request parameter exist outside a request object even if the request object includes the request parameter.
         *   - OIDC Core 1.0 requires that scope request parameter exist outside a request object if the authorization request is an
         *   - OIDC request even if the request object includes the request parameter.
         * 
         * <p>If this flag is set to `false` and the value of `requestObjectRequired` is `true`, the value of
         * `require_signed_request_object` server metadata of this service
         * is reported as `true` in the discovery document. The metadata is defined in JAR (JWT Secured
         * Authorization Request). That `require_signed_request_object` is `true` means that authorization
         * requests which don't conform to the JAR specification are rejected.
         */
        public Builder traditionalRequestObjectProcessingApplied(@Nullable Boolean traditionalRequestObjectProcessingApplied) {
            this.traditionalRequestObjectProcessingApplied = traditionalRequestObjectProcessingApplied;
            return this;
        }

        /**
         * The flag to indicate whether this service validates certificate chains during PKI-based client mutual TLS authentication.
         */
        public Builder mutualTlsValidatePkiCertChain(@Nullable Boolean mutualTlsValidatePkiCertChain) {
            this.mutualTlsValidatePkiCertChain = mutualTlsValidatePkiCertChain;
            return this;
        }

        /**
         * The list of root certificates trusted by this service for PKI-based client mutual TLS authentication.
         */
        public Builder trustedRootCertificates(@Nullable List<String> trustedRootCertificates) {
            this.trustedRootCertificates = trustedRootCertificates;
            return this;
        }

        /**
         * The MTLS endpoint aliases.
         * 
         * <p>This property corresponds to the mtls_endpoint_aliases metadata defined in "5. Metadata for Mutual TLS Endpoint Aliases" of [OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens](https://datatracker.ietf.org/doc/rfc8705/).
         * 
         * <p>The aliases will be embedded in the response from the discovery endpoint like the following.
         * 
         * <p>```json
         * {
         *   ......,
         *   "mtls_endpoint_aliases": {
         *     "token_endpoint":         "https://mtls.example.com/token",
         *     "revocation_endpoint":    "https://mtls.example.com/revo",
         *     "introspection_endpoint": "https://mtls.example.com/introspect"
         *   }
         * }
         * ```
         */
        public Builder mtlsEndpointAliases(@Nullable List<ServiceUpdateApiMtlsEndpointAliasRequest> mtlsEndpointAliases) {
            this.mtlsEndpointAliases = mtlsEndpointAliases;
            return this;
        }

        /**
         * The access token type.
         * 
         * <p>This value is used as the value of `token_type` property in access token responses. If this service
         * complies with [RFC 6750](https://tools.ietf.org/html/rfc6750), the value of this property should
         * be `Bearer`.
         * 
         * <p>See [RFC 6749 (OAuth 2.0), 7.1. Access Token Types](https://tools.ietf.org/html/rfc6749#section-7.1) for details.
         */
        public Builder accessTokenType(@Nullable String accessTokenType) {
            this.accessTokenType = accessTokenType;
            return this;
        }

        /**
         * The flag to indicate whether this service supports issuing TLS client certificate bound access tokens.
         */
        public Builder tlsClientCertificateBoundAccessTokens(@Nullable Boolean tlsClientCertificateBoundAccessTokens) {
            this.tlsClientCertificateBoundAccessTokens = tlsClientCertificateBoundAccessTokens;
            return this;
        }

        /**
         * The duration of access tokens in seconds. This value is used as the value of `expires_in` property
         * in access token responses. `expires_in` is defined [RFC 6749, 5.1. Successful Response](https://tools.ietf.org/html/rfc6749#section-5.1).
         */
        public Builder accessTokenDuration(@Nullable Long accessTokenDuration) {
            this.accessTokenDuration = accessTokenDuration;
            return this;
        }

        /**
         * The flag to indicate whether the number of access tokens per subject (and per client) is at most one or can be more.
         * 
         * <p>If `true`, an attempt to issue a new access token invalidates existing access tokens that are associated with the same subject and the same client.
         * 
         * <p>Note that, however, attempts by [Client Credentials Flow](https://tools.ietf.org/html/rfc6749#section-4.4) do not invalidate existing access tokens because access tokens issued by Client Credentials Flow are not associated with any end-user's subject. Also note that an attempt by [Refresh Token Flow](https://tools.ietf.org/html/rfc6749#section-6) invalidates the coupled access token only and this invalidation is always performed regardless of whether the value of this setting item is `true` or `false`.
         */
        public Builder singleAccessTokenPerSubject(@Nullable Boolean singleAccessTokenPerSubject) {
            this.singleAccessTokenPerSubject = singleAccessTokenPerSubject;
            return this;
        }

        /**
         * The signature algorithm for JWT. This value is represented on 'alg' attribute
         * of the header of JWT.
         * 
         * <p>it's semantics depends upon where is this defined, for instance:
         *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
         *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
         *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
         */
        public Builder accessTokenSignAlg(@Nullable ServiceUpdateApiAccessTokenSignAlgRequest accessTokenSignAlg) {
            this.accessTokenSignAlg = accessTokenSignAlg;
            return this;
        }

        /**
         * The key ID to identify a JWK used for signing access tokens.
         * 
         * <p>A JWK Set can be registered as a property of a service. A JWK Set can contain 0 or more JWKs.
         * Authlete Server has to pick up one JWK for signing from the JWK Set when it generates a JWT-based
         * access token. Authlete Server searches the registered JWK Set for a JWK which satisfies conditions
         * for access token signature. If the number of JWK candidates which satisfy the conditions is 1,
         * there is no problem. On the other hand, if there exist multiple candidates, a Key ID is needed
         * to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
         */
        public Builder accessTokenSignatureKeyId(@Nullable String accessTokenSignatureKeyId) {
            this.accessTokenSignatureKeyId = accessTokenSignatureKeyId;
            return this;
        }

        /**
         * The duration of refresh tokens in seconds. The related specifications have no requirements on refresh token duration, but Authlete sets expiration for refresh tokens.
         */
        public Builder refreshTokenDuration(@Nullable Long refreshTokenDuration) {
            this.refreshTokenDuration = refreshTokenDuration;
            return this;
        }

        /**
         * The flag to indicate whether the remaining duration of the used refresh token is taken over to
         * the newly issued refresh token.
         */
        public Builder refreshTokenDurationKept(@Nullable Boolean refreshTokenDurationKept) {
            this.refreshTokenDurationKept = refreshTokenDurationKept;
            return this;
        }

        /**
         * The flag which indicates whether duration of refresh tokens are reset when they are used even
         * if the `refreshTokenKept` property of this service set to is `true` (= even if "Refresh Token
         * Continuous Use" is "Kept").
         * 
         * <p>This flag has no effect when the `refreshTokenKept` property is set to `false`. In other words,
         * if this service issues a new refresh token on every refresh token request, the refresh token
         * will have fresh duration (unless `refreshTokenDurationKept` is set to `true`) and this
         * `refreshTokenDurationReset` property is not referenced.
         */
        public Builder refreshTokenDurationReset(@Nullable Boolean refreshTokenDurationReset) {
            this.refreshTokenDurationReset = refreshTokenDurationReset;
            return this;
        }

        /**
         * The flag to indicate whether a refresh token remains unchanged or gets renewed after its use.
         * 
         * <p>If `true`, a refresh token used to get a new access token remains valid after its use. Otherwise, if `false`, a refresh token is invalidated after its use and a new refresh token is issued.
         * 
         * <p>See [RFC 6749 6. Refreshing an Access Token](https://tools.ietf.org/html/rfc6749#section-6), as to how to get a new access token using a refresh token.
         */
        public Builder refreshTokenKept(@Nullable Boolean refreshTokenKept) {
            this.refreshTokenKept = refreshTokenKept;
            return this;
        }

        /**
         * Scopes supported by the service.
         * 
         * <p>Authlete strongly recommends that the service register at least the following scopes.
         * 
         * <p>| Name | Description |
         * | --- | --- |
         * | openid | A permission to get an ID token of an end-user. The `openid` scope appears in [OpenID Connect Core 1.0, 3.1.2.1. Authentication Request, scope](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest). Without this scope, Authlete does not allow `response_type` request parameter to have values other than code and token. |
         * | profile | A permission to get information about `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale` and `updated_at` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
         * | email | A permission to get information about `email` and `email_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
         * | address | A permission to get information about address from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) and [5.1.1. Address Claim](https://openid.net/specs/openid-connect-core-1_0.html#AddressClaim) for details. |
         * | phone | A permission to get information about `phone_number` and `phone_number_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
         * | offline_access | A permission to get information from the user info endpoint even when the end-user is not present. See [OpenID Connect Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess) for details. |
         * 
         * <p>The value of this property is used as `scopes_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder supportedScopes(@Nullable List<ServiceUpdateApiSupportedScopeRequest> supportedScopes) {
            this.supportedScopes = supportedScopes;
            return this;
        }

        /**
         * The flag to indicate whether requests that request no scope are rejected or not.
         * 
         * <p>When a request has no explicit `scope` parameter and the service's pre-defined default scope set is empty,
         * the authorization server regards the request requests no scope. When this flag is set to `true`,
         * requests that request no scope are rejected.
         * 
         * <p>The requirement below excerpted from [RFC 6749 Section 3.3](https://tools.ietf.org/html/rfc6749#section-3.3)
         * does not explicitly mention the case where the default scope set is empty.
         * 
         * <p>&gt; If the client omits the scope parameter when requesting authorization, the authorization server
         * MUST either process the request using a pre-defined default value or fail the request indicating an invalid scope.
         * 
         * <p>However, if you interpret *"the default scope set exists but is empty"* as *"the default scope set does not exist"*
         * and want to strictly conform to the requirement above, this flag has to be `true`.
         */
        public Builder scopeRequired(@Nullable Boolean scopeRequired) {
            this.scopeRequired = scopeRequired;
            return this;
        }

        /**
         * 'The duration of [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)s
         * in seconds. This value is used to calculate the value of `exp` claim in an ID token.'
         */
        public Builder idTokenDuration(@Nullable Long idTokenDuration) {
            this.idTokenDuration = idTokenDuration;
            return this;
        }

        /**
         * The allowable clock skew between the server and clients in seconds.
         * 
         * <p>The clock skew is taken into consideration when time-related claims in a JWT (e.g. `exp`, `iat`, `nbf`) are verified.
         */
        public Builder allowableClockSkew(@Nullable Integer allowableClockSkew) {
            this.allowableClockSkew = allowableClockSkew;
            return this;
        }

        /**
         * Claim types supported by the service. Valid values are listed in Claim Type. Note that Authlete
         * currently doesn't provide any API to help implementations for `AGGREGATED` and `DISTRIBUTED`.
         * 
         * <p>The value of this property is used as `claim_types_supported` property in the [OpenID Provider
         * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder supportedClaimTypes(@Nullable List<ServiceUpdateApiSupportedClaimTypeRequest> supportedClaimTypes) {
            this.supportedClaimTypes = supportedClaimTypes;
            return this;
        }

        /**
         * Claim locales that the service supports. Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646).
         * For example, `en-US` and `ja-JP`. See [OpenID Connect Core 1.0, 5.2. Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
         * for details.
         * 
         * <p>The value of this property is used as `claims_locales_supported` property in the
         * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder supportedClaimLocales(@Nullable List<String> supportedClaimLocales) {
            this.supportedClaimLocales = supportedClaimLocales;
            return this;
        }

        /**
         * Claim names that the service supports. The standard claim names listed in [OpenID Connect Core 1.0,
         * 5.1. Standard Claim](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) should
         * be supported. The following is the list of standard claims.
         * 
         * <p>- `sub`
         * - `name`
         * - `given_name`
         * - `family_name`
         * - `middle_name`
         * - `nickname`
         * - `preferred_username`
         * - `profile`
         * - `picture`
         * - `website`
         * - `email`
         * - `email_verified`
         * - `gender`
         * - `birthdate`
         * - `zoneinfo`
         * - `locale`
         * - `phone_number`
         * - `phone_number_verified`
         * - `address`
         * - `updated_at`
         * 
         * <p>The value of this property is used as `claims_supported` property in the [OpenID Provider
         * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         * 
         * <p>The service may support its original claim names. See [OpenID Connect Core 1.0, 5.1.2. Additional
         * Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims).
         */
        public Builder supportedClaims(@Nullable List<String> supportedClaims) {
            this.supportedClaims = supportedClaims;
            return this;
        }

        /**
         * The flag indicating whether claims specified by shortcut scopes (e.g. `profile`) are included
         * in the issued ID token only when no access token is issued.
         * 
         * <p>To strictly conform to the description below excerpted from [OpenID Connect Core 1.0 Section
         * 5.4](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims), this flag has to be `true`.
         * 
         * <p>&gt; The Claims requested by the profile, email, address, and phone scope values are returned from
         * the UserInfo Endpoint, as described in Section 5.3.2, when a response_type value is used that
         * results in an Access Token being issued. However, when no Access Token is issued (which is the
         * case for the response_type value id_token), the resulting Claims are returned in the ID Token.
         */
        public Builder claimShortcutRestrictive(@Nullable Boolean claimShortcutRestrictive) {
            this.claimShortcutRestrictive = claimShortcutRestrictive;
            return this;
        }

        /**
         * The URL of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document. For
         * example, `http://example.com/auth/jwks`.
         * 
         * <p>Client applications accesses this URL (1) to get the public key of the service to validate the
         * signature of an ID token issued by the service and (2) to get the public key of the service to
         * encrypt an request object of the client application. See [OpenID Connect Core 1.0, 10. Signatures
         * and Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
         * 
         * <p>The value of this property is used as `jwks_uri` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder jwksUri(@Nullable String jwksUri) {
            this.jwksUri = jwksUri;
            return this;
        }

        /**
         * 'The flag to indicate whether the direct jwks endpoint is enabled or not. The path of the endpoint
         * is `/api/service/jwks/get/direct/service-api-key`. '
         */
        public Builder directJwksEndpointEnabled(@Nullable Boolean directJwksEndpointEnabled) {
            this.directJwksEndpointEnabled = directJwksEndpointEnabled;
            return this;
        }

        /**
         * The content of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document.
         * 
         * <p>If this property is not `null` in a `/service/create` request or a `/service/update` request,
         * Authlete hosts the content in the database. This property must not be `null` and must contain
         * pairs of public/private keys if the service wants to support asymmetric signatures for ID tokens
         * and asymmetric encryption for request objects. See [OpenID Connect Core 1.0, 10. Signatures and
         * Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
         */
        public Builder jwks(@Nullable String jwks) {
            this.jwks = jwks;
            return this;
        }

        /**
         * The key ID to identify a JWK used for ID token signature using an asymmetric key.
         * 
         * <p>A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
         * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
         * to pick up one JWK for signature from the JWK Set when it generates an ID token and signature
         * using an asymmetric key is required. Authlete Server searches the registered JWK Set for a JWK
         * which satisfies conditions for ID token signature. If the number of JWK candidates which satisfy
         * the conditions is 1, there is no problem. On the other hand, if there exist multiple candidates,
         * a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5) is needed to be specified so that
         * Authlete Server can pick up one JWK from among the JWK candidates.
         * 
         * <p>This `idTokenSignatureKeyId` property exists for the purpose described above. For key rotation
         * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
         * this mechanism is needed.
         */
        public Builder idTokenSignatureKeyId(@Nullable String idTokenSignatureKeyId) {
            this.idTokenSignatureKeyId = idTokenSignatureKeyId;
            return this;
        }

        /**
         * The key ID to identify a JWK used for user info signature using an asymmetric key.
         * 
         * <p>A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
         * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
         * to pick up one JWK for signature from the JWK Set when it is required to sign user info (which
         * is returned from [userinfo endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo))
         * using an asymmetric key. Authlete Server searches the registered JWK Set for a JWK which satisfies
         * conditions for user info signature. If the number of JWK candidates which satisfy the conditions
         * is 1, there is no problem. On the other hand, if there exist multiple candidates, a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5)
         * is needed to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
         * 
         * <p>This `userInfoSignatureKeyId` property exists for the purpose described above. For key rotation
         * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
         * this mechanism is needed.
         */
        public Builder userInfoSignatureKeyId(@Nullable String userInfoSignatureKeyId) {
            this.userInfoSignatureKeyId = userInfoSignatureKeyId;
            return this;
        }

        /**
         * The key ID to identify a JWK used for signing authorization responses using an asymmetric key.
         * 
         * <p>[Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
         * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
         * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
         * from the authorization endpoint will be packed into a JWT. This property is used to compute the
         * value of the `exp` claim of the JWT.
         * 
         * <p>Authlete Server searches the JWK Set for a JWK which satisfies conditions for authorization response
         * signature. If the number of JWK candidates which satisfy the conditions is 1, there is no problem.
         * On the other hand, if there exist multiple candidates, a Key ID is needed to be specified so that
         * Authlete Server can pick up one JWK from among the JWK candidates. This property exists to specify
         * the key ID.
         */
        public Builder authorizationSignatureKeyId(@Nullable String authorizationSignatureKeyId) {
            this.authorizationSignatureKeyId = authorizationSignatureKeyId;
            return this;
        }

        /**
         * The [user info endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo) of the
         * service. A URL that starts with `https://`. For example, `https://example.com/auth/userinfo`.
         * 
         * <p>The value of this property is used as `userinfo_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder userInfoEndpoint(@Nullable String userInfoEndpoint) {
            this.userInfoEndpoint = userInfoEndpoint;
            return this;
        }

        /**
         * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path
         * of the endpoint is `/api/auth/userinfo/direct/service-api-key`.
         */
        public Builder directUserInfoEndpointEnabled(@Nullable Boolean directUserInfoEndpointEnabled) {
            this.directUserInfoEndpointEnabled = directUserInfoEndpointEnabled;
            return this;
        }

        /**
         * The boolean flag which indicates whether the [OAuth 2.0 Dynamic Client Registration Protocol](https://tools.ietf.org/html/rfc7591)
         * is supported.
         */
        public Builder dynamicRegistrationSupported(@Nullable Boolean dynamicRegistrationSupported) {
            this.dynamicRegistrationSupported = dynamicRegistrationSupported;
            return this;
        }

        /**
         * The [registration endpoint](http://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration)
         * of the service. A URL that starts with `https://`. For example, `https://example.com/auth/registration`.
         * 
         * <p>The value of this property is used as `registration_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder registrationEndpoint(@Nullable String registrationEndpoint) {
            this.registrationEndpoint = registrationEndpoint;
            return this;
        }

        /**
         * The URI of the registration management endpoint. If dynamic client registration is supported,
         * and this is set, this URI will be used as the basis of the client's management endpoint by appending
         * `/clientid}/` to it as a path element. If this is unset, the value of `registrationEndpoint` will
         * be used as the URI base instead.
         */
        public Builder registrationManagementEndpoint(@Nullable String registrationManagementEndpoint) {
            this.registrationManagementEndpoint = registrationManagementEndpoint;
            return this;
        }

        /**
         * The URL of the "Policy" of the service.
         * 
         * <p>The value of this property is used as `op_policy_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder policyUri(@Nullable String policyUri) {
            this.policyUri = policyUri;
            return this;
        }

        /**
         * The URL of the "Terms Of Service" of the service.
         * 
         * <p>The value of this property is used as `op_tos_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder tosUri(@Nullable String tosUri) {
            this.tosUri = tosUri;
            return this;
        }

        /**
         * The URL of a page where documents for developers can be found.
         * 
         * <p>The value of this property is used as `service_documentation` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder serviceDocumentation(@Nullable String serviceDocumentation) {
            this.serviceDocumentation = serviceDocumentation;
            return this;
        }

        /**
         * The URI of backchannel authentication endpoint, which is defined in the specification of [CIBA
         * (Client Initiated Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
         */
        public Builder backchannelAuthenticationEndpoint(@Nullable String backchannelAuthenticationEndpoint) {
            this.backchannelAuthenticationEndpoint = backchannelAuthenticationEndpoint;
            return this;
        }

        /**
         * The supported backchannel token delivery modes. This property corresponds to the `backchannel_token_delivery_modes_supported`
         * metadata.
         * 
         * <p>Backchannel token delivery modes are defined in the specification of [CIBA (Client Initiated
         * Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
         */
        public Builder supportedBackchannelTokenDeliveryModes(@Nullable List<ServiceUpdateApiSupportedBackchannelTokenDeliveryModeRequest> supportedBackchannelTokenDeliveryModes) {
            this.supportedBackchannelTokenDeliveryModes = supportedBackchannelTokenDeliveryModes;
            return this;
        }

        /**
         * The duration of backchannel authentication request IDs issued from the backchannel authentication
         * endpoint in seconds. This is used as the value of the `expires_in` property in responses from
         * the backchannel authentication endpoint.
         */
        public Builder backchannelAuthReqIdDuration(@Nullable Integer backchannelAuthReqIdDuration) {
            this.backchannelAuthReqIdDuration = backchannelAuthReqIdDuration;
            return this;
        }

        /**
         * The minimum interval between polling requests to the token endpoint from client applications in
         * seconds. This is used as the value of the `interval` property in responses from the backchannel
         * authentication endpoint.
         */
        public Builder backchannelPollingInterval(@Nullable Integer backchannelPollingInterval) {
            this.backchannelPollingInterval = backchannelPollingInterval;
            return this;
        }

        /**
         * The boolean flag which indicates whether the `user_code` request parameter is supported at the
         * backchannel authentication endpoint. This property corresponds to the `backchannel_user_code_parameter_supported`
         * metadata.
         */
        public Builder backchannelUserCodeParameterSupported(@Nullable Boolean backchannelUserCodeParameterSupported) {
            this.backchannelUserCodeParameterSupported = backchannelUserCodeParameterSupported;
            return this;
        }

        /**
         * The flag to indicate whether the `binding_message` request parameter is always required whenever
         * a backchannel authentication request is judged as a request for Financial-grade API.
         * 
         * <p>The FAPI-CIBA profile requires that the authorization server _"shall ensure unique authorization
         * context exists in the authorization request or require a `binding_message` in the authorization
         * request"_ (FAPI-CIBA, 5.2.2, 2). The simplest way to fulfill this requirement is to set this property
         * to `true`.
         * 
         * <p>If this property is set to `false`, the `binding_message` request parameter remains optional
         * even in FAPI context, but in exchange, your authorization server must implement a custom mechanism
         * that ensures each backchannel authentication request has unique context.
         */
        public Builder backchannelBindingMessageRequiredInFapi(@Nullable Boolean backchannelBindingMessageRequiredInFapi) {
            this.backchannelBindingMessageRequiredInFapi = backchannelBindingMessageRequiredInFapi;
            return this;
        }

        /**
         * The URI of the device authorization endpoint.
         * 
         * <p>Device authorization endpoint is defined in the specification of OAuth 2.0 Device Authorization Grant.
         */
        public Builder deviceAuthorizationEndpoint(@Nullable String deviceAuthorizationEndpoint) {
            this.deviceAuthorizationEndpoint = deviceAuthorizationEndpoint;
            return this;
        }

        /**
         * The verification URI for the device flow. This URI is used as the value of the `verification_uri`
         * parameter in responses from the device authorization endpoint.
         */
        public Builder deviceVerificationUri(@Nullable String deviceVerificationUri) {
            this.deviceVerificationUri = deviceVerificationUri;
            return this;
        }

        /**
         * The verification URI for the device flow with a placeholder for a user code. This URI is used
         * to build the value of the `verification_uri_complete` parameter in responses from the device
         * authorization endpoint.
         * 
         * <p>It is expected that the URI contains a fixed string `USER_CODE` somewhere as a placeholder for
         * a user code. For example, like the following.
         * 
         * <p>`https://example.com/device?user\_code=USER\_CODE`
         * 
         * <p>The fixed string is replaced with an actual user code when Authlete builds a verification URI
         * with a user code for the `verification_uri_complete` parameter.
         * 
         * <p>If this URI is not set, the `verification_uri_complete` parameter won't appear in device authorization
         * responses.
         */
        public Builder deviceVerificationUriComplete(@Nullable String deviceVerificationUriComplete) {
            this.deviceVerificationUriComplete = deviceVerificationUriComplete;
            return this;
        }

        /**
         * The duration of device verification codes and end-user verification codes issued from the device
         * authorization endpoint in seconds. This is used as the value of the `expires_in` property in responses
         * from the device authorization endpoint.
         */
        public Builder deviceFlowCodeDuration(@Nullable Integer deviceFlowCodeDuration) {
            this.deviceFlowCodeDuration = deviceFlowCodeDuration;
            return this;
        }

        /**
         * The minimum interval between polling requests to the token endpoint from client applications in
         * seconds in device flow. This is used as the value of the `interval` property in responses from
         * the device authorization endpoint.
         */
        public Builder deviceFlowPollingInterval(@Nullable Integer deviceFlowPollingInterval) {
            this.deviceFlowPollingInterval = deviceFlowPollingInterval;
            return this;
        }

        /**
         * The character set for end-user verification codes (`user_code`) for Device Flow.
         */
        public Builder userCodeCharset(@Nullable ServiceUpdateApiUserCodeCharsetRequest userCodeCharset) {
            this.userCodeCharset = userCodeCharset;
            return this;
        }

        /**
         * The length of end-user verification codes (`user_code`) for Device Flow.
         */
        public Builder userCodeLength(@Nullable Integer userCodeLength) {
            this.userCodeLength = userCodeLength;
            return this;
        }

        /**
         * Trust frameworks supported by this service. This corresponds to the `trust_frameworks_supported`
         * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
         */
        public Builder supportedTrustFrameworks(@Nullable List<String> supportedTrustFrameworks) {
            this.supportedTrustFrameworks = supportedTrustFrameworks;
            return this;
        }

        /**
         * Evidence supported by this service. This corresponds to the `evidence_supported` [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
         */
        public Builder supportedEvidence(@Nullable List<String> supportedEvidence) {
            this.supportedEvidence = supportedEvidence;
            return this;
        }

        /**
         * Identity documents supported by this service. This corresponds to the `id_documents_supported`
         * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
         */
        public Builder supportedIdentityDocuments(@Nullable List<String> supportedIdentityDocuments) {
            this.supportedIdentityDocuments = supportedIdentityDocuments;
            return this;
        }

        /**
         * Verification methods supported by this service. This corresponds to the `id_documents_verification_methods_supported`
         * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
         */
        public Builder supportedVerificationMethods(@Nullable List<String> supportedVerificationMethods) {
            this.supportedVerificationMethods = supportedVerificationMethods;
            return this;
        }

        /**
         * Verified claims supported by this service. This corresponds to the `claims_in_verified_claims_supported`
         * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
         */
        public Builder supportedVerifiedClaims(@Nullable List<String> supportedVerifiedClaims) {
            this.supportedVerifiedClaims = supportedVerifiedClaims;
            return this;
        }

        /**
         * OIDC4IDA / verifiedClaimsValidationSchemaSet
         */
        public Builder verifiedClaimsValidationSchemaSet(@Nullable ServiceUpdateApiVerifiedClaimsValidationSchemaSetRequest verifiedClaimsValidationSchemaSet) {
            this.verifiedClaimsValidationSchemaSet = verifiedClaimsValidationSchemaSet;
            return this;
        }

        /**
         * The attributes of this service.
         */
        public Builder attributes(@Nullable List<ServiceUpdateApiAttributeRequest> attributes) {
            this.attributes = attributes;
            return this;
        }

        /**
         * The flag indicating whether the nbf claim in the request object is optional even when the authorization
         * request is regarded as a FAPI-Part2 request.
         * 
         * <p>The final version of Financial-grade API was approved in January, 2021. The Part 2 of the final
         * version has new requirements on lifetime of request objects. They require that request objects
         * contain an `nbf` claim and the lifetime computed by `exp` - `nbf` be no longer than 60 minutes.
         * 
         * <p>Therefore, when an authorization request is regarded as a FAPI-Part2 request, the request object
         * used in the authorization request must contain an nbf claim. Otherwise, the authorization server
         * rejects the authorization request.
         * 
         * <p>When this flag is `true`, the `nbf` claim is treated as an optional claim even when the authorization
         * request is regarded as a FAPI-Part2 request. That is, the authorization server does not perform
         * the validation on lifetime of the request object.
         * 
         * <p>Skipping the validation is a violation of the FAPI specification. The reason why this flag has
         * been prepared nevertheless is that the new requirements (which do not exist in the Implementer's
         * Draft 2 released in October, 2018) have big impacts on deployed implementations of client
         * applications and Authlete thinks there should be a mechanism whereby to make the migration
         * from ID2 to Final smooth without breaking live systems.
         */
        public Builder nbfOptional(@Nullable Boolean nbfOptional) {
            this.nbfOptional = nbfOptional;
            return this;
        }

        /**
         * The flag indicating whether generation of the iss response parameter is suppressed.
         * 
         * <p>"OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response" has defined a new
         * authorization response parameter, `iss`, as a countermeasure for a certain type of mix-up attacks.
         * 
         * <p>The specification requires that the `iss` response parameter always be included in authorization
         * responses unless JARM (JWT Secured Authorization Response Mode) is used.
         * 
         * <p>When this flag is `true`, the authorization server does not include the `iss` response parameter
         * in authorization responses. By turning this flag on and off, developers of client applications
         * can experiment the mix-up attack and the effect of the `iss` response parameter.
         * 
         * <p>Note that this flag should not be `true` in production environment unless there are special
         * reasons for it.
         */
        public Builder issSuppressed(@Nullable Boolean issSuppressed) {
            this.issSuppressed = issSuppressed;
            return this;
        }

        /**
         * custom client metadata supported by this service.
         * 
         * <p>Standard specifications define client metadata as necessary. The following are such examples.
         * 
         * <p>* [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
         * * [RFC 7591 OAuth 2.0 Dynamic Client Registration Protocol](https://www.rfc-editor.org/rfc/rfc7591.html)
         * * [RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens](https://www.rfc-editor.org/rfc/rfc8705.html)
         * * [OpenID Connect Client-Initiated Backchannel Authentication Flow - Core 1.0](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html)
         * * [The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-jwsreq/)
         * * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
         * * [OAuth 2.0 Pushed Authorization Requests (PAR)](https://datatracker.ietf.org/doc/rfc9126/)
         * * [OAuth 2.0 Rich Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/)
         * 
         * <p>Standard client metadata included in Client Registration Request and Client Update Request (cf.
         * [OIDC DynReg](https://openid.net/specs/openid-connect-registration-1_0.html), [RFC 7591](https://www.rfc-editor.org/rfc/rfc7591.html)
         * and [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)) are, if supported by Authlete, stored
         * into Authlete database. On the other hand, unrecognized client metadata are discarded.
         * 
         * <p>By listing up custom client metadata in advance by using this property (`supportedCustomClientMetadata`),
         * Authlete can recognize them and stores their values into the database. The stored custom client
         * metadata values can be referenced by `customMetadata`.
         */
        public Builder supportedCustomClientMetadata(@Nullable List<String> supportedCustomClientMetadata) {
            this.supportedCustomClientMetadata = supportedCustomClientMetadata;
            return this;
        }

        /**
         * The flag indicating whether the expiration date of an access token never exceeds that of the
         * corresponding refresh token.
         * 
         * <p>When a new access token is issued by a refresh token request (= a token request with `grant_type=refresh_token`),
         * the expiration date of the access token may exceed the expiration date of the corresponding
         * refresh token. This behavior itself is not wrong and may happen when `refreshTokenKept` is
         * `true` and/or when `refreshTokenDurationKept` is `true`.
         * 
         * <p>When this flag is `true`, the expiration date of an access token never exceeds that of the corresponding
         * refresh token regardless of the calculated duration based on other settings such as `accessTokenDuration`,
         * `accessTokenDuration` in `extension` and `access_token.duration` scope attribute.
         * 
         * <p>It is technically possible to set a value which is bigger than the duration of refresh tokens
         * as the duration of access tokens although it is strange. In the case, the duration of an access
         * token becomes longer than the duration of the refresh token which is issued together with the
         * access token. Even if the duration values are configured so, if this flag is `true`, the expiration
         * date of the access token does not exceed that of the refresh token. That is, the duration of
         * the access token will be shortened, and as a result, the access token and the refresh token
         * will have the same expiration date.
         */
        public Builder tokenExpirationLinked(@Nullable Boolean tokenExpirationLinked) {
            this.tokenExpirationLinked = tokenExpirationLinked;
            return this;
        }

        /**
         * The flag indicating whether encryption of request object is required when the request object
         * is passed through the front channel.
         * 
         * <p>This flag does not affect the processing of request objects at the Pushed Authorization Request
         * Endpoint, which is defined in [OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/).
         * Unecrypted request objects are accepted at the endpoint even if this flag is `true`.
         * 
         * <p>This flag does not indicate whether a request object is always required. There is a different
         * flag, `requestObjectRequired`, for the purpose. See the description of `requestObjectRequired`
         * for details.
         * 
         * <p>Even if this flag is `false`, encryption of request object is required if the `frontChannelRequestObjectEncryptionRequired`
         * flag of the client is `true`.
         */
        public Builder frontChannelRequestObjectEncryptionRequired(@Nullable Boolean frontChannelRequestObjectEncryptionRequired) {
            this.frontChannelRequestObjectEncryptionRequired = frontChannelRequestObjectEncryptionRequired;
            return this;
        }

        /**
         * The flag indicating whether the JWE alg of encrypted request object must match the `request_object_encryption_alg`
         * client metadata of the client that has sent the request object.
         * 
         * <p>The request_object_encryption_alg client metadata itself is defined in [OpenID Connect Dynamic
         * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
         * 
         * <p>&gt; request_object_encryption_alg
         * &gt;
         * &gt; OPTIONAL. JWE [JWE] alg algorithm [JWA] the RP is declaring that it may use for encrypting
         * Request Objects sent to the OP. This parameter SHOULD be included when symmetric encryption
         * will be used, since this signals to the OP that a client_secret value needs to be returned
         * from which the symmetric key will be derived, that might not otherwise be returned. The RP
         * MAY still use other supported encryption algorithms or send unencrypted Request Objects, even
         * when this parameter is present. If both signing and encryption are requested, the Request Object
         * will be signed then encrypted, with the result being a Nested JWT, as defined in [JWT]. The
         * default, if omitted, is that the RP is not declaring whether it might encrypt any Request Objects.
         * 
         * <p>The point here is "The RP MAY still use other supported encryption algorithms or send unencrypted
         * Request Objects, even when this parameter is present."
         * 
         * <p>The Client's property that represents the client metadata is `requestEncryptionAlg`. See the
         * description of `requestEncryptionAlg` for details.
         * 
         * <p>Even if this flag is `false`, the match is required if the `requestObjectEncryptionAlgMatchRequired`
         * flag of the client is `true`.
         */
        public Builder requestObjectEncryptionAlgMatchRequired(@Nullable Boolean requestObjectEncryptionAlgMatchRequired) {
            this.requestObjectEncryptionAlgMatchRequired = requestObjectEncryptionAlgMatchRequired;
            return this;
        }

        /**
         * The flag indicating whether the JWE `enc` of encrypted request object must match the `request_object_encryption_enc`
         * client metadata of the client that has sent the request object.
         * 
         * <p>The `request_object_encryption_enc` client metadata itself is defined in [OpenID Connect Dynamic
         * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
         * 
         * <p>&gt; request_object_encryption_enc
         * &gt;
         * &gt; OPTIONAL. JWE enc algorithm [JWA] the RP is declaring that it may use for encrypting Request
         * Objects sent to the OP. If request_object_encryption_alg is specified, the default for this
         * value is A128CBC-HS256. When request_object_encryption_enc is included, request_object_encryption_alg
         * MUST also be provided.
         * 
         * <p>The Client's property that represents the client metadata is `requestEncryptionEnc`. See the
         * description of `requestEncryptionEnc` for details.
         * 
         * <p>Even if this flag is false, the match is required if the `requestObjectEncryptionEncMatchRequired`
         * flag is `true`.
         */
        public Builder requestObjectEncryptionEncMatchRequired(@Nullable Boolean requestObjectEncryptionEncMatchRequired) {
            this.requestObjectEncryptionEncMatchRequired = requestObjectEncryptionEncMatchRequired;
            return this;
        }

        /**
         * The flag indicating whether HSM (Hardware Security Module) support is enabled for this service.
         * 
         * <p>When this flag is `false`, keys managed in HSMs are not used even if they exist. In addition,
         * `/api/hsk/*` APIs reject all requests.
         * 
         * <p>Even if this flag is `true`, HSM-related features do not work if the configuration of the Authlete
         * server you are using does not support HSM.
         */
        public Builder hsmEnabled(@Nullable Boolean hsmEnabled) {
            this.hsmEnabled = hsmEnabled;
            return this;
        }

        /**
         * The information about keys managed on HSMs (Hardware Security Modules).
         * 
         * <p>This `hsks` property is output only, meaning that `hsks` in requests to `/api/service/create`
         * API and `/api/service/update` API do not have any effect. The contents of this property is controlled
         * only by `/api/hsk/*` APIs.
         */
        public Builder hsks(@Nullable List<ServiceUpdateApiHskRequest> hsks) {
            this.hsks = hsks;
            return this;
        }

        /**
         * The URL of the grant management endpoint.
         */
        public Builder grantManagementEndpoint(@Nullable String grantManagementEndpoint) {
            this.grantManagementEndpoint = grantManagementEndpoint;
            return this;
        }

        /**
         * The flag indicating whether every authorization request (and any request serving as an authorization
         * request such as CIBA backchannel authentication request and device authorization request) must
         * include the `grant_management_action` request parameter.
         * 
         * <p>This property corresponds to the `grant_management_action_required` server metadata defined
         * in [Grant Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html).
         * 
         * <p>Note that setting true to this property will result in blocking all public clients because
         * the specification requires that grant management be usable only by confidential clients for
         * security reasons.
         */
        public Builder grantManagementActionRequired(@Nullable Boolean grantManagementActionRequired) {
            this.grantManagementActionRequired = grantManagementActionRequired;
            return this;
        }

        /**
         * The flag indicating whether Authlete's `/api/client/registration` API uses `UNAUTHORIZED` as
         * a value of the `action` response parameter when appropriate.
         * 
         * <p>The `UNAUTHORIZED` enum value was initially not defined as a possible value of the `action`
         * parameter in an `/api/client/registration` API response. This means that implementations of
         * client `configuration` endpoint were not able to conform to [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)
         * strictly.
         * 
         * <p>For backward compatibility (to avoid breaking running systems), Authlete's `/api/client/registration`
         * API does not return the `UNAUTHORIZED` enum value if this flag is not turned on.
         * 
         * <p>The steps an existing implementation of client configuration endpoint has to do in order to
         * conform to the requirement related to "401 Unauthorized" are as follows.
         * 
         * <p>1. Update the Authlete library (e.g. authlete-java-common) your system is using.
         * 2. Update your implementation of client configuration endpoint so that it can handle the
         * `UNAUTHORIZED` action.
         * 3. Turn on this `unauthorizedOnClientConfigSupported` flag.
         */
        public Builder unauthorizedOnClientConfigSupported(@Nullable Boolean unauthorizedOnClientConfigSupported) {
            this.unauthorizedOnClientConfigSupported = unauthorizedOnClientConfigSupported;
            return this;
        }

        /**
         * The flag indicating whether the `scope` request parameter in dynamic client registration and
         * update requests (RFC 7591 and RFC 7592) is used as scopes that the client can request.
         * 
         * <p>Limiting the range of scopes that a client can request is achieved by listing scopes in the
         * `client.extension.requestableScopes` property and setting the `client.extension.requestableScopesEnabled`
         * property to `true`. This feature is called "requestable scopes".
         * 
         * <p>This property affects behaviors of `/api/client/registration` and other family APIs.
         */
        public Builder dcrScopeUsedAsRequestable(@Nullable Boolean dcrScopeUsedAsRequestable) {
            this.dcrScopeUsedAsRequestable = dcrScopeUsedAsRequestable;
            return this;
        }

        /**
         * The endpoint for clients ending the sessions.
         * 
         * <p>A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/endSession`.
         * 
         * <p>The value of this property is used as `end_session_endpoint` property in the [OpenID Provider
         * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
         */
        public Builder endSessionEndpoint(@Nullable String endSessionEndpoint) {
            this.endSessionEndpoint = endSessionEndpoint;
            return this;
        }

        /**
         * The flag indicating whether the port number component of redirection URIs can be variable when
         * the host component indicates loopback.
         * 
         * <p>When this flag is `true`, if the host component of a redirection URI specified in an authorization
         * request indicates loopback (to be precise, when the host component is localhost, `127.0.0.1`
         * or `::1`), the port number component is ignored when the specified redirection URI is compared
         * to pre-registered ones. This behavior is described in [7.3. Loopback Interface Redirection](
         * https://www.rfc-editor.org/rfc/rfc8252.html#section-7.3) of [RFC 8252 OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8252.html)
         * for Native Apps.
         * 
         * <p>[3.1.2.3. Dynamic Configuration](https://www.rfc-editor.org/rfc/rfc6749.html#section-3.1.2.3)
         * of [RFC 6749](https://www.rfc-editor.org/rfc/rfc6749.html) states _"If the client registration
         * included the full redirection URI, the authorization server MUST compare the two URIs using
         * simple string comparison as defined in [RFC3986] Section 6.2.1."_ Also, the description of
         * `redirect_uri` in [3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest)
         * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) states
         * _"This URI MUST exactly match one of the Redirection URI values for the Client pre-registered
         * at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [RFC3986]
         * (**Simple String Comparison**)."_ These "Simple String Comparison" requirements are preceded
         * by this flag. That is, even when the conditions described in RFC 6749 and OpenID Connect Core 1.0
         * are satisfied, the port number component of loopback redirection URIs can be variable when this
         * flag is `true`.
         * 
         * <p>[8.3. Loopback Redirect Considerations](https://www.rfc-editor.org/rfc/rfc8252.html#section-8.3)
         * of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) states as follows.
         * 
         * <p>&gt; While redirect URIs using localhost (i.e., `"http://localhost:{port}/{path}"`) function
         * similarly to loopback IP redirects described in Section 7.3, the use of localhost is NOT RECOMMENDED.
         * Specifying a redirect URI with the loopback IP literal rather than localhost avoids inadvertently
         * listening on network interfaces other than the loopback interface. It is also less susceptible
         * to client-side firewalls and misconfigured host name resolution on the user's device.
         * 
         * <p>However, Authlete allows the port number component to be variable in the case of `localhost`,
         * too. It is left to client applications whether they use `localhost` or a literal loopback IP
         * address (`127.0.0.1` for IPv4 or `::1` for IPv6).
         * 
         * <p>Section 7.3 and Section 8.3 of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) state
         * that loopback redirection URIs use the `"http"` scheme, but Authlete allows the port number
         * component to be variable in other cases (e.g. in the case of the `"https"` scheme), too.
         */
        public Builder loopbackRedirectionUriVariable(@Nullable Boolean loopbackRedirectionUriVariable) {
            this.loopbackRedirectionUriVariable = loopbackRedirectionUriVariable;
            return this;
        }

        /**
         * The flag indicating whether Authlete checks whether the `aud` claim of request objects matches
         * the issuer identifier of this service.
         * 
         * <p>[Section 6.1. Passing a Request Object by Value](https://openid.net/specs/openid-connect-core-1_0.html#JWTRequests)
         * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) has the following
         * statement.
         * 
         * <p>&gt; The `aud` value SHOULD be or include the OP's Issuer Identifier URL.
         * 
         * <p>Likewise, [Section 4. Request Object](https://www.rfc-editor.org/rfc/rfc9101.html#section-4) of
         * [RFC 9101](https://www.rfc-editor.org/rfc/rfc9101.html) (The OAuth 2.0 Authorization Framework:
         * JWT-Secured Authorization Request (JAR)) has the following statement.
         * 
         * <p>&gt; The value of aud should be the value of the authorization server (AS) issuer, as defined in
         * [RFC 8414](https://www.rfc-editor.org/rfc/rfc8414.html).
         * 
         * <p>As excerpted above, validation on the `aud` claim of request objects is optional. However, if
         * this flag is turned on, Authlete checks whether the `aud` claim of request objects matches the issuer
         * identifier of this service and raises an error if they are different.
         */
        public Builder requestObjectAudienceChecked(@Nullable Boolean requestObjectAudienceChecked) {
            this.requestObjectAudienceChecked = requestObjectAudienceChecked;
            return this;
        }

        /**
         * The flag indicating whether Authlete generates access tokens for
         * external attachments and embeds them in ID tokens and userinfo
         * responses.
         */
        public Builder accessTokenForExternalAttachmentEmbedded(@Nullable Boolean accessTokenForExternalAttachmentEmbedded) {
            this.accessTokenForExternalAttachmentEmbedded = accessTokenForExternalAttachmentEmbedded;
            return this;
        }

        /**
         * Identifiers of entities that can issue entity statements for this
         * service. This property corresponds to the `authority_hints`
         * property that appears in a self-signed entity statement that is
         * defined in OpenID Connect Federation 1.0.
         */
        public Builder authorityHints(@Nullable List<String> authorityHints) {
            this.authorityHints = authorityHints;
            return this;
        }

        /**
         * flag indicating whether this service supports OpenID Connect Federation 1
         */
        public Builder federationEnabled(@Nullable Boolean federationEnabled) {
            this.federationEnabled = federationEnabled;
            return this;
        }

        /**
         * JWK Set document containing keys that are used to sign (1) self-signed
         * entity statement of this service and (2) the response from
         * `signed_jwks_uri`.
         */
        public Builder federationJwks(@Nullable String federationJwks) {
            this.federationJwks = federationJwks;
            return this;
        }

        /**
         * A key ID to identify a JWK used to sign the entity configuration and
         * the signed JWK Set.
         */
        public Builder federationSignatureKeyId(@Nullable String federationSignatureKeyId) {
            this.federationSignatureKeyId = federationSignatureKeyId;
            return this;
        }

        /**
         * The duration of the entity configuration in seconds.
         */
        public Builder federationConfigurationDuration(@Nullable Long federationConfigurationDuration) {
            this.federationConfigurationDuration = federationConfigurationDuration;
            return this;
        }

        /**
         * The URI of the federation registration endpoint. This property corresponds
         * to the `federation_registration_endpoint` server metadata that is
         * defined in OpenID Connect Federation 1.0.
         */
        public Builder federationRegistrationEndpoint(@Nullable String federationRegistrationEndpoint) {
            this.federationRegistrationEndpoint = federationRegistrationEndpoint;
            return this;
        }

        /**
         * The human-readable name representing the organization that operates
         * this service. This property corresponds to the `organization_name`
         * server metadata that is defined in OpenID Connect Federation 1.0.
         */
        public Builder organizationName(@Nullable String organizationName) {
            this.organizationName = organizationName;
            return this;
        }

        /**
         * The transformed claims predefined by this service in JSON format.
         * This property corresponds to the `transformed_claims_predefined`
         * server metadata.
         */
        public Builder predefinedTransformedClaims(@Nullable String predefinedTransformedClaims) {
            this.predefinedTransformedClaims = predefinedTransformedClaims;
            return this;
        }

        /**
         * flag indicating whether refresh token requests with the same
         * refresh token can be made multiple times in quick succession and
         * they can obtain the same renewed refresh token within the short
         * period.
         */
        public Builder refreshTokenIdempotent(@Nullable Boolean refreshTokenIdempotent) {
            this.refreshTokenIdempotent = refreshTokenIdempotent;
            return this;
        }

        /**
         * The URI of the endpoint that returns this service's JWK Set document in
         * the JWT format. This property corresponds to the `signed_jwks_uri`
         * server metadata defined in OpenID Connect Federation 1.0.
         */
        public Builder signedJwksUri(@Nullable String signedJwksUri) {
            this.signedJwksUri = signedJwksUri;
            return this;
        }

        /**
         * Supported attachment types. This property corresponds to the {@code
         * attachments_supported} server metadata which was added by the third
         * implementer's draft of OpenID Connect for Identity Assurance 1.0.
         */
        public Builder supportedAttachments(@Nullable List<ServiceUpdateApiSupportedAttachmentRequest> supportedAttachments) {
            this.supportedAttachments = supportedAttachments;
            return this;
        }

        /**
         * Supported algorithms used to compute digest values of external
         * attachments. This property corresponds to the
         * `digest_algorithms_supported` server metadata which was added
         * by the third implementer's draft of OpenID Connect for Identity
         * Assurance 1.0.
         */
        public Builder supportedDigestAlgorithms(@Nullable List<String> supportedDigestAlgorithms) {
            this.supportedDigestAlgorithms = supportedDigestAlgorithms;
            return this;
        }

        /**
         * Document types supported by this service. This property corresponds
         * to the `documents_supported` server metadata.
         */
        public Builder supportedDocuments(@Nullable List<String> supportedDocuments) {
            this.supportedDocuments = supportedDocuments;
            return this;
        }

        /**
         * validation and verification processes supported by this service.
         * This property corresponds to the `documents_methods_supported`
         * server metadata.
         * 
         * <p>The third implementer's draft of [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
         * renamed the
         * `id_documents_verification_methods_supported` server metadata to
         * `documents_methods_supported`.
         */
        public Builder supportedDocumentsMethods(@Nullable List<String> supportedDocumentsMethods) {
            this.supportedDocumentsMethods = supportedDocumentsMethods;
            return this;
        }

        /**
         * Document validation methods supported by this service. This property
         * corresponds to the `documents_validation_methods_supported` server
         * metadata which was added by the third implementer's draft of &lt;a href=
         * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
         */
        public Builder supportedDocumentsValidationMethods(@Nullable List<String> supportedDocumentsValidationMethods) {
            this.supportedDocumentsValidationMethods = supportedDocumentsValidationMethods;
            return this;
        }

        /**
         * Document verification methods supported by this service. This property
         * corresponds to the `documents_verification_methods_supported` server
         * metadata which was added by the third implementer's draft of
         * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
         */
        public Builder supportedDocumentsVerificationMethods(@Nullable List<String> supportedDocumentsVerificationMethods) {
            this.supportedDocumentsVerificationMethods = supportedDocumentsVerificationMethods;
            return this;
        }

        /**
         * Electronic record types supported by this service. This property
         * corresponds to the `electronic_records_supported` server metadata
         * which was added by the third implementer's draft of
         * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
         */
        public Builder supportedElectronicRecords(@Nullable List<String> supportedElectronicRecords) {
            this.supportedElectronicRecords = supportedElectronicRecords;
            return this;
        }

        public Builder supportedClientRegistrationTypes(@Nullable List<ServiceUpdateApiSupportedClientRegistrationTypeRequest> supportedClientRegistrationTypes) {
            this.supportedClientRegistrationTypes = supportedClientRegistrationTypes;
            return this;
        }

        /**
         * The flag indicating whether to prohibit unidentifiable clients from
         * making token exchange requests.
         */
        public Builder tokenExchangeByIdentifiableClientsOnly(@Nullable Boolean tokenExchangeByIdentifiableClientsOnly) {
            this.tokenExchangeByIdentifiableClientsOnly = tokenExchangeByIdentifiableClientsOnly;
            return this;
        }

        /**
         * The flag indicating whether to prohibit public clients from making
         * token exchange requests.
         */
        public Builder tokenExchangeByConfidentialClientsOnly(@Nullable Boolean tokenExchangeByConfidentialClientsOnly) {
            this.tokenExchangeByConfidentialClientsOnly = tokenExchangeByConfidentialClientsOnly;
            return this;
        }

        /**
         * The flag indicating whether to prohibit clients that have no explicit
         * permission from making token exchange requests.
         */
        public Builder tokenExchangeByPermittedClientsOnly(@Nullable Boolean tokenExchangeByPermittedClientsOnly) {
            this.tokenExchangeByPermittedClientsOnly = tokenExchangeByPermittedClientsOnly;
            return this;
        }

        /**
         * The flag indicating whether to reject token exchange requests which
         * use encrypted JWTs as input tokens.
         */
        public Builder tokenExchangeEncryptedJwtRejected(@Nullable Boolean tokenExchangeEncryptedJwtRejected) {
            this.tokenExchangeEncryptedJwtRejected = tokenExchangeEncryptedJwtRejected;
            return this;
        }

        /**
         * The flag indicating whether to reject token exchange requests which
         * use unsigned JWTs as input tokens.
         */
        public Builder tokenExchangeUnsignedJwtRejected(@Nullable Boolean tokenExchangeUnsignedJwtRejected) {
            this.tokenExchangeUnsignedJwtRejected = tokenExchangeUnsignedJwtRejected;
            return this;
        }

        /**
         * The flag indicating whether to prohibit unidentifiable clients from
         * using the grant type "urn:ietf:params:oauth:grant-type:jwt-bearer".
         */
        public Builder jwtGrantByIdentifiableClientsOnly(@Nullable Boolean jwtGrantByIdentifiableClientsOnly) {
            this.jwtGrantByIdentifiableClientsOnly = jwtGrantByIdentifiableClientsOnly;
            return this;
        }

        /**
         * The flag indicating whether to reject token requests that use an
         * encrypted JWT as an authorization grant with the grant type
         * "urn:ietf:params:oauth:grant-type:jwt-bearer".
         */
        public Builder jwtGrantEncryptedJwtRejected(@Nullable Boolean jwtGrantEncryptedJwtRejected) {
            this.jwtGrantEncryptedJwtRejected = jwtGrantEncryptedJwtRejected;
            return this;
        }

        /**
         * The flag indicating whether to reject token requests that use an
         * unsigned JWT as an authorization grant with the grant type
         * "urn:ietf:params:oauth:grant-type:jwt-bearer".
         */
        public Builder jwtGrantUnsignedJwtRejected(@Nullable Boolean jwtGrantUnsignedJwtRejected) {
            this.jwtGrantUnsignedJwtRejected = jwtGrantUnsignedJwtRejected;
            return this;
        }

        /**
         * The flag indicating whether to block DCR (Dynamic Client Registration)
         * requests whose "software_id" has already been used previously.
         */
        public Builder dcrDuplicateSoftwareIdBlocked(@Nullable Boolean dcrDuplicateSoftwareIdBlocked) {
            this.dcrDuplicateSoftwareIdBlocked = dcrDuplicateSoftwareIdBlocked;
            return this;
        }

        /**
         * The trust anchors that are referenced when this service resolves
         * trust chains of relying parties.
         * 
         * <p>If this property is empty, client registration fails regardless of
         * whether its type is `automatic` or `explicit`. It means
         * that OpenID Connect Federation 1.0 does not work.
         */
        public Builder trustAnchors(@Nullable List<ServiceUpdateApiTrustAnchorRequest> trustAnchors) {
            this.trustAnchors = trustAnchors;
            return this;
        }

        /**
         * The flag indicating whether the openid scope should be dropped from
         * scopes list assigned to access token issued when a refresh token grant
         * is used.
         */
        public Builder openidDroppedOnRefreshWithoutOfflineAccess(@Nullable Boolean openidDroppedOnRefreshWithoutOfflineAccess) {
            this.openidDroppedOnRefreshWithoutOfflineAccess = openidDroppedOnRefreshWithoutOfflineAccess;
            return this;
        }

        /**
         * Supported document check methods. This property corresponds to the `documents_check_methods_supported`
         * server metadata which was added by the fourth implementer's draft of OpenID Connect for Identity
         * Assurance 1.0.
         */
        public Builder supportedDocumentsCheckMethods(@Nullable List<String> supportedDocumentsCheckMethods) {
            this.supportedDocumentsCheckMethods = supportedDocumentsCheckMethods;
            return this;
        }

        /**
         * The flag indicating whether this service signs responses from the resource server.
         */
        public Builder rsResponseSigned(@Nullable Boolean rsResponseSigned) {
            this.rsResponseSigned = rsResponseSigned;
            return this;
        }

        /**
         * The duration of `c_nonce`.
         */
        public Builder cnonceDuration(@Nullable Long cnonceDuration) {
            this.cnonceDuration = cnonceDuration;
            return this;
        }

        /**
         * Whether to require DPoP proof JWTs to include the `nonce` claim
         * whenever they are presented.
         */
        public Builder dpopNonceRequired(@Nullable Boolean dpopNonceRequired) {
            this.dpopNonceRequired = dpopNonceRequired;
            return this;
        }

        /**
         * Get the flag indicating whether the feature of Verifiable Credentials
         * for this service is enabled or not.
         */
        public Builder verifiableCredentialsEnabled(@Nullable Boolean verifiableCredentialsEnabled) {
            this.verifiableCredentialsEnabled = verifiableCredentialsEnabled;
            return this;
        }

        /**
         * The URL at which the JWK Set document of the credential issuer is
         * exposed.
         */
        public Builder credentialJwksUri(@Nullable String credentialJwksUri) {
            this.credentialJwksUri = credentialJwksUri;
            return this;
        }

        /**
         * The default duration of credential offers in seconds.
         */
        public Builder credentialOfferDuration(@Nullable Long credentialOfferDuration) {
            this.credentialOfferDuration = credentialOfferDuration;
            return this;
        }

        /**
         * The duration of nonce values for DPoP proof JWTs in seconds.
         */
        public Builder dpopNonceDuration(@Nullable Long dpopNonceDuration) {
            this.dpopNonceDuration = dpopNonceDuration;
            return this;
        }

        /**
         * The flag indicating whether token requests using the pre-authorized
         * code grant flow by unidentifiable clients are allowed.
         */
        public Builder preAuthorizedGrantAnonymousAccessSupported(@Nullable Boolean preAuthorizedGrantAnonymousAccessSupported) {
            this.preAuthorizedGrantAnonymousAccessSupported = preAuthorizedGrantAnonymousAccessSupported;
            return this;
        }

        /**
         * The duration of transaction ID in seconds that may be issued as a
         * result of a credential request or a batch credential request.
         */
        public Builder credentialTransactionDuration(@Nullable Long credentialTransactionDuration) {
            this.credentialTransactionDuration = credentialTransactionDuration;
            return this;
        }

        /**
         * The key ID of the key for signing introspection responses.
         */
        public Builder introspectionSignatureKeyId(@Nullable String introspectionSignatureKeyId) {
            this.introspectionSignatureKeyId = introspectionSignatureKeyId;
            return this;
        }

        /**
         * The key ID of the key for signing introspection responses.
         */
        public Builder resourceSignatureKeyId(@Nullable String resourceSignatureKeyId) {
            this.resourceSignatureKeyId = resourceSignatureKeyId;
            return this;
        }

        /**
         * The default length of user PINs.
         */
        public Builder userPinLength(@Nullable Integer userPinLength) {
            this.userPinLength = userPinLength;
            return this;
        }

        /**
         * The supported `prompt` values.
         */
        public Builder supportedPromptValues(@Nullable List<ServiceUpdateApiSupportedPromptValueRequest> supportedPromptValues) {
            this.supportedPromptValues = supportedPromptValues;
            return this;
        }

        /**
         * The flag indicating whether to enable the feature of ID token
         * reissuance in the refresh token flow.
         */
        public Builder idTokenReissuable(@Nullable Boolean idTokenReissuable) {
            this.idTokenReissuable = idTokenReissuable;
            return this;
        }

        /**
         * The JWK Set document containing private keys that are used to sign
         * verifiable credentials.
         */
        public Builder credentialJwks(@Nullable String credentialJwks) {
            this.credentialJwks = credentialJwks;
            return this;
        }

        /**
         * FAPI modes for this service.
         * 
         * <p>When the value of this property is not `null`, Authlete always processes requests to this service based
         * on the specified FAPI modes if the FAPI feature is enabled in Authlete and the FAPI profile is supported
         * by this service.
         * 
         * <p>For instance, when this property is set to an array containing `FAPI1_ADVANCED` only, Authlete always
         * processes requests to this service based on "Financial-grade API Security Profile 1.0 - Part 2:
         * Advanced" if the FAPI feature is enabled in Authlete and the FAPI profile is supported by this service.
         */
        public Builder fapiModes(@Nullable List<ServiceUpdateApiFapiModeRequest> fapiModes) {
            this.fapiModes = fapiModes;
            return this;
        }

        /**
         * The default duration of verifiable credentials in seconds.
         */
        public Builder credentialDuration(@Nullable Long credentialDuration) {
            this.credentialDuration = credentialDuration;
            return this;
        }

        public Builder credentialIssuerMetadata(@Nullable ServiceUpdateApiCredentialIssuerMetadataRequest credentialIssuerMetadata) {
            this.credentialIssuerMetadata = credentialIssuerMetadata;
            return this;
        }

        /**
         * The type of the `aud` claim in ID tokens.
         */
        public Builder idTokenAudType(@Nullable String idTokenAudType) {
            this.idTokenAudType = idTokenAudType;
            return this;
        }

        public ServiceUpdateApiRequestBody build() {
            return new ServiceUpdateApiRequestBody(
                serviceName, issuer, description,
                clientIdAliasEnabled, metadata, authenticationCallbackEndpoint,
                authenticationCallbackApiKey, authenticationCallbackApiSecret, supportedGrantTypes,
                supportedResponseTypes, supportedAuthorizationDetailsTypes, supportedServiceProfiles,
                errorDescriptionOmitted, errorUriOmitted, authorizationEndpoint,
                directAuthorizationEndpointEnabled, supportedUiLocales, supportedDisplays,
                pkceRequired, pkceS256Required, authorizationResponseDuration,
                tokenEndpoint, directTokenEndpointEnabled, supportedTokenAuthMethods,
                missingClientIdAllowed, revocationEndpoint, directRevocationEndpointEnabled,
                supportedRevocationAuthMethods, introspectionEndpoint, directIntrospectionEndpointEnabled,
                supportedIntrospectionAuthMethods, pushedAuthReqEndpoint, pushedAuthReqDuration,
                parRequired, requestObjectRequired, traditionalRequestObjectProcessingApplied,
                mutualTlsValidatePkiCertChain, trustedRootCertificates, mtlsEndpointAliases,
                accessTokenType, tlsClientCertificateBoundAccessTokens, accessTokenDuration,
                singleAccessTokenPerSubject, accessTokenSignAlg, accessTokenSignatureKeyId,
                refreshTokenDuration, refreshTokenDurationKept, refreshTokenDurationReset,
                refreshTokenKept, supportedScopes, scopeRequired,
                idTokenDuration, allowableClockSkew, supportedClaimTypes,
                supportedClaimLocales, supportedClaims, claimShortcutRestrictive,
                jwksUri, directJwksEndpointEnabled, jwks,
                idTokenSignatureKeyId, userInfoSignatureKeyId, authorizationSignatureKeyId,
                userInfoEndpoint, directUserInfoEndpointEnabled, dynamicRegistrationSupported,
                registrationEndpoint, registrationManagementEndpoint, policyUri,
                tosUri, serviceDocumentation, backchannelAuthenticationEndpoint,
                supportedBackchannelTokenDeliveryModes, backchannelAuthReqIdDuration, backchannelPollingInterval,
                backchannelUserCodeParameterSupported, backchannelBindingMessageRequiredInFapi, deviceAuthorizationEndpoint,
                deviceVerificationUri, deviceVerificationUriComplete, deviceFlowCodeDuration,
                deviceFlowPollingInterval, userCodeCharset, userCodeLength,
                supportedTrustFrameworks, supportedEvidence, supportedIdentityDocuments,
                supportedVerificationMethods, supportedVerifiedClaims, verifiedClaimsValidationSchemaSet,
                attributes, nbfOptional, issSuppressed,
                supportedCustomClientMetadata, tokenExpirationLinked, frontChannelRequestObjectEncryptionRequired,
                requestObjectEncryptionAlgMatchRequired, requestObjectEncryptionEncMatchRequired, hsmEnabled,
                hsks, grantManagementEndpoint, grantManagementActionRequired,
                unauthorizedOnClientConfigSupported, dcrScopeUsedAsRequestable, endSessionEndpoint,
                loopbackRedirectionUriVariable, requestObjectAudienceChecked, accessTokenForExternalAttachmentEmbedded,
                authorityHints, federationEnabled, federationJwks,
                federationSignatureKeyId, federationConfigurationDuration, federationRegistrationEndpoint,
                organizationName, predefinedTransformedClaims, refreshTokenIdempotent,
                signedJwksUri, supportedAttachments, supportedDigestAlgorithms,
                supportedDocuments, supportedDocumentsMethods, supportedDocumentsValidationMethods,
                supportedDocumentsVerificationMethods, supportedElectronicRecords, supportedClientRegistrationTypes,
                tokenExchangeByIdentifiableClientsOnly, tokenExchangeByConfidentialClientsOnly, tokenExchangeByPermittedClientsOnly,
                tokenExchangeEncryptedJwtRejected, tokenExchangeUnsignedJwtRejected, jwtGrantByIdentifiableClientsOnly,
                jwtGrantEncryptedJwtRejected, jwtGrantUnsignedJwtRejected, dcrDuplicateSoftwareIdBlocked,
                trustAnchors, openidDroppedOnRefreshWithoutOfflineAccess, supportedDocumentsCheckMethods,
                rsResponseSigned, cnonceDuration, dpopNonceRequired,
                verifiableCredentialsEnabled, credentialJwksUri, credentialOfferDuration,
                dpopNonceDuration, preAuthorizedGrantAnonymousAccessSupported, credentialTransactionDuration,
                introspectionSignatureKeyId, resourceSignatureKeyId, userPinLength,
                supportedPromptValues, idTokenReissuable, credentialJwks,
                fapiModes, credentialDuration, credentialIssuerMetadata,
                idTokenAudType);
        }

    }
}
