/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package org.openapis.openapi;

import static org.openapis.openapi.operations.Operations.RequestOperation;

import jakarta.annotation.Nonnull;
import java.lang.Exception;
import java.lang.String;
import org.openapis.openapi.models.components.1api1Percent7BserviceIdPercent7D1auth1userinfo1issuePostRequestBodyContentApplication1jsonSchema;
import org.openapis.openapi.models.components.1api1Percent7BserviceIdPercent7D1auth1userinfoPostRequestBodyContentApplication1jsonSchema;
import org.openapis.openapi.models.operations.AuthUserinfoApiFormRequest;
import org.openapis.openapi.models.operations.AuthUserinfoApiFormRequestBuilder;
import org.openapis.openapi.models.operations.AuthUserinfoApiFormResponse;
import org.openapis.openapi.models.operations.AuthUserinfoApiRequest;
import org.openapis.openapi.models.operations.AuthUserinfoApiRequestBody;
import org.openapis.openapi.models.operations.AuthUserinfoApiRequestBuilder;
import org.openapis.openapi.models.operations.AuthUserinfoApiResponse;
import org.openapis.openapi.models.operations.AuthUserinfoIssueApiFormRequest;
import org.openapis.openapi.models.operations.AuthUserinfoIssueApiFormRequestBuilder;
import org.openapis.openapi.models.operations.AuthUserinfoIssueApiFormResponse;
import org.openapis.openapi.models.operations.AuthUserinfoIssueApiRequest;
import org.openapis.openapi.models.operations.AuthUserinfoIssueApiRequestBody;
import org.openapis.openapi.models.operations.AuthUserinfoIssueApiRequestBuilder;
import org.openapis.openapi.models.operations.AuthUserinfoIssueApiResponse;
import org.openapis.openapi.operations.AuthUserinfoApiFormOperation;
import org.openapis.openapi.operations.AuthUserinfoApiOperation;
import org.openapis.openapi.operations.AuthUserinfoIssueApiFormOperation;
import org.openapis.openapi.operations.AuthUserinfoIssueApiOperation;


public class Userinfo {
    private final SDKConfiguration sdkConfiguration;

    Userinfo(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
    }

    /**
     * Process UserInfo Request
     * 
     * <p>This API gathers information about a user.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)
     * of the authorization server in order to get information about the user that is associated with
     * an access token.
     * 
     * <p>The response from `/auth/userinfo` API has various parameters. Among them, it is `action` parameter
     * that the authorization server implementation should check first because it denotes the next action
     * that the authorization server implementation should take. According to the value of `action`, the
     * service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete. In either case, from the
     * viewpoint of the client application, it is an error on the server side. Therefore, the service
     * implementation should generate a response to the client application with HTTP status of "500 Internal
     * Server Error".
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)
     * (OAuth 2.0 Bearer Token Usage) so the userinfo endpoint implementation can use the value of `responseContent`
     * as the value of`WWW-Authenticate` header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * does not contain an access token (= the request from the authorization server implementation to
     * Authlete does not contain `token` parameter).
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format
     * of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the
     * userinfo endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**UNAUTHORIZED**
     * 
     * <p>When the value of `action` is `UNAUTHORIZED`, it means that the access token does not exist, has
     * expired, or is not associated with any subject (= any user account).
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 401 Unauthorized
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORBIDDEN**
     * 
     * <p>When the value of `action` is `FORBIDDEN`, it means that the access token does not include the
     * `openid` scope.
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)
     * (OAuth 2.0 Bearer Token Usage) so the userinfo endpoint implementation can use the value of `responseContent`
     * as the value of`WWW-Authenticate` header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 403 Forbidden
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**OK**
     * 
     * <p>When the value of `action` is `OK`, it means that the access token which the client application
     * presented is valid. To be concrete, it means that the access token exists, has not expired, includes
     * the openid scope, and is associated with a subject (= a user account).
     * 
     * <p>What the userinfo endpoint implementation should do next is to collect information about the subject
     * (user) from your database. The value of the `subject` is contained in the subject parameter in the
     * response from this API and the names of data, i.e., the claims names are contained in the claims
     * parameter in the response. For example, if the `subject` parameter is `joe123` and the claims
     * parameter is `[ "given_name", "email" ]`, you need to extract information about joe123's given name
     * and email from your database.
     * 
     * <p>Then, call Authlete's `/auth/userinfo/issue` API with the collected information and the access token
     * in order to make Authlete generate an ID token.
     * 
     * <p>If an error occurred during the above steps, generate an error response to the client. The response
     * should comply with [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750). For example, if the
     * subject associated with the access token does not exist in your database any longer, you may feel
     * like generating a response like below.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: Bearer error="invalid_token",
     *  error_description="The subject associated with the access token does not exist."
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>Also, an error might occur on database access. If you treat the error as an internal server error,
     * then the response would be like the following.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: Bearer error="server_error",
     *  error_description="Failed to extract information about the subject from the database."
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * &lt;/details&gt;
     * 
     * @return The call builder
     */
    public AuthUserinfoApiRequestBuilder get() {
        return new AuthUserinfoApiRequestBuilder(sdkConfiguration);
    }

    /**
     * Process UserInfo Request
     * 
     * <p>This API gathers information about a user.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)
     * of the authorization server in order to get information about the user that is associated with
     * an access token.
     * 
     * <p>The response from `/auth/userinfo` API has various parameters. Among them, it is `action` parameter
     * that the authorization server implementation should check first because it denotes the next action
     * that the authorization server implementation should take. According to the value of `action`, the
     * service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete. In either case, from the
     * viewpoint of the client application, it is an error on the server side. Therefore, the service
     * implementation should generate a response to the client application with HTTP status of "500 Internal
     * Server Error".
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)
     * (OAuth 2.0 Bearer Token Usage) so the userinfo endpoint implementation can use the value of `responseContent`
     * as the value of`WWW-Authenticate` header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * does not contain an access token (= the request from the authorization server implementation to
     * Authlete does not contain `token` parameter).
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format
     * of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the
     * userinfo endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**UNAUTHORIZED**
     * 
     * <p>When the value of `action` is `UNAUTHORIZED`, it means that the access token does not exist, has
     * expired, or is not associated with any subject (= any user account).
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 401 Unauthorized
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORBIDDEN**
     * 
     * <p>When the value of `action` is `FORBIDDEN`, it means that the access token does not include the
     * `openid` scope.
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)
     * (OAuth 2.0 Bearer Token Usage) so the userinfo endpoint implementation can use the value of `responseContent`
     * as the value of`WWW-Authenticate` header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 403 Forbidden
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**OK**
     * 
     * <p>When the value of `action` is `OK`, it means that the access token which the client application
     * presented is valid. To be concrete, it means that the access token exists, has not expired, includes
     * the openid scope, and is associated with a subject (= a user account).
     * 
     * <p>What the userinfo endpoint implementation should do next is to collect information about the subject
     * (user) from your database. The value of the `subject` is contained in the subject parameter in the
     * response from this API and the names of data, i.e., the claims names are contained in the claims
     * parameter in the response. For example, if the `subject` parameter is `joe123` and the claims
     * parameter is `[ "given_name", "email" ]`, you need to extract information about joe123's given name
     * and email from your database.
     * 
     * <p>Then, call Authlete's `/auth/userinfo/issue` API with the collected information and the access token
     * in order to make Authlete generate an ID token.
     * 
     * <p>If an error occurred during the above steps, generate an error response to the client. The response
     * should comply with [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750). For example, if the
     * subject associated with the access token does not exist in your database any longer, you may feel
     * like generating a response like below.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: Bearer error="invalid_token",
     *  error_description="The subject associated with the access token does not exist."
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>Also, an error might occur on database access. If you treat the error as an internal server error,
     * then the response would be like the following.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: Bearer error="server_error",
     *  error_description="Failed to extract information about the subject from the database."
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * &lt;/details&gt;
     * 
     * @param serviceId A service ID.
     * @param requestBody 
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public AuthUserinfoApiResponse get(@Nonnull String serviceId, @Nonnull AuthUserinfoApiRequestBody requestBody) throws Exception {
        AuthUserinfoApiRequest request = new AuthUserinfoApiRequest(serviceId, requestBody);
        RequestOperation<AuthUserinfoApiRequest, AuthUserinfoApiResponse> operation
              = new AuthUserinfoApiOperation(sdkConfiguration);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Process UserInfo Request
     * 
     * <p>This API gathers information about a user.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)
     * of the authorization server in order to get information about the user that is associated with
     * an access token.
     * 
     * <p>The response from `/auth/userinfo` API has various parameters. Among them, it is `action` parameter
     * that the authorization server implementation should check first because it denotes the next action
     * that the authorization server implementation should take. According to the value of `action`, the
     * service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete. In either case, from the
     * viewpoint of the client application, it is an error on the server side. Therefore, the service
     * implementation should generate a response to the client application with HTTP status of "500 Internal
     * Server Error".
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)
     * (OAuth 2.0 Bearer Token Usage) so the userinfo endpoint implementation can use the value of `responseContent`
     * as the value of`WWW-Authenticate` header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * does not contain an access token (= the request from the authorization server implementation to
     * Authlete does not contain `token` parameter).
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format
     * of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the
     * userinfo endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**UNAUTHORIZED**
     * 
     * <p>When the value of `action` is `UNAUTHORIZED`, it means that the access token does not exist, has
     * expired, or is not associated with any subject (= any user account).
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 401 Unauthorized
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORBIDDEN**
     * 
     * <p>When the value of `action` is `FORBIDDEN`, it means that the access token does not include the
     * `openid` scope.
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)
     * (OAuth 2.0 Bearer Token Usage) so the userinfo endpoint implementation can use the value of `responseContent`
     * as the value of`WWW-Authenticate` header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 403 Forbidden
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**OK**
     * 
     * <p>When the value of `action` is `OK`, it means that the access token which the client application
     * presented is valid. To be concrete, it means that the access token exists, has not expired, includes
     * the openid scope, and is associated with a subject (= a user account).
     * 
     * <p>What the userinfo endpoint implementation should do next is to collect information about the subject
     * (user) from your database. The value of the `subject` is contained in the subject parameter in the
     * response from this API and the names of data, i.e., the claims names are contained in the claims
     * parameter in the response. For example, if the `subject` parameter is `joe123` and the claims
     * parameter is `[ "given_name", "email" ]`, you need to extract information about joe123's given name
     * and email from your database.
     * 
     * <p>Then, call Authlete's `/auth/userinfo/issue` API with the collected information and the access token
     * in order to make Authlete generate an ID token.
     * 
     * <p>If an error occurred during the above steps, generate an error response to the client. The response
     * should comply with [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750). For example, if the
     * subject associated with the access token does not exist in your database any longer, you may feel
     * like generating a response like below.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: Bearer error="invalid_token",
     *  error_description="The subject associated with the access token does not exist."
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>Also, an error might occur on database access. If you treat the error as an internal server error,
     * then the response would be like the following.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: Bearer error="server_error",
     *  error_description="Failed to extract information about the subject from the database."
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * &lt;/details&gt;
     * 
     * @return The call builder
     */
    public AuthUserinfoApiFormRequestBuilder getForm() {
        return new AuthUserinfoApiFormRequestBuilder(sdkConfiguration);
    }

    /**
     * Process UserInfo Request
     * 
     * <p>This API gathers information about a user.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)
     * of the authorization server in order to get information about the user that is associated with
     * an access token.
     * 
     * <p>The response from `/auth/userinfo` API has various parameters. Among them, it is `action` parameter
     * that the authorization server implementation should check first because it denotes the next action
     * that the authorization server implementation should take. According to the value of `action`, the
     * service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete. In either case, from the
     * viewpoint of the client application, it is an error on the server side. Therefore, the service
     * implementation should generate a response to the client application with HTTP status of "500 Internal
     * Server Error".
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)
     * (OAuth 2.0 Bearer Token Usage) so the userinfo endpoint implementation can use the value of `responseContent`
     * as the value of`WWW-Authenticate` header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * does not contain an access token (= the request from the authorization server implementation to
     * Authlete does not contain `token` parameter).
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format
     * of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the
     * userinfo endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**UNAUTHORIZED**
     * 
     * <p>When the value of `action` is `UNAUTHORIZED`, it means that the access token does not exist, has
     * expired, or is not associated with any subject (= any user account).
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 401 Unauthorized
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORBIDDEN**
     * 
     * <p>When the value of `action` is `FORBIDDEN`, it means that the access token does not include the
     * `openid` scope.
     * 
     * <p>The value of `responseContent` is a string which describes the error in the format of [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)
     * (OAuth 2.0 Bearer Token Usage) so the userinfo endpoint implementation can use the value of `responseContent`
     * as the value of`WWW-Authenticate` header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 403 Forbidden
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**OK**
     * 
     * <p>When the value of `action` is `OK`, it means that the access token which the client application
     * presented is valid. To be concrete, it means that the access token exists, has not expired, includes
     * the openid scope, and is associated with a subject (= a user account).
     * 
     * <p>What the userinfo endpoint implementation should do next is to collect information about the subject
     * (user) from your database. The value of the `subject` is contained in the subject parameter in the
     * response from this API and the names of data, i.e., the claims names are contained in the claims
     * parameter in the response. For example, if the `subject` parameter is `joe123` and the claims
     * parameter is `[ "given_name", "email" ]`, you need to extract information about joe123's given name
     * and email from your database.
     * 
     * <p>Then, call Authlete's `/auth/userinfo/issue` API with the collected information and the access token
     * in order to make Authlete generate an ID token.
     * 
     * <p>If an error occurred during the above steps, generate an error response to the client. The response
     * should comply with [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750). For example, if the
     * subject associated with the access token does not exist in your database any longer, you may feel
     * like generating a response like below.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: Bearer error="invalid_token",
     *  error_description="The subject associated with the access token does not exist."
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>Also, an error might occur on database access. If you treat the error as an internal server error,
     * then the response would be like the following.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: Bearer error="server_error",
     *  error_description="Failed to extract information about the subject from the database."
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * &lt;/details&gt;
     * 
     * @param serviceId A service ID.
     * @param 1api1Percent7BserviceIdPercent7D1auth1userinfoPostRequestBodyContentApplication1jsonSchema 
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public AuthUserinfoApiFormResponse getForm(@Nonnull String serviceId, @Nonnull 1api1Percent7BserviceIdPercent7D1auth1userinfoPostRequestBodyContentApplication1jsonSchema 1api1Percent7BserviceIdPercent7D1auth1userinfoPostRequestBodyContentApplication1jsonSchema) throws Exception {
        AuthUserinfoApiFormRequest request = new AuthUserinfoApiFormRequest(serviceId, 1api1Percent7BserviceIdPercent7D1auth1userinfoPostRequestBodyContentApplication1jsonSchema);
        RequestOperation<AuthUserinfoApiFormRequest, AuthUserinfoApiFormResponse> operation
              = new AuthUserinfoApiFormOperation(sdkConfiguration);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Issue UserInfo Response
     * 
     * <p>This API generates an ID token.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)
     * of the authorization server in order to generate an ID token. Before calling this API, a valid
     * response from `/auth/userinfo` API must be obtained. Then, call this API with the access token
     * contained in the response and the claims values of the user (subject) associated with the access
     * token. See **OK** written in the description of `/auth/userinfo` API for details.
     * 
     * <p>The response from `/auth/userinfo/issue` API has various parameters. Among them, it is `action`
     * parameter that the authorization server implementation should check first because it denotes the
     * next action that the authorization server implementation should take. According to the value of
     * `action`, the service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete. In either case, from the
     * viewpoint of the client application, it is an error on the server side. Therefore, the service
     * implementation should generate a response to the client application with HTTP status of "500 Internal
     * Server Error".
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * does not contain an access token (= the request from the authorization server implementation to
     * Authlete does not contain `token` parameter).
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**UNAUTHORIZED**
     * 
     * <p>When the value of `action` is `UNAUTHORIZED`, it means that the access token does not exist, has
     * expired, or is not associated with any subject (= any user account).
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 401 Unauthorized
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORBIDDEN**
     * 
     * <p>When the value of `action` is `FORBIDDEN`, it means that the access token does not include the
     * `openid` scope.
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 403 Forbidden
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**JSON**
     * 
     * <p>When the value of `action` is `JSON`, it means that the access token which the client application
     * presented is valid and an ID token was successfully generated in the format of JSON.
     * 
     * <p>The userinfo endpoint implementation is expected to generate a response to the client application.
     * The content type of the response must be `application/json` and the response body must be an ID
     * token in JSON format.
     * 
     * <p>The value of `responseContent` is the ID token in JSON format when `action` is `JSON`, so
     * a response to the client can be built like below.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Cache-Control: no-store
     * Pragma: no-cache
     * Content-Type: application/json;charset=UTF-8
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>**JWT**
     * 
     * <p>When the value of `action` is `JWT`, it means that the access token which the client application
     * presented is valid and an ID token was successfully generated in the format of JWT (JSON Web Token)
     * ([RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)).
     * 
     * <p>The userinfo endpoint implementation is expected to generate a response to the client application.
     * The content type of the response must be `application/jwt` and the response body must be an ID
     * token in JWT format.
     * 
     * <p>The value of `responseContent` is the ID token in JSON format when `action` is `JWT`, so a response
     * to the client can be built like below.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Cache-Control: no-store
     * Pragma: no-cache
     * Content-Type: application/jwt
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>&lt;/details&gt;
     * 
     * @return The call builder
     */
    public AuthUserinfoIssueApiRequestBuilder issue() {
        return new AuthUserinfoIssueApiRequestBuilder(sdkConfiguration);
    }

    /**
     * Issue UserInfo Response
     * 
     * <p>This API generates an ID token.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)
     * of the authorization server in order to generate an ID token. Before calling this API, a valid
     * response from `/auth/userinfo` API must be obtained. Then, call this API with the access token
     * contained in the response and the claims values of the user (subject) associated with the access
     * token. See **OK** written in the description of `/auth/userinfo` API for details.
     * 
     * <p>The response from `/auth/userinfo/issue` API has various parameters. Among them, it is `action`
     * parameter that the authorization server implementation should check first because it denotes the
     * next action that the authorization server implementation should take. According to the value of
     * `action`, the service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete. In either case, from the
     * viewpoint of the client application, it is an error on the server side. Therefore, the service
     * implementation should generate a response to the client application with HTTP status of "500 Internal
     * Server Error".
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * does not contain an access token (= the request from the authorization server implementation to
     * Authlete does not contain `token` parameter).
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**UNAUTHORIZED**
     * 
     * <p>When the value of `action` is `UNAUTHORIZED`, it means that the access token does not exist, has
     * expired, or is not associated with any subject (= any user account).
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 401 Unauthorized
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORBIDDEN**
     * 
     * <p>When the value of `action` is `FORBIDDEN`, it means that the access token does not include the
     * `openid` scope.
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 403 Forbidden
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**JSON**
     * 
     * <p>When the value of `action` is `JSON`, it means that the access token which the client application
     * presented is valid and an ID token was successfully generated in the format of JSON.
     * 
     * <p>The userinfo endpoint implementation is expected to generate a response to the client application.
     * The content type of the response must be `application/json` and the response body must be an ID
     * token in JSON format.
     * 
     * <p>The value of `responseContent` is the ID token in JSON format when `action` is `JSON`, so
     * a response to the client can be built like below.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Cache-Control: no-store
     * Pragma: no-cache
     * Content-Type: application/json;charset=UTF-8
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>**JWT**
     * 
     * <p>When the value of `action` is `JWT`, it means that the access token which the client application
     * presented is valid and an ID token was successfully generated in the format of JWT (JSON Web Token)
     * ([RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)).
     * 
     * <p>The userinfo endpoint implementation is expected to generate a response to the client application.
     * The content type of the response must be `application/jwt` and the response body must be an ID
     * token in JWT format.
     * 
     * <p>The value of `responseContent` is the ID token in JSON format when `action` is `JWT`, so a response
     * to the client can be built like below.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Cache-Control: no-store
     * Pragma: no-cache
     * Content-Type: application/jwt
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>&lt;/details&gt;
     * 
     * @param serviceId A service ID.
     * @param requestBody 
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public AuthUserinfoIssueApiResponse issue(@Nonnull String serviceId, @Nonnull AuthUserinfoIssueApiRequestBody requestBody) throws Exception {
        AuthUserinfoIssueApiRequest request = new AuthUserinfoIssueApiRequest(serviceId, requestBody);
        RequestOperation<AuthUserinfoIssueApiRequest, AuthUserinfoIssueApiResponse> operation
              = new AuthUserinfoIssueApiOperation(sdkConfiguration);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Issue UserInfo Response
     * 
     * <p>This API generates an ID token.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)
     * of the authorization server in order to generate an ID token. Before calling this API, a valid
     * response from `/auth/userinfo` API must be obtained. Then, call this API with the access token
     * contained in the response and the claims values of the user (subject) associated with the access
     * token. See **OK** written in the description of `/auth/userinfo` API for details.
     * 
     * <p>The response from `/auth/userinfo/issue` API has various parameters. Among them, it is `action`
     * parameter that the authorization server implementation should check first because it denotes the
     * next action that the authorization server implementation should take. According to the value of
     * `action`, the service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete. In either case, from the
     * viewpoint of the client application, it is an error on the server side. Therefore, the service
     * implementation should generate a response to the client application with HTTP status of "500 Internal
     * Server Error".
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * does not contain an access token (= the request from the authorization server implementation to
     * Authlete does not contain `token` parameter).
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**UNAUTHORIZED**
     * 
     * <p>When the value of `action` is `UNAUTHORIZED`, it means that the access token does not exist, has
     * expired, or is not associated with any subject (= any user account).
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 401 Unauthorized
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORBIDDEN**
     * 
     * <p>When the value of `action` is `FORBIDDEN`, it means that the access token does not include the
     * `openid` scope.
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 403 Forbidden
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**JSON**
     * 
     * <p>When the value of `action` is `JSON`, it means that the access token which the client application
     * presented is valid and an ID token was successfully generated in the format of JSON.
     * 
     * <p>The userinfo endpoint implementation is expected to generate a response to the client application.
     * The content type of the response must be `application/json` and the response body must be an ID
     * token in JSON format.
     * 
     * <p>The value of `responseContent` is the ID token in JSON format when `action` is `JSON`, so
     * a response to the client can be built like below.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Cache-Control: no-store
     * Pragma: no-cache
     * Content-Type: application/json;charset=UTF-8
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>**JWT**
     * 
     * <p>When the value of `action` is `JWT`, it means that the access token which the client application
     * presented is valid and an ID token was successfully generated in the format of JWT (JSON Web Token)
     * ([RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)).
     * 
     * <p>The userinfo endpoint implementation is expected to generate a response to the client application.
     * The content type of the response must be `application/jwt` and the response body must be an ID
     * token in JWT format.
     * 
     * <p>The value of `responseContent` is the ID token in JSON format when `action` is `JWT`, so a response
     * to the client can be built like below.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Cache-Control: no-store
     * Pragma: no-cache
     * Content-Type: application/jwt
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>&lt;/details&gt;
     * 
     * @return The call builder
     */
    public AuthUserinfoIssueApiFormRequestBuilder issueForm() {
        return new AuthUserinfoIssueApiFormRequestBuilder(sdkConfiguration);
    }

    /**
     * Issue UserInfo Response
     * 
     * <p>This API generates an ID token.
     * 
     * <p>&lt;br&gt;
     * &lt;details&gt;
     * &lt;summary&gt;Description&lt;/summary&gt;
     * 
     * <p>This API is supposed to be called from within the implementation of the [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)
     * of the authorization server in order to generate an ID token. Before calling this API, a valid
     * response from `/auth/userinfo` API must be obtained. Then, call this API with the access token
     * contained in the response and the claims values of the user (subject) associated with the access
     * token. See **OK** written in the description of `/auth/userinfo` API for details.
     * 
     * <p>The response from `/auth/userinfo/issue` API has various parameters. Among them, it is `action`
     * parameter that the authorization server implementation should check first because it denotes the
     * next action that the authorization server implementation should take. According to the value of
     * `action`, the service implementation must take the steps described below.
     * 
     * <p>**INTERNAL_SERVER_ERROR**
     * 
     * <p>When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
     * server implementation was wrong or that an error occurred in Authlete. In either case, from the
     * viewpoint of the client application, it is an error on the server side. Therefore, the service
     * implementation should generate a response to the client application with HTTP status of "500 Internal
     * Server Error".
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 500 Internal Server Error
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**BAD_REQUEST**
     * 
     * <p>When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
     * does not contain an access token (= the request from the authorization server implementation to
     * Authlete does not contain `token` parameter).
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 400 Bad Request
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**UNAUTHORIZED**
     * 
     * <p>When the value of `action` is `UNAUTHORIZED`, it means that the access token does not exist, has
     * expired, or is not associated with any subject (= any user account).
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 401 Unauthorized
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**FORBIDDEN**
     * 
     * <p>When the value of `action` is `FORBIDDEN`, it means that the access token does not include the
     * `openid` scope.
     * 
     * <p>The parameter `responseContent` returns a string which describes the error in the format of [RFC
     * 6750](https://datatracker.ietf.org/doc/html/rfc6750) (OAuth 2.0 Bearer Token Usage) so the userinfo
     * endpoint implementation can use the value of `responseContent` as the value of`WWW-Authenticate`
     * header.
     * 
     * <p>The following is an example response which complies with RFC 6750. Note that OpenID Connect Core
     * 1.0 requires that an error response from userinfo endpoint comply with RFC 6750. See [5.3.3. UserInfo
     * Response](https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) for details.
     * 
     * <p>```
     * HTTP/1.1 403 Forbidden
     * WWW-Authenticate: {responseContent}
     * Cache-Control: no-store
     * Pragma: no-cache
     * ```
     * 
     * <p>**JSON**
     * 
     * <p>When the value of `action` is `JSON`, it means that the access token which the client application
     * presented is valid and an ID token was successfully generated in the format of JSON.
     * 
     * <p>The userinfo endpoint implementation is expected to generate a response to the client application.
     * The content type of the response must be `application/json` and the response body must be an ID
     * token in JSON format.
     * 
     * <p>The value of `responseContent` is the ID token in JSON format when `action` is `JSON`, so
     * a response to the client can be built like below.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Cache-Control: no-store
     * Pragma: no-cache
     * Content-Type: application/json;charset=UTF-8
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>**JWT**
     * 
     * <p>When the value of `action` is `JWT`, it means that the access token which the client application
     * presented is valid and an ID token was successfully generated in the format of JWT (JSON Web Token)
     * ([RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)).
     * 
     * <p>The userinfo endpoint implementation is expected to generate a response to the client application.
     * The content type of the response must be `application/jwt` and the response body must be an ID
     * token in JWT format.
     * 
     * <p>The value of `responseContent` is the ID token in JSON format when `action` is `JWT`, so a response
     * to the client can be built like below.
     * 
     * <p>```
     * HTTP/1.1 200 OK
     * Cache-Control: no-store
     * Pragma: no-cache
     * Content-Type: application/jwt
     * 
     * <p>{responseContent}
     * ```
     * 
     * <p>&lt;/details&gt;
     * 
     * @param serviceId A service ID.
     * @param 1api1Percent7BserviceIdPercent7D1auth1userinfo1issuePostRequestBodyContentApplication1jsonSchema 
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public AuthUserinfoIssueApiFormResponse issueForm(@Nonnull String serviceId, @Nonnull 1api1Percent7BserviceIdPercent7D1auth1userinfo1issuePostRequestBodyContentApplication1jsonSchema 1api1Percent7BserviceIdPercent7D1auth1userinfo1issuePostRequestBodyContentApplication1jsonSchema) throws Exception {
        AuthUserinfoIssueApiFormRequest request = new AuthUserinfoIssueApiFormRequest(serviceId, 1api1Percent7BserviceIdPercent7D1auth1userinfo1issuePostRequestBodyContentApplication1jsonSchema);
        RequestOperation<AuthUserinfoIssueApiFormRequest, AuthUserinfoIssueApiFormResponse> operation
              = new AuthUserinfoIssueApiFormOperation(sdkConfiguration);
        return operation.handleResponse(operation.doRequest(request));
    }

}
